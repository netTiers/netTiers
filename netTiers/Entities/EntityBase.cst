<%--
 * $Id: EntityBase.cst,v 1.11 2006/02/28 15:22:56 jcteague Exp $
 * Last modified by $Author$
 * Last modified at $Date$
 * $Revision$

	Written By:
		Ryan Hurdon
	Description:
		This script will create data access layer classes. It requires stored procedures
		created from the procedure script. So for this code to work properly you need to run
		the procedure template, the rowobject template, and the rowcollection template on
		the same table. You can also optionally use the main script which will run them all
		for you.
--%>
<%@ CodeTemplate Src="..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Business object base class"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Connection" Description="Table Object should be based on." %>
<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Connection" Description="Tables of the sytem." %>

<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>

<%@ Property Name="NameSpace" Optional="True" Type="System.String" Category="Style" Description="Object Namespace." %>
	
<%@ Property Name="UsePartialClass" Type="System.Boolean" Default="true" Category="General" Description="Indicates if partial class should be generated." %>
	
<%
	//if (SourceTables == null) SourceTables = new SchemaExplorer.TableSchemaCollection();
	string name;
	string today = DateTime.Now.ToLongDateString();

	
	// Name of the Abstract Class
	string className = GetClassName(SourceTable.Name);
	string collectionClassName = GetCollectionClassName(SourceTable.Name);
	string structName = GetStructName(SourceTable.Name);
	string abstractClassName = UsePartialClass ? className : GetAbstractClassName(SourceTable.Name);

	string constructorAccessModifier = UsePartialClass ? "public" : "protected";


	// Collection of all columns in the table.
	ColumnSchemaCollection cols = SourceTable.Columns;
		
	//Provides information about the indexes contained in the table. 
	//IndexSchemaCollection indexes = SourceTable.Indexes;
		
	ColumnSchemaCollection colsUpdatable = new ColumnSchemaCollection();
	foreach (ColumnSchema column in cols)
	{
		if ( ! IsIdentityColumn(column) && ! IsComputed(column) )
			colsUpdatable.Add(column);
	}
%>
/*
	Code Generated by a tool.
	<%=today%>
	Do not modify, edit the file <%=SourceTable.Name%>.cs instead.
*/
using System;
using System.ComponentModel;
using System.Collections;
using System.Xml.Serialization;

namespace <%=NameSpace%>
{
	#region <%=className%>EventArgs class
	/// <summary>
	/// Provides data for the ColumnChanging and ColumnChanged events.
	/// </summary>
	/// <remarks>
	/// The ColumnChanging and ColumnChanged events occur when a change is made to the value 
	/// of a property of a <see cref="<%=className%>"/> object.
	/// </remarks>
	public class <%=className%>EventArgs : System.EventArgs
	{
		private <%=className%>Column column;
		
		///<summary>
		/// Initalizes a new Instance of the <%=className%>EventArgs class.
		///</summary>
		public <%=className%>EventArgs(<%=className%>Column column)
		{
			this.column = column;
		}
		
		
		///<summary>
		/// The <%=className%>Column that was modified, which has raised the event.
		///</summary>
		///<value cref="<%=className%>Column" />
		public <%=className%>Column Column { get { return this.column; } }
	}
	#endregion
	
	
	///<summary>
	/// Define a delegate for all <%=className%> related events.
	///</summary>
	public delegate void <%=className%>EventHandler(object sender, <%=className%>EventArgs e);
		
	
	///<summary>
	/// An object representation of the '<%=SourceTable.Name%>' table.
	///</summary>
	/// <remarks>
	/// This class is generated by a tool and should never be modified.
    /// All custom implementations should be done in the <see cref="<%=className%>"/> class.
    /// </remarks>
	[Serializable]
	<% if (!UsePartialClass) { %>[EditorBrowsable(EditorBrowsableState.Never)]<% } %>
	public <% if (UsePartialClass) { Response.Write("partial "); } else { Response.Write("abstract "); } %>class <%=abstractClassName%> : System.IComparable, System.ICloneable, IEntity, IEditableObject
	{
		
		#region Variable Declarations
		
		/// <summary>
		/// 	Old the inner data of the entity.
		/// </summary>
		private <%=structName%> entityData; 
		
		/// <summary>
		/// 	Old a backup of the inner data of the entity.
		/// </summary>
		private <%=structName%> backupData; 
		
		private <%=collectionClassName%> parentCollection;
		private bool inTxn = false;

		
		/// <summary>
		/// Occurs when a value is being changed for the specified column.
		/// </summary>	
		public event <%=className%>EventHandler ColumnChanging;
		
		
		/// <summary>
		/// Occurs after a value has been changed for the specified column.
		/// </summary>
		public event <%=className%>EventHandler ColumnChanged;		
		#endregion "Variable Declarations"
		
		#region Constructors
		///<summary>
		/// Creates a new <see cref="<%=abstractClassName%>"/> instance.
		///</summary>
		<%=constructorAccessModifier%> <%=abstractClassName%>()
		{
			this.entityData = new <%=structName%>();
			this.backupData = new <%=structName%>();
		}		
		
		<% if(colsUpdatable.Count > 0) { %>
		///<summary>
		/// Creates a new <see cref="<%=abstractClassName%>"/> instance.
		///</summary>
		<% for (int x=0; x < colsUpdatable.Count; x++) { %>
		///<param name="<%=GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %>"><%=GetColumnXmlComment(colsUpdatable[x],2)%></param>
		<% } %>
		<%=constructorAccessModifier%> <%=abstractClassName%>(<% WrapInit(); for (int x=0; x < colsUpdatable.Count; x++) { %><%= GetCSType(colsUpdatable[x]) %> <%= GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %><%WrapIncr(colsUpdatable[x]); if (x < colsUpdatable.Count -1){%>, <% WrapLine(3); } }// end for %>)
		{
			this.entityData = new <%=structName%>();
			this.backupData = null;
			
			<% for (int x=0; x < colsUpdatable.Count; x++) { %>
			this.entityData.<%= GetPropertyName(colsUpdatable[x]) %> = <%= GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %>;
			<% }// end for %>
		}
		<% } %>
		
		///<summary>
		/// A simple factory method to create a new <see cref="<%=className%>"/> instance.
		///</summary>
		<% for (int x=0; x < colsUpdatable.Count; x++) { %>
		///<param name="<%=GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %>"><%=GetColumnXmlComment(colsUpdatable[x],2)%></param>
		<% } %>
		public static <%=className%> Create<%=className%>(<% WrapInit(); for (int x=0; x < colsUpdatable.Count; x++) { %><%= GetCSType(colsUpdatable[x]) %> <%= GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %><% WrapIncr(colsUpdatable[x]); if (x < colsUpdatable.Count -1){%>, <%  WrapLine(3); } }// end for %>)
		{
			<%=className%> new<%=className%> = new <%=className%>();
			<% for (int x=0; x < colsUpdatable.Count; x++) { %>
			new<%=className%>.<%=GetPropertyName( colsUpdatable[x].Name) %> = <%= GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %>;
			<% }// end for %>
			return new<%=className%>;
		}
				
		#endregion Constructors
		
		#region Events trigger
		/// <summary>
		/// Raises the <see cref="ColumnChanging" /> event.
		/// </summary>
		/// <param name="column">The <see cref="<%=className%>Column"/> which has raised the event.</param>
		public void OnColumnChanging(<%=className%>Column column)
		{
			<%=className%>EventHandler handler = ColumnChanging;
			if(handler != null)
			{
				handler(this, new <%=className%>EventArgs(column));
			}
	
		}
		
		
		/// <summary>
		/// Raises the <see cref="ColumnChanged" /> event.
		/// </summary>
		/// <param name="column">The <see cref="<%=className%>Column"/> which has raised the event.</param>
		public void OnColumnChanged(<%=className%>Column column)
		{
			<%=className%>EventHandler handler = ColumnChanged;
			if(handler != null)
			{
				handler(this, new <%=className%>EventArgs(column));
			}
			
			// warn the parent list that i have changed
			OnEntityChanged();
	
		} 
		#endregion
				
		#region Properties	
		
		<% for (int x=0; x < cols.Count; x++) { %>
		/// <summary>
		/// 	Gets or sets the <%= GetPropertyName(cols[x].Name) %> property. 
		///		<%=GetColumnXmlComment(cols[x],2)%>
		/// </summary>
		/// <value>This type is <%=cols[x].NativeType%>.</value>
		/// <remarks>
		/// This property can<%if (!cols[x].AllowDBNull) {%> not<%}%> be set to null. <%if (cols[x].AllowDBNull && !IsCSReferenceDataType(cols[x])) {%>
		/// If this column is null, this property will return <%=GetCSDefaultByType(cols[x])%>. It is up to the developer
		/// to check the value of Is<%=GetPropertyName(cols[x].Name)%>Null() and perform business logic appropriately.<%}%>
		/// </remarks>
		<%if (! cols[x].AllowDBNull && IsCSReferenceDataType(cols[x]) ) {%>
		/// <exception cref="ArgumentNullException">If you attempt to set to null.</exception>
		<%}%>
		[<%if (cols[x].IsPrimaryKeyMember && (IsIdentityColumn(cols[x]) || IsComputed(cols[x])) ) {%>ReadOnlyAttribute(false)/*, XmlIgnoreAttribute()*/, <%}%>DescriptionAttribute("<%=GetDescriptionAttributeText(cols[x].Description)%>"), BindableAttribute()]
		public virtual <%= GetCSType(cols[x])%> <%= GetPropertyName(cols[x]) %>
		{
			get
			{
				return this.entityData.<%= GetPropertyName(cols[x]) %>; 
			}
			
			set
			{
				<%if (! cols[x].AllowDBNull && IsCSReferenceDataType(cols[x]) ) {%>
				if ( value == null )
					throw new ArgumentNullException("value", "<%= GetPropertyName(cols[x].Name) %> does not allow null values.");
				<%}
				if ( cols[x].AllowDBNull && !IsCSReferenceDataType(cols[x]) ) {%>
				if (this.entityData.<%= GetPropertyName(cols[x]) %> == value && !Is<%=GetPropertyName(cols[x])%>Null() )
				<%}
				else
				{%>
				if ( this.entityData.<%= GetPropertyName(cols[x]) %> == value)
				<%} // end if (! IsCSReferenceDataType(cols[x]) ) %>
					return;
					
				OnColumnChanging(<%=className%>Column.<%=GetPropertyName(cols[x]) %>);
				this.entityData.<%= GetPropertyName(cols[x]) %> = value;
				<%if ( cols[x].AllowDBNull && !IsCSReferenceDataType(cols[x]) ) {%>
				this.entityData.Is<%=GetPropertyName(cols[x])%>Null = false;
				<%} // end IsCSReferenceDataType%>
				if (this.state == EntityState.Unchanged)
				{
					this.state = EntityState.Changed;
				}
				OnColumnChanged(<%=className%>Column.<%=GetPropertyName(cols[x]) %>);
			}
		}
		
		<%
			if (cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) )
			{%>
		/// <summary>
		/// 	Get the original value of the <%= cols[x].Name %> property.
		///		<%=GetColumnXmlComment(cols[x],2)%>
		/// </summary>
		/// <remarks>This is the original value of the <%= cols[x].Name %> property.</remarks>
		/// <value>This type is <%=cols[x].NativeType%></value>
		[BrowsableAttribute(false)/*, XmlIgnoreAttribute()*/]
		public  virtual <%= GetCSType(cols[x])%> Original<%= GetPropertyName(cols[x].Name) %>
		{
			get { return this.entityData.<%= GetOriginalPropertyName(cols[x]) %>; }
			set { this.entityData.<%= GetOriginalPropertyName(cols[x]) %> = value; }
		}
		
		<% 	} // end if updatable PK
		
		} // end for each columns 
		%>

		<% if (IncludeGetListByFK) { %>
		#region "Source Foreign Key Property"
				
		<%	//Generate a Source property for each foreign key relation		
		foreach(TableKeySchema tableKey in SourceTable.ForeignKeys)
		{	
			// related table must be in the selection
			if (SourceTables.Contains(tableKey.PrimaryKeyTable)) {
			
			string pkClassName = GetClassName(tableKey.PrimaryKeyTable.Name);
			string fkPropertyName = GetKeysName(tableKey.ForeignKeyMemberColumns);
			string memberVarName = "_" + GetCamelCaseName(fkPropertyName) + "Source";
		%>
		private <%=pkClassName%> <%=memberVarName%> = null;
		
		/// <summary>
		/// Gets or sets the source <see cref="<%=pkClassName%>"/>.
		/// </summary>
		/// <value>The source <%=pkClassName%> for <%=fkPropertyName%>.</value>
		public <%=pkClassName%> <%=fkPropertyName%>Source
		
      	{
            get { return this.<%=memberVarName%>; }
            set { this.<%=memberVarName%> = value; }
      	}
		<%	} //end if in SourceTables
		 } //end for each FK%>
		#endregion
		<%}// IncludeGetListByFK%>	

		//private bool _isDeleted = false;
		/// <summary>
		/// 	True if object has been <see cref="MarkToDelete"/>. ReadOnly.
		/// </summary>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public virtual bool IsDeleted
		{
			get { return this.state == EntityState.Deleted; }
		}		
		
		//private bool _isDirty = false;
		/// <summary>
		///		Indicates if the object has been modified from its original state.
		/// </summary>
		/// <remarks>True if object has been modified from its original state; otherwise False;</remarks>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public virtual bool IsDirty
		{
			get { return this.state != EntityState.Unchanged; }
		}
		
		
		//private bool _isNew = true;
		/// <summary>
		///		Indicates if the object is new.
		/// </summary>
		/// <remarks>True if objectis new; otherwise False;</remarks>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public virtual bool IsNew
		{
			get { return this.state == EntityState.Added; }
			set { this.state = EntityState.Added; }
		}
		

		protected EntityState state = EntityState.Added ;
		/// <summary>
		///		Indicates state of object
		/// </summary>
		/// <remarks>0=Unchanged, 1=Added, 2=Changed, 3-Deleted</remarks>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public virtual EntityState EntityState
		{
			get { return this.state; }
			set { this.state = value; }
		}

		/// <summary>
		///		The name of the underlying database table.
		/// </summary>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public string TableName
		{
			get { return "<%=SourceTable.Name%>"; }
		}
		
		/// <summary>
		///		The name of the underlying database table's columns.
		/// </summary>
		[BrowsableAttribute(false), XmlIgnoreAttribute()]
		public string[] TableColumns
		{
			get
			{
				return new string[] {<%for (int i=0; i< SourceTable.Columns.Count; i++) { %>
					<% if (i>0) Response.Write(", "); Response.Write("\""+ SourceTable.Columns[i].Name + "\""); } %>};
			}
		}
<% 
if(IncludeRelations) {
WriteRelationshipPropertyString();
}
%>
		
		#endregion
		
		#region IEditableObject
		
	    void IEditableObject.BeginEdit() 
	    {
	        //Console.WriteLine("Start BeginEdit");
	        if (!inTxn) 
	        {
	            this.backupData = this.entityData.Clone() as <%=structName%>;
	            inTxn = true;
	            //Console.WriteLine("BeginEdit");
	        }
	        //Console.WriteLine("End BeginEdit");
	    }
	
	    void IEditableObject.CancelEdit() 
	    {
	        //Console.WriteLine("Start CancelEdit");
	        if (this.inTxn) 
	        {
	            this.entityData = this.backupData;
	            this.backupData = null;
				this.inTxn = false;

				//if (this._isNew)
				if (this.state == EntityState.Added)
				{
					if (ParentCollection != null)
						(ParentCollection as <%=collectionClassName%>).Remove( (<%=className%>) this ) ;
				}	            
	        }
	        //Console.WriteLine("End CancelEdit");
	    }
	
	    void IEditableObject.EndEdit() 
	    {
	        //Console.WriteLine("Start EndEdit" + this.custData.id + this.custData.lastName);
	        if (this.inTxn) 
	        {
	            this.backupData = null;
				/*if (this._isDirty) 
				{
					if (this._isNew) {
						this.state = EntityState.Added ;
						this._isNew = false ;
					}
					else
						this.state = EntityState.Changed ;
				}

				this._isNew = false ;
				*/
	            this.inTxn = false;	            
	        }
	        //Console.WriteLine("End EndEdit");
	    }
	    
	     /// <summary>
        /// Gets or sets the parent collection.
        /// </summary>
        /// <value>The parent collection.</value>
	    [XmlIgnore]
		[Browsable(false)]
	    public object ParentCollection
	    {
	        get 
	        {
	            return this.parentCollection;
	        }
	        set 
	        {
	            this.parentCollection = (<%=collectionClassName%>)value;
	        }
	    }
	    
	    private void OnEntityChanged() 
	    {
	        if (!inTxn && ParentCollection != null) 
	        {
	            (ParentCollection as <%=collectionClassName%>).EntityChanged(this);
	        }
	    }


		#endregion
		
		#region Methods	
		
		/// <summary>
		/// Accepts the changes made to this object.
		/// </summary>
		/// <remarks>
		/// After calling this method <see cref="IsDirty"/> and <see cref="IsNew"/> are false. <see cref="IsDeleted"/> flag remain unchanged as it is handled by the parent List.
		/// </remarks>
		public virtual void AcceptChanges()
		{
			//this._isDeleted = false;
			//this._isDirty = false;
			//this._isNew = false;
			this.state = EntityState.Unchanged;			
		}
		
		
		///<summary>
		///  TODO: Revert all changes and restore original values.
		///  Currently not supported.
		///</summary>
		/// <exception cref="NotSupportedException">This method is not currently supported and always throws this exception.</exception>
		public virtual void CancelChanges()
		{
			throw new NotSupportedException("Method currently not Supported.");
		}
		
		
		///<summary>
		///   Marks entity to be deleted.
		///</summary>
		public virtual void MarkToDelete()
		{
			if (this.state != EntityState.Added)
				this.state = EntityState.Deleted ;
		}
		
		///<summary>
		///   Remove the "isDeleted" mark from the entity.
		///</summary>
		public virtual void RemoveDeleteMark()
		{
			//this._isDeleted = false;
			if (this.state != EntityState.Added) 
			{				
				this.state = EntityState.Changed ;
			}
		}
		
		#region ICloneable Members
		///<summary>
		///  Returns a Typed <%=abstractClassName%> Entity 
		///</summary>
		public virtual <%=abstractClassName%> Copy()
		{
			//shallow copy entity
			<%=className%> copy = new <%=className%>();
			<% for (int x=0; x < cols.Count; x++) { %>
			<% if ( cols[x].AllowDBNull && !IsCSReferenceDataType(cols[x]) ) { %>
			if ( this.Is<%=GetPropertyName(cols[x].Name)%>Null() )
				copy.Set<%=GetPropertyName(cols[x].Name)%>Null();
			else
			copy.<%= GetPropertyName(cols[x].Name) %> = this.<%= GetPropertyName(cols[x].Name) %>;
			<% } %>
			<% else { %>
			copy.<%= GetPropertyName(cols[x].Name) %> = this.<%= GetPropertyName(cols[x].Name) %>;
			<% } %>
			<% if( cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) ) {%>
			copy.<%= GetOriginalPropertyName(cols[x].Name) %> = this.<%= GetOriginalPropertyName(cols[x].Name) %>;
			<% } %>
			<% } %>
					
		<% 
		/* commented till GetChildrenCollections will work 
		if (IncludeRelations){
		int ctr = 0;
		foreach(CollectionInfo item in GetChildrenCollections(SourceTable)) { 
			if (ctr == 0)
				Response.Write("\t\t\t//deep copy nested objects" + Environment.NewLine);
			ctr++;
		%>
			copy.<%=GetCollectionClassName(item.CleanName)%> = (<%=GetCollectionClassName(item.CleanName)%>)MakeCopyOf(this.<%=GetCollectionClassName(item.CleanName)%>); 
			<% }//end foreach CollectionInfo
		}//end if IncludeRelations
		//ChildCollections.Clear();
		*/
		%>
			copy.AcceptChanges();
			return (<%=className%>)copy;
		}
		
		///<summary>
		/// ICloneable.Clone() Member, returns the Deep Copy of this entity.
		///</summary>
		public object Clone(){
			return this.Copy();
		}
		
		///<summary>
		/// Returns a deep copy of the child collection object passed in.
		///</summary>
		public static object MakeCopyOf(object x)
		{
			if (x is ICloneable)
			{
				// Return a deep copy of the object
				return ((ICloneable)x).Clone();
			}
			else
				throw new System.NotSupportedException("Object Does Not Implement the ICloneable Interface.");
		}
		#endregion
		
		
		///<summary>
		/// Returns a value indicating whether this instance is equal to a specified object.
		///</summary>
		///<param name="toObject">An object to compare to this instance.</param>
		///<returns>true if toObject is a <see cref="<%=abstractClassName%>"/> and has the same value as this instance; otherwise, false.</returns>
		public virtual bool Equals(<%=abstractClassName%> toObject)
		{
			if (toObject == null)
				return false;
			return Equals(this, toObject);
		}
		
		
		///<summary>
		/// Determines whether the specified <see cref="<%=abstractClassName%>"/> instances are considered equal.
		///</summary>
		///<param name="Object1">The first <see cref="<%=abstractClassName%>"/> to compare.</param>
		///<param name="Object2">The second <see cref="<%=abstractClassName%>"/> to compare. </param>
		///<returns>true if Object1 is the same instance as Object2 or if both are null references or if objA.Equals(objB) returns true; otherwise, false.</returns>
		public static bool Equals(<%=abstractClassName%> Object1, <%=abstractClassName%> Object2)
		{
			// both are null
			if (Object1 == null && Object2 == null)
				return true;

			// one or the other is null, but not both
			if (Object1 == null ^ Object2 == null)
				return false;
				
			bool equal = true;
		<% for (int x=0; x < cols.Count; x++) {
			    if ( cols[x].AllowDBNull )
				{ %>
			if (! Object1.Is<%=GetPropertyName(cols[x].Name)%>Null() && !Object2.Is<%=GetPropertyName(cols[x].Name)%>Null() )
			{
				if (Object1.<%= GetPropertyName(cols[x].Name) %> != Object2.<%= GetPropertyName(cols[x].Name) %>)
					equal = false;
			}
			else if (Object1.Is<%=GetPropertyName(cols[x].Name)%>Null() != Object1.Is<%=GetPropertyName(cols[x].Name)%>Null() )
			{
				equal = false;
			}
		      <%}
				else { %>
			if (Object1.<%= GetPropertyName(cols[x].Name) %> != Object2.<%= GetPropertyName(cols[x].Name) %>)
				equal = false;
			<% } // if ( cols[x].AllowDBNull ) %>
		<% }// end for %>	
			return equal;
		}
		
		#endregion
		
		#region IComparable Members
		///<summary>
		/// Compares this instance to a specified object and returns an indication of their relative values.
		///<param name="obj">An object to compare to this instance, or a null reference (Nothing in Visual Basic).</param>
		///</summary>
		///<returns>A signed integer that indicates the relative order of this instance and obj.</returns>
		public virtual int CompareTo(object obj)
		{
			throw new NotImplementedException();
			// TODO -> generate a strongly typed IComparer in the concrete class
			//return this. GetPropertyName(SourceTable.PrimaryKey.MemberColumns[0].Name) .CompareTo(((<%=abstractClassName%>)obj).GetPropertyName(SourceTable.PrimaryKey.MemberColumns[0].Name));
		}
	
		#endregion
		
		#region IsColumnNull
		<% for (int x=0; x < cols.Count; x++) { 
			// only write method if it allows nulls
			if (cols[x].AllowDBNull) {%>
		///<summary>
		/// Indicates if the <%=cols[x].Name%> value is null.
		///</summary>		
		///<returns>true if <%=cols[x].Name%> has a null value; otherwise, false.</returns>
		public virtual bool Is<%=GetPropertyName(cols[x])%>Null()
		{
			<% if ( IsCSReferenceDataType(cols[x]) ) {%>
				return (<%=GetPropertyName(cols[x])%> == null);
			<%}
			else 
			{%>
				return this.entityData.Is<%=GetPropertyName(cols[x])%>Null;
			<%}%>
		}
		<% if ( !IsCSReferenceDataType(cols[x]) ) {%>
		
		///<summary>
		/// Sets the column <%=cols[x].Name%> value to null.
		///</summary>		
		public virtual void Set<%=GetPropertyName(cols[x])%>Null()
		{
			this.entityData.Is<%=GetPropertyName(cols[x])%>Null = true;			
			this.entityData.<%= GetPropertyName(cols[x]) %> = <%= GetCSDefaultByType(cols[x]) %>; // set to default for data type
			if (this.state == EntityState.Unchanged)
			{
				this.state = EntityState.Changed;
			}
		}
		<% } // end !IsCSReferenceDataType(cols[x])
		  } //end Nullable
		 }// end for 
		%>	
		#endregion IsColumnNull
		
		///<summary>
		/// Returns a String that represents the current object.
		///</summary>
		public override string ToString()
		{
			return string.Format(System.Globalization.CultureInfo.InvariantCulture,
				"{<%=cols.Count+1%>}{<%=cols.Count%>}"<% for (int x=0; x < cols.Count; x++) { %>
				<%Response.Write("+ \"- " + GetPropertyName(cols[x].Name) + ": {" + x + "}{" + cols.Count + "}\"" ); } %>, 
			<%for (int x=0; x < cols.Count; x++)
			  {
			    if ( cols[x].AllowDBNull )
				{
				  if ( IsCSReferenceDataType(cols[x]) ) { %>
				(this.<%=GetPropertyName(cols[x].Name)%> == null) ? string.Empty : this.<%=GetPropertyName(cols[x].Name)%>.ToString(),
			      <%} else { %>
				(this.Is<%=GetPropertyName(cols[x].Name)%>Null()) ? string.Empty : this.<%=GetPropertyName(cols[x].Name)%>.ToString(),
			      <%}
				}
				else { %>
				this.<%= GetPropertyName(cols[x].Name) %>,
			<% } // if ( cols[x].AllowDBNull )
			} // for (int x=0; x < cols.Count; x++) %>
				Environment.NewLine, 
				this.GetType());
		}
	
	}//End Class
	
	
	/// <summary>
	/// Enumerate the <%=className%> columns.
	/// </summary>
	[Serializable]
	public enum <%=className%>Column
	{
		<% for (int x=0; x < cols.Count; x++) { %>
		/// <summary>
		/// <%=GetPropertyName(cols[x].Name)%> : <%=GetColumnXmlComment(cols[x],2)%>
		/// </summary>
		<%=GetPropertyName(cols[x].Name)%><%if(x < cols.Count -1) {%>,<%}%>
		<% }// end for %>	
	}//End enum

} // end namespace

<script runat="template">
///<summary>
/// Many To Many Relationship Class Template Property String
///</summary>
protected static string MANY_TO_MANY = @"
		private {1} _{0} = new {1}();
		
		/// <summary>
		///	Holds a collection of {1} objects
		///	which are related to this object through the junction table {2}
		/// </summary>	
		public {1} {0}
		{{
			get {{ return _{0}; }}
			set {{ _{0} = value; }}	
		}}
";

///<summary>
/// One to One Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_ONE = @"
		private {0} _{0} = new {0}();
			
		/// <summary>
		///	Holds a {0} object
		///	which is related to this object through the relation {1}
		/// </summary>
		public {0} {0}
		{{
			get {{ return _{0}; }}
			set {{ _{0} = value; }}	
		}}
";
		
///<summary>
/// One To Many Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_MANY = @"
		private {0} _{0} = new {0}();
		
		/// <summary>
		///	Holds a collection of {2} objects
		///	which are related to this object through the relation {1}
		/// </summary>	
		public {0} {0}
		{{
			get {{ return _{0}; }}
			set {{ _{0} = value; }}	
		}}
";
		
///<summary>
///   Writes out the property string of all the relationship object collections.
///</summary>
private void WriteRelationshipPropertyString() {
		
		///Loop Child Collections
		foreach (CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables))
		{
			
			///Assign by RelationshipType, Then Write to Response
			switch((int)item.CollectionRelationshipType)
			{
				///One To One Relationship
				case (int)RelationshipType.OneToOne:
					object[] oneToOneParams = {
								GetClassName(item.SecondaryTable), 
								GetClassName(item.PkIdxName)
					};
					item.PropertyString = string.Format(ONE_TO_ONE, oneToOneParams);
					break;
					
				///One To Many, Many To One
				case (int)RelationshipType.OneToMany:
				case (int)RelationshipType.ManyToOne:
				    object[] oneToManyParams = {
							GetCollectionClassName(item.SecondaryTable)
							, item.PkIdxName
							, GetClassName(item.SecondaryTable)
					};
				item.PropertyString = string.Format(ONE_TO_MANY, oneToManyParams);
				break;
				
				///Many To Many
				case (int)RelationshipType.ManyToMany:
					object[] manyToManyParams = {
							//GetCollectionClassName(item.CleanName) + "_From_" + GetClassName(item.JunctionTable), 
							item.CollectionName,
							GetCollectionClassName(item.SecondaryTable),
							item.JunctionTable
					};
					item.PropertyString = string.Format(MANY_TO_MANY, manyToManyParams);
					break;
				default:
					break;
			}
			
			if (!RenderedChildren.Contains(item.CleanName))
			{
				///Write it out to the resonse stream
				Response.Write(item.PropertyString);	
				RenderedChildren.Add(item.CleanName);
			}
		}///End foreach loop
		
		///enable use for the next template
		RenderedChildren.Clear();
		}
</script>

