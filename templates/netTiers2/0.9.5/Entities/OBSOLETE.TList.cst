<%--
 * $Id: TList.cst,v 1.13 2006/01/20 19:47:10 bgjohnso Exp $
 * Last modified by $Author: jroland $
 * Last modified at $Date: 2006-03-16 16:53:08 -0600 (Thu, 16 Mar 2006) $
 * $Revision: 62 $
--%>
<%@ CodeTemplate Language="C#" TargetLanguage="C#" Description="Generate a generic Colelction for our framework." %>

<%@ Property Name="NameSpace" Type="System.String" Category="Data" Description="Object Namespace." %>	

using System;
using System.Text;

using System.ComponentModel;
using System.Collections;
using System.Collections.Generic;

using System.Runtime.Serialization;
using System.Xml.Serialization;


namespace <%=NameSpace%>
{
<<<<<<< TList.cst
	/// <summary>
	/// http://www.ondotnet.com/pub/a/dotnet/excerpt/progcsharp4_ch09-04/index.html?page=1
	/// </summary>
	[Serializable]
    public class TList<T> : BindingList<T>, IBindingListView, IBindingList, IList, ICloneable, IListSource, ITypedList, IDisposable, IComponent, IRaiseItemChangedEvents, IDeserializationCallback where T : IEntity, new()
    {

        List<T> _OriginalList = new List<T>();

        // Sorting
        bool _isSorted = false;
        [NonSerialized] PropertyDescriptor _sortProperty;
        [NonSerialized] ListSortDirection _sortDirection = ListSortDirection.Descending;
        ListSortDescriptionCollection _sortDescriptions = new ListSortDescriptionCollection();

        //Filtering
        string _filterString = null;
        List<T> excludedItems = new List<T>();

        readonly string _listName;
        bool _containsListCollection = false;
        
        [NonSerialized] readonly PropertyDescriptorCollection _propertyCollection;

        /// <summary>
        /// Initializes a new instance of the <see cref="T:TList&lt;T&gt;"/> class.
        /// </summary>
        public TList()
        {
            InitializeList();
        }

        /// <summary>
        /// Initialize any member variables when the list is created
        /// </summary>
        private void InitializeList()
        {
            // create a filter so we only return the properties that have been designated as bindable
            Attribute[] attrs = new Attribute[] { new BindableAttribute() };
            // get the type information for the next two steps
            Type t = typeof(T);
            // save the bindable properties in a local field
            _propertyCollection = TypeDescriptor.GetProperties(t, attrs);
            // save the name of the type for use in the IDE GUI
            _listName = t.Name;
        }

        #region Core Overrides

        protected override bool SupportsSearchingCore
        {
            get
            {
                return true;
            }
        }
        
        protected override int FindCore(PropertyDescriptor prop, object key)
        {
        	return FindCore(prop, key, 0);
        }

        protected virtual int FindCore(PropertyDescriptor prop, object key, int start)
        {
            // Simple iteration:
            for (int i = start; i < Count; i++)
            {
                T item = this[i];
                if (prop.GetValue(item).Equals(key))
                {
                    return i;
                }
            }
            return -1; // Not found
        }

        protected override bool SupportsSortingCore
        {
            get
            {
                return true;
            }
        }

        protected override bool IsSortedCore
        {
            get
            {
                return _isSorted;
            }
        }

        protected override ListSortDirection SortDirectionCore
        {
            get
            {
                return _sortDirection;
            }
        }

        protected override PropertyDescriptor SortPropertyCore
        {
            get
            {
                return _sortProperty;
            }
        }

        protected override void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
        {
            _sortDirection = direction;
            _sortProperty = prop;
            SortComparer<T> comparer = new SortComparer<T>(prop, direction);
            ApplySortInternal(comparer);
        }

        protected override void RemoveSortCore()
        {
            if (!_isSorted)
                return;

            Clear();
            foreach (T item in _OriginalList)
            {
                Add(item);
            }

            _OriginalList.Clear();
            _sortProperty = null;
            _sortDescriptions = null;
            _isSorted = false;
        }



        #endregion

        #region IBindingListView Members

        ///<summary>
        /// Sorts the data source based on the given <see cref="ListSortDescriptionCollection"/>.
        ///</summary>
        ///<param name="sorts">The <see cref="ListSortDescriptionCollection"/> containing the sorts to apply to the data source.</param>
        public void ApplySort(ListSortDescriptionCollection sorts)
        {
            _sortProperty = null;
            _sortDescriptions = sorts;
            SortComparer<T> comparer = new SortComparer<T>(sorts);
            ApplySortInternal(comparer);
        }

        ///<summary>
        /// Sorts the data source based on a <see cref="PropertyDescriptor">PropertyDescriptor</see> and a <see cref="ListSortDirection">ListSortDirection</see>.
        ///</summary>
        ///<param name="property">The <see cref="PropertyDescriptor"/> to sort the collection by.</param>
        ///<param name="direction">The <see cref="ListSortDirection"/> in which to sort the collection.</param>
        public void ApplySort(PropertyDescriptor property, ListSortDirection direction)
        {
            ApplySortCore(property, direction);
        }


        /// <summary>
        /// Gets or sets the filter to be used to exclude items from the collection of items returned by the data source.
        /// </summary>
        public string Filter
        {
            get
            {
                return _filterString;
            }
            set
            {
                if (value == this._filterString) return;

                this._filterString = value;
                this.ApplyFilter();
            }
        }

        /// <summary>
        /// Removes the current filter applied to the data source..
        /// </summary>
        public void RemoveFilter()
        {
            this.Filter = string.Empty;
        }

        /// <summary>
        /// Gets the collection of sort descriptions currently applied to the data source.
        /// </summary>
        public ListSortDescriptionCollection SortDescriptions
        {
            get
            {
                return _sortDescriptions;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the data source supports advanced sorting.
        /// </summary>
        public bool SupportsAdvancedSorting
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the data source supports filtering.
        /// </summary>
        public bool SupportsFiltering
        {
            get
            {
                return true;
            }
        }

        #region Sorting

        private void ApplySortInternal(SortComparer<T> comparer)
        {
            if (_OriginalList.Count == 0)
            {
                _OriginalList.AddRange(this);
            }

            List<T> listRef = this.Items as List<T>;

            if (listRef == null)
                return;

            listRef.Sort(comparer);
            _isSorted = true;
            OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
        }

        #endregion

        #region Filtering


        /// <summary>
        /// Indicates whether a filter is currently applied to the collection.
        /// </summary>
        public bool IsFiltering
        {
            get { return this.excludedItems.Count > 0; }
        }

        /// <summary>
        /// Get the list of items that are excluded by the current filter.
        /// </summary>
        public List<T> ExcludedItems
        {
            get { return this.excludedItems; }
        }

        /// <summary>
        /// Force the filtering of the collection, based on the filter expression set through the <c cref="Filter"/> property.
        /// </summary>
        public void ApplyFilter()
        {
            // Restore the state without filter
            for (int i = 0; i < this.excludedItems.Count; i++)
            {
                this.Add(this.excludedItems[i]);
            }

            // Clear the filterd items
            this.excludedItems.Clear();

            // Application du filtre si non vide
            if (this._filterString != null & this._filterString.Length > 0)
            {
                Filter MyFilter = new Filter(this, this.excludedItems, typeof(T), this._filterString);
            }

            // Send a IBindingList list event
            OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, 0, 0));
        }

        #endregion

        #endregion

        #region BindingList overrides

        protected override void InsertItem(int index, T item)
        {
            //Set the parentCollection property
            item.ParentCollection = this;
            foreach (PropertyDescriptor propDesc in TypeDescriptor.GetProperties(item))
            {
                if (propDesc.SupportsChangeEvents)
                {
                    propDesc.AddValueChanged(item, OnItemChanged);
                }
            }
            base.InsertItem(index, item);
        }

        protected override void RemoveItem(int index)
        {
            T item = Items[index];
            foreach (PropertyDescriptor propDesc in TypeDescriptor.GetProperties(item))
            {
                if (propDesc.SupportsChangeEvents)
                {
                    propDesc.RemoveValueChanged(item, OnItemChanged);
                }
            }
            //Move item to deleted collection(if not in added state)
            if (item.EntityState != EntityState.Added)
            {
                DeletedItems.Add(item);
            }
            base.RemoveItem(index);
        }

        void OnItemChanged(object sender, EventArgs args)
        {
            int index = Items.IndexOf((T)sender);
            OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
        }

        #endregion

        #region IRaiseItemChangedEvents Members

        bool IRaiseItemChangedEvents.RaisesItemChangedEvents
        {
            get { return true; }
        }

        #endregion

        #region Shuffle

        /// <summary>
        ///		Sorts the collection based on a random shuffle.
        /// </summary>
        /// <author>Steven Smith</author>
        /// <url>http://blogs.aspadvice.com/ssmith/archive/2005/01/27/2480.aspx</url>
        ///<remarks></remarks>
        public virtual void Shuffle()
        {
            if (this._OriginalList.Count == 0)
=======
  /// <summary>
   /// http://www.ondotnet.com/pub/a/dotnet/excerpt/progcsharp4_ch09-04/index.html?page=1
   /// </summary>
   [Serializable]
   public class TList<T> : BindingList<T>, IBindingListView, IBindingList, IList, ICloneable, IListSource, ITypedList, IDisposable, IComponent, IRaiseItemChangedEvents, IDeserializationCallback where T : IEntity, new()
   {

      private List<T> _OriginalList = new List<T>();

      // Sorting
      private bool _isSorted = false;
      [NonSerialized]
      private PropertyDescriptor _sortProperty;
      private ListSortDirection _sortDirection = ListSortDirection.Descending;
      [NonSerialized]
      ListSortDescriptionCollection _sortDescriptions = new ListSortDescriptionCollection();

      //Filtering
      private string _filterString = null;
      private List<T> excludedItems = new List<T>();

      private string _listName;
      private bool _containsListCollection = false;
      [NonSerialized]
      private PropertyDescriptorCollection _propertyCollection;

      /// <summary>
      /// Initializes a new instance of the <see cref="T:TList{T}"/> class.
      /// </summary>
      public TList()
      {
         InitializeList();
      }

      /// <summary>
      /// Initialize any member variables when the list is created
      /// </summary>
      private void InitializeList()
      {
         // create a filter so we only return the properties that have been designated as bindable
         Attribute[] attrs = new Attribute[] { new BindableAttribute() };
         // get the type information for the next two steps
         Type t = typeof(T);
         // save the bindable properties in a local field
         _propertyCollection = TypeDescriptor.GetProperties(t, attrs);
         // save the name of the type for use in the IDE GUI
         _listName = t.Name;
      }

      #region Core Overrides

      /// <summary>
      /// Gets a value indicating whether the list supports searching. 
      /// </summary>
      protected override bool SupportsSearchingCore
      {
         get
         {
            return true;
         }
      }

      /// <summary>
      /// Searches for the index of the item that has the specified property descriptor with the specified value.
      /// </summary>
      /// <param name="prop">The <see cref="PropertyDescriptor"/> to search for.</param>
      /// <param name="key">The value of <i>property</i> to match.</param>
      /// <returns>The zero-based index of the item that matches the property descriptor and contains the specified value. </returns>
      protected override int FindCore(PropertyDescriptor prop, object key)
      {
         return FindCore(prop, key, 0);
      }

      /// <summary>
      /// Searches for the index of the item that has the specified property descriptor with the specified value.
      /// </summary>
      /// <param name="prop">The <see cref="PropertyDescriptor"> to search for.</see></param>
      /// <param name="key">The value of <i>property</i> to match.</param>
      /// <param name="start">The index in the list at which to start the search.</param>
      /// <returns>The zero-based index of the item that matches the property descriptor and contains the specified value. </returns>
      protected virtual int FindCore(PropertyDescriptor prop, object key, int start)
      {
         // Simple iteration:
         for (int i = start; i < Count; i++)
         {
            T item = this[i];
            if (prop.GetValue(item).Equals(key))
            {
               return i;
            }
         }
         return -1; // Not found
      }

      /// <summary>
      /// Gets a value indicating whether the list supports sorting. 
      /// </summary>
      protected override bool SupportsSortingCore
      {
         get
         {
            return true;
         }
      }

      /// <summary>
      /// Gets a value indicating whether the list is sorted. 
      /// </summary>
      protected override bool IsSortedCore
      {
         get
         {
            return _isSorted;
         }
      }

      /// <summary>
      /// Gets the direction the list is sorted.
      /// </summary>
      protected override ListSortDirection SortDirectionCore
      {
         get
         {
            return _sortDirection;
         }
      }

      /// <summary>
      /// Gets the property descriptor that is used for sorting
      /// </summary>
      /// <returns>The <see cref="PropertyDescriptor"/> used for sorting the list.</returns>
      protected override PropertyDescriptor SortPropertyCore
      {
         get
         {
            return _sortProperty;
         }
      }

      /// <summary>
      /// Sorts the items in the list
      /// </summary>
      /// <param name="prop">A <see cref="PropertyDescriptor"/> that specifies the property to sort on.</param>
      /// <param name="direction">One of the <see cref="ListSortDirection"/> values.</param>
      protected override void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
      {
         _sortDirection = direction;
         _sortProperty = prop;
         SortComparer<T> comparer = new SortComparer<T>(prop, direction);
         ApplySortInternal(comparer);
      }

      /// <summary>
      /// Removes any sort applied to the list.
      /// </summary>
      protected override void RemoveSortCore()
      {
         if (!_isSorted)
            return;

         Clear();
         foreach (T item in _OriginalList)
         {
            Add(item);
         }

         _OriginalList.Clear();
         _sortProperty = null;
         _sortDescriptions = null;
         _isSorted = false;
      }



      #endregion

      #region IBindingListView Members

      /// <summary>
      /// Gets or sets the filter to be used to exclude items from the collection of items returned by the data source.
      /// </summary>
      public string Filter
      {
         get
         {
            return _filterString;
         }
         set
         {
            if (value == this._filterString) return;

            this._filterString = value;
            this.ApplyFilter();
         }
      }

      /// <summary>
      /// Removes the current filter applied to the data source..
      /// </summary>
      public void RemoveFilter()
      {
         this.Filter = string.Empty;
      }

      /// <summary>
      /// Gets the collection of sort descriptions currently applied to the data source.
      /// </summary>
      public ListSortDescriptionCollection SortDescriptions
      {
         get
         {
            return _sortDescriptions;
         }
      }

      /// <summary>
      /// Gets a value indicating whether the data source supports advanced sorting.
      /// </summary>
      public bool SupportsAdvancedSorting
      {
         get
         {
            return true;
         }
      }

      /// <summary>
      /// Gets a value indicating whether the data source supports filtering.
      /// </summary>
      public bool SupportsFiltering
      {
         get
         {
            return true;
         }
      }

      #region Sorting

      ///<summary>
      /// Sorts the data source based on the given <see cref="ListSortDescriptionCollection"/>.
      ///</summary>
      ///<param name="sorts">The <see cref="ListSortDescriptionCollection"/> containing the sorts to apply to the data source.</param>
      public void ApplySort(ListSortDescriptionCollection sorts)
      {
         _sortProperty = null;
         _sortDescriptions = sorts;
         SortComparer<T> comparer = new SortComparer<T>(sorts);
         ApplySortInternal(comparer);
      }

      ///<summary>
      /// Sorts the data source based on a <see cref="PropertyDescriptor">PropertyDescriptor</see> and a <see cref="ListSortDirection">ListSortDirection</see>.
      ///</summary>
      ///<param name="property">The <see cref="PropertyDescriptor"/> to sort the collection by.</param>
      ///<param name="direction">The <see cref="ListSortDirection"/> in which to sort the collection.</param>
      public void ApplySort(PropertyDescriptor property, ListSortDirection direction)
      {
         ApplySortCore(property, direction);
      }

      /// <summary>
      /// Sorts the elements in the entire list using the specified <see cref="System.Comparison{T}"/>.
      /// </summary>
      /// <param name="comparison">The <see cref="System.Comparison{T}"/> to use when comparing elements.</param>
      /// <exception cref="ArgumentNullException">comparison is a null reference.</exception>
      private void ApplySortInternal(Comparison<T> comparison)
      {
         if (comparison == null)
            throw new ArgumentNullException("The comparison parameter must be a valid object instance.");

         if (_OriginalList.Count == 0)
         {
            _OriginalList.AddRange(this);
         }

         List<T> listRef = this.Items as List<T>;

         if (listRef == null)
            return;

         listRef.Sort(comparison);
         _isSorted = true;
         OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
      }

      /// <summary>
      /// Sorts the elements in the entire list using the specified comparer. 
      /// </summary>
      /// <param name="comparer">The <see cref="IComparer{T}" /> implementation to use when comparing elements, or a null reference (Nothing in Visual Basic) to use the default comparer <see cref="Comparer.Default"/>.</param>
      private void ApplySortInternal(IComparer<T> comparer)
      {
         if (comparer == null)
            comparer = Comparer<T>.Default;

         ApplySortInternal(comparer.Compare);
      }

      /// <summary>
      /// Sorts the elements in the entire list using the specified comparer. 
      /// </summary>
      /// <param name="comparer">The <see cref="IComparer{T}" /> implementation to use when comparing elements, or a null reference (Nothing in Visual Basic) to use the default comparer <see cref="Comparer.Default"/>.</param>
      public void Sort(IComparer<T> comparer)
      {
         ApplySortInternal(comparer);
      }

      /// <summary>
      /// Sorts the elements in the entire list using the specified <see cref="System.Comparison{T}"/>.
      /// </summary>
      /// <param name="comparison">The <see cref="System.Comparison{T}"/> to use when comparing elements.</param>
      /// <exception cref="ArgumentNullException">comparison is a null reference.</exception>
      public void Sort(Comparison<T> comparison)
      {
         ApplySortInternal(comparison);
      }

      /// <summary>
      /// Sorts the elements in the entire list using the specified Order By statement.
      /// </summary>
      /// <param name="orderBy">SQL-like string representing the properties to sort the list by.</param>
      /// <remarks><i>orderBy</i> should be in the following format: 
      /// <para>PropertyName[[ [[ASC]|DESC]][, PropertyName[ [[ASC]|DESC]][,...]]]</para></remarks>
      /// <example><c>list.Sort("Property1, Property2 DESC, Property3 ASC");</c></example>
      public void Sort(string orderBy)
      {
         SortComparer<T> sortComparer = new SortComparer<T>(orderBy);
         ApplySortInternal(sortComparer.Compare);
      }

      #endregion

      #region Filtering


      /// <summary>
      /// Indicates whether a filter is currently applied to the collection.
      /// </summary>
      public bool IsFiltering
      {
         get { return this.excludedItems.Count > 0; }
      }

      /// <summary>
      /// Get the list of items that are excluded by the current filter.
      /// </summary>
      public List<T> ExcludedItems
      {
         get { return this.excludedItems; }
      }

      /// <summary>
      /// Force the filtering of the collection, based on the filter expression set through the <c cref="Filter"/> property.
      /// </summary>
      public void ApplyFilter()
      {
         // Restore the state without filter
         for (int i = 0; i < this.excludedItems.Count; i++)
         {
            this.Add(this.excludedItems[i]);
         }

         // Clear the filterd items
         this.excludedItems.Clear();

         // Application du filtre si non vide
         if (this._filterString != null & this._filterString.Length > 0)
         {
            Filter MyFilter = new Filter(this, this.excludedItems, typeof(T), this._filterString);
         }

         // Send a IBindingList list event
         OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, 0, 0));
      }

      #endregion

      #endregion

      #region BindingList overrides

      /// <summary>
      /// Inserts the specified item in the list at the specified index.
      /// </summary>
      /// <param name="index">The zero-based index where the item is to be inserted.</param>
      /// <param name="item">The item to insert in the list.</param>
      protected override void InsertItem(int index, T item)
      {
         //Set the parentCollection property
         item.ParentCollection = this;
         foreach (PropertyDescriptor propDesc in TypeDescriptor.GetProperties(item))
         {
            if (propDesc.SupportsChangeEvents)
            {
               propDesc.AddValueChanged(item, OnItemChanged);
            }
         }
         base.InsertItem(index, item);
      }

      /// <summary>
      /// Removes the item at the specified index.
      /// </summary>
      /// <param name="index">The zero-based index of the item to remove.</param>
      protected override void RemoveItem(int index)
      {
         T item = Items[index];
         foreach (PropertyDescriptor propDesc in TypeDescriptor.GetProperties(item))
         {
            if (propDesc.SupportsChangeEvents)
            {
               propDesc.RemoveValueChanged(item, OnItemChanged);
            }
         }
         //Move item to deleted collection(if not in added state)
         if (item.EntityState != EntityState.Added)
         {
            DeletedItems.Add(item);
         }
         base.RemoveItem(index);
      }

      /// <summary>
      /// Represents the method that will handle the ItemChanged event of the CurrencyManager class
      /// </summary>
      /// <param name="sender">The source of the event.</param>
      /// <param name="args">An EventArgs that contains the event data.</param>
      /// <remarks>This raises the ListChanged event of the list.</remarks>
      void OnItemChanged(object sender, EventArgs args)
      {
         int index = Items.IndexOf((T)sender);
         OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
      }

      #endregion

      #region IRaiseItemChangedEvents Members

      /// <summary>
      /// Gets a value indicating whether the object raises <see cref="IBindingList.ListChanged"/> events.
      /// </summary>
      bool IRaiseItemChangedEvents.RaisesItemChangedEvents
      {
         get { return true; }
      }

      #endregion

      #region Shuffle

      /// <summary>
      ///		Sorts the collection based on a random shuffle.
      /// </summary>
      /// <author>Steven Smith</author>
      /// <url>http://blogs.aspadvice.com/ssmith/archive/2005/01/27/2480.aspx</url>
      ///<remarks></remarks>
      public virtual void Shuffle()
      {
         if (this._OriginalList.Count == 0)
         {
            this._OriginalList.AddRange(this);
         }

         //List<T> source = new List<T>(this);
         Random rnd = new Random();
         for (int inx = this.Count - 1; inx > 0; inx--)
         {
            int position = rnd.Next(inx + 1);
            T temp = this[inx];
            this[inx] = this[position];
            this[position] = temp;
         }
      }
      #endregion

      #region ICloneable

      ///<summary>
      /// Creates an exact copy of this TList{T} instance.
      ///</summary>
      ///<returns>The TList{T} object this method creates, cast as an object.</returns>
      ///<implements><see cref="ICloneable.Clone"/></implements>
      public object Clone()
      {
         return this.Copy();
      }

      ///<summary>
      /// Creates an exact copy of this TList{T} object.
      ///</summary>
      ///<returns>A new, identical copy of the TList{T}.</returns>
      public virtual TList<T> Copy()
      {
         TList<T> copy = new TList<T>();
         foreach (T item in this)
         {
            T itemCopy = (T)MakeCopyOf(item);
            copy.Add(itemCopy);
         }
         return copy;
      }

      ///<summary>
      /// Creates an exact copy of this TList{T} object.
      ///</summary>
      ///<returns>A new, identical copy of the TList{T} casted as object.</returns>
      public static object MakeCopyOf(object x)
      {
         if (x is ICloneable)
         {
            // Return a deep copy of the object
            return ((ICloneable)x).Clone();
         }
         else
         {
            throw new
                System.NotSupportedException("object not cloneable");
         }
      }
      #endregion ICloneable

      #region ITypedList Members

      /// <summary>
      /// This member allows binding objects to discover the field/column information.
      /// </summary>
      public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors)
      {
         return _propertyCollection;
      }

      /// <summary>
      /// This member returns the name displayed in the IDE.
      /// </summary>
      public string GetListName(PropertyDescriptor[] listAccessors)
      {
         return _listName;
      }

      #endregion // ITypedList

      #region IListSource Members

      /// <summary>
      /// Clean up. Nothing here though.
      /// </summary>
      public IList GetList()
      {
         return this;
      }

      /// <summary>
      /// Return TRUE if our list contains additional/child lists.
      /// </summary>
      public bool ContainsListCollection
      {
         // TODO: Implement nested lists
         get { return _containsListCollection; }
         set { _containsListCollection = value; }
      }

      #endregion // IListSource

      #region IComponent Members

      // Added to implement Site property correctly.
      private ISite _site = null;

      /// <summary>
      /// Get / Set the site where this data is located.
      /// </summary>
      public ISite Site
      {
         get { return _site; }
         set { _site = value; }
      }

      #endregion

      #region IDisposable Members

      /// <summary>
      /// Notify those that care when we dispose.
      /// </summary>
      public event System.EventHandler Disposed;

      /// <summary>
      /// Clean up. Nothing here though.
      /// </summary>
      public void Dispose()
      {
         this.Dispose(true);
         GC.SuppressFinalize(this);
      }

      /// <summary>
      /// Clean up.
      /// </summary>
      protected virtual void Dispose(bool disposing)
      {
         if (disposing)
         {
            EventHandler handler = Disposed;
            if (handler != null)
               handler(this, EventArgs.Empty);
         }
      }

      #endregion

      /// <summary>
      /// Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
      /// </summary>
      /// <returns>
      /// A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
      /// </returns>
      public override string ToString()
      {
         string s = this.GetType().Name + " Collection" + Environment.NewLine;
         foreach (T Item in this)
         {
            s += Item.ToString() + Environment.NewLine;
         }
         return s;
      }

      /// <summary>
      /// Raises the ListChanged event indicating that a item in the list has changed.
      /// </summary>
      /// <param name="entity"></param>
      internal void EntityChanged(T entity)
      {
         OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOf(entity)));
      }
      #region Added Functionality

      /// <summary>
      ///		Indicates whether the collection was modified or not, and thus if it needs to be saved.
      /// </summary>
      ///<returns>true is the collection needs to be saved; otherwise false.</returns>
      public virtual bool IsDirty
      {
         get
         {
            return IsNewCount > 0 || IsDeletedCount > 0 || IsDirtyCount > 0;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked new in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked new in the collection</returns>
      public virtual int IsNewCount
      {
         get
         {
            int count = 0;
            foreach (T item in this)
>>>>>>> 1.12
            {
               //if(item.IsNew)
               if (item.EntityState == EntityState.Added)
                  count += 1;
            }
            return count;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked to delete in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked for deletation in the collection</returns>
      public virtual int IsDeletedCount
      {
         get
         {
            /*
            int count = 0;
            foreach(T item in this)
            {
                //if(item.IsDeleted)
                if(item.EntityState == EntityState.Deleted)
                    count += 1;
            }
            return count;
            */
            return DeletedItems.Count;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked as modified in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked as modified in the collection</returns>
      public virtual int IsDirtyCount
      {
         get
         {
            int count = 0;
            foreach (T item in this)
            {
               //if(item.IsDirty)
               if (item.EntityState == EntityState.Changed)
                  count += 1;
            }
            return count;
         }
      }

      #region Deleted items

      private List<T> deletedItems;

      /// <summary>
      /// Hold a collection of item that we want to delete. they are removed from the main collection, so the databinding is working.
      /// </summary>
      /// <remark>The save method will loop on this collection to delete item from the datasource.</remark>
      public List<T> DeletedItems
      {
         get
         {
            if (this.deletedItems == null)
            {
               this.deletedItems = new List<T>();
            }
            return this.deletedItems;
         }
      }

      #endregion

      #endregion	Added Functionality

      #region Find

      ///<summary>
      /// Finds the first <see cref="IEntity" /> object in the current list matching the search criteria.
      ///</summary>
      /// <param name="propertyName">Property of the object to search.</param>
      /// <param name="value">Value to find.</param>
      public virtual T Find(string propertyName, object value)
      {
         PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(T));
         PropertyDescriptor searchBy = props.Find(propertyName, true);

         if (searchBy != null)
         {
            int index = this.FindCore(searchBy, value);

            if (index > -1)
            {
               return this[index];
            }
            else
            {
               return default(T);
            }
         }
         else
         {
            //No such property found
            return default(T);
         }



      }

      ///<summary>
      /// Finds a collection of <see cref="IEntity" /> objects in the current list matching the search criteria.
      ///</summary>
      /// <param name="propertyName">Property of the object to search.</param>
      /// <param name="value">Value to find.</param>
      public virtual TList<T> FindAll(string propertyName, object value)
      {
         PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(T));
         PropertyDescriptor searchBy = props.Find(propertyName, true);

         TList<T> copy = new TList<T>();

         int index = 0;

         while (index > -1)
         {
            index = this.FindCore(searchBy, value, index);

            if (index > -1)
            {
               T entity = this[index];
               if (entity is ICloneable)
               {
                  copy.Add((T)((ICloneable)entity).Clone());
               }

               //Increment the index to start at the next item
               index++;
            }
         }

         return copy;



      }

      #endregion Find

      #region IDeserializationCallback Members

      /// <summary>
      /// Runs when the entire object graph has been deserialized.
      /// </summary>
      /// <param name="sender">The object that initiated the callback.</param>
      public void OnDeserialization(object sender)
      {
         InitializeList();
      }

      #endregion


   }

   #region Sort Comparer
	/// <summary>
   /// Generic Sort comparer for the <see cref="TList{T}"/> class.
   /// </summary>
   /// <typeparam name="T">Type of object to sort.</typeparam>
   public class SortComparer<T> : IComparer<T>
   {
      /// <summary>
      /// Collection of properties to sort by.
      /// </summary>
      private ListSortDescriptionCollection m_SortCollection = null;

      /// <summary>
      /// Property to sort by.
      /// </summary>
      private PropertyDescriptor m_PropDesc = null;

      /// <summary>
      /// Direction to sort by
      /// </summary>
      private ListSortDirection m_Direction = ListSortDirection.Ascending;

      /// <summary>
      /// Collection of properties for T.
      /// </summary>
      private PropertyDescriptorCollection m_PropertyDescriptors = null;

      /// <summary>
      /// Create a new instance of the SortComparer class.
      /// </summary>
      /// <param name="propDesc">The <see cref="PropertyDescriptor"/> to sort by.</param>
      /// <param name="direction">The <see cref="ListSortDirection"/> to sort the list.</param>
      public SortComparer(PropertyDescriptor propDesc, ListSortDirection direction)
      {
         Initialize();
         m_PropDesc = propDesc;
         m_Direction = direction;
      }

      /// <summary>
      /// Create a new instance of the SortComparer class.
      /// </summary>
      /// <param name="sortCollection">A <see cref="ListSortDescriptionCollection"/> containing the properties to sort the list by.</param>
      public SortComparer(ListSortDescriptionCollection sortCollection)
      {
         Initialize();
         m_SortCollection = sortCollection;
      }

      /// <summary>
      /// Create a new instance of the SortComparer class.
      /// </summary>
      /// <param name="orderBy">SQL-like string representing the properties to sort the list by.</param>
      /// <remarks><i>orderBy</i> should be in the following format: 
      /// <para>PropertyName[[ [[ASC]|DESC]][, PropertyName[ [[ASC]|DESC]][,...]]]</para></remarks>
      /// <example><c>list.Sort("Property1, Property2 DESC, Property3 ASC");</c></example>
      public SortComparer(string orderBy)
      {
         Initialize();
         m_SortCollection = ParseOrderBy(orderBy);
      }

      #region IComparer<T> Members
      
      /// <summary>
      /// Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
      /// </summary>
      /// <param name="x">The first object to compare.</param>
      /// <param name="y">The second object to compare.</param>
      /// <returns>Value is less than zero: <c>x</c> is less than <c>y</c>
      /// <para>Value is equal to zero: <c>x</c> equals <c>y</c></para>
      /// <para>Value is greater than zero: <c>x</c> is greater than <c>y</c></para>
      /// </returns>
      public int Compare(T x, T y)
      {
         if (m_PropDesc != null) // Simple sort 
         {
            object xValue = m_PropDesc.GetValue(x);
            object yValue = m_PropDesc.GetValue(y);
            return CompareValues(xValue, yValue, m_Direction);
         }
         else if (m_SortCollection != null && m_SortCollection.Count > 0)
         {
            return RecursiveCompareInternal(x, y, 0);
         }
         else return 0;
      }
      #endregion

      #region Private Methods

      /// <summary>
      /// Compare two objects
      /// </summary>
      /// <param name="xValue">The first object to compare</param>
      /// <param name="yValue">The second object to compare</param>
      /// <param name="direction">The direction to sort the objects in</param>
      /// <returns>Returns an integer representing the order of the objects</returns>
      private int CompareValues(object xValue, object yValue, ListSortDirection direction)
      {

         int retValue = 0;
         if (xValue != null && yValue == null)
         {
            retValue = 1;
         }
         else if (xValue == null && yValue != null)
         {
            retValue = -1;

         }
         else if (xValue == null && yValue == null)
         {
            retValue = 0;
         }
         else if (xValue is IComparable) // Can ask the x value
         {
            retValue = ((IComparable)xValue).CompareTo(yValue);
         }
         else if (yValue is IComparable) //Can ask the y value
         {
            retValue = ((IComparable)yValue).CompareTo(xValue);
         }
         else if (!xValue.Equals(yValue)) // not comparable, compare String representations
         {
            retValue = xValue.ToString().CompareTo(yValue.ToString());
         }
         if (direction == ListSortDirection.Ascending)
         {
            return retValue;
         }
         else
         {
            return retValue * -1;
         }
      }

      private int RecursiveCompareInternal(T x, T y, int index)
      {
         if (index >= m_SortCollection.Count)
            return 0; // termination condition

         ListSortDescription listSortDesc = m_SortCollection[index];
         object xValue = listSortDesc.PropertyDescriptor.GetValue(x);
         object yValue = listSortDesc.PropertyDescriptor.GetValue(y);

         int retValue = CompareValues(xValue, yValue, listSortDesc.SortDirection);
         if (retValue == 0)
         {
            return RecursiveCompareInternal(x, y, ++index);
         }
         else
         {
            return retValue;
         }
      }

      /// <summary>
      /// Parses a string into a <see cref="ListSortDescriptionCollection"/>.
      /// </summary>
      /// <param name="orderBy">SQL-like string of sort properties</param>
      /// <returns></returns>
      private ListSortDescriptionCollection ParseOrderBy(string orderBy)
      {
         if (orderBy == null || orderBy.Length == 0)
            throw new ArgumentNullException("orderBy");

         string[] props = orderBy.Split(',');
         ListSortDescription[] sortProps = new ListSortDescription[props.Length];
         string prop;
         ListSortDirection sortDirection = ListSortDirection.Ascending;

         for (int i = 0; i < props.Length; i++)
         {
            //Default to Ascending
            sortDirection = ListSortDirection.Ascending;
            prop = props[i].Trim();

            if (prop.ToUpper().EndsWith(" DESC"))
            {
               sortDirection = ListSortDirection.Descending;
               prop = prop.Substring(0, prop.ToUpper().LastIndexOf(" DESC"));
            }
            else if (prop.ToUpper().EndsWith(" ASC"))
            {
               prop = prop.Substring(0, prop.ToUpper().LastIndexOf(" ASC"));
            }

            prop = prop.Trim();

            //Get the appropriate descriptor
            PropertyDescriptor propertyDescriptor = m_PropertyDescriptors[prop];

            if (propertyDescriptor == null)
            {
               throw new ArgumentException(string.Format("The property \"{0}\" is not a valid property.", prop));
            }
            sortProps[i] = new ListSortDescription(propertyDescriptor, sortDirection);

         }

         return new ListSortDescriptionCollection(sortProps);
      }

      /// <summary>
      /// Initializes the SortComparer object
      /// </summary>
      private void Initialize()
      {
         Type instanceType = typeof(T);

         if (!instanceType.IsPublic)
            throw new ArgumentException(string.Format("Type \"{0}\" is not public.", typeof(T).FullName));

         m_PropertyDescriptors = TypeDescriptor.GetProperties(typeof(T));

      }

      #endregion
   }
   #endregion
}