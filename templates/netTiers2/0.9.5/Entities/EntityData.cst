<%--
 * $Id: EntityData.cst,v 1.2 2005/12/14 10:04:22 jroland Exp $
 * Last modified by $Author: bgjohnso $
 * Last modified at $Date: 2006-03-18 00:48:43 -0600 (Sat, 18 Mar 2006) $
 * $Revision: 69 $
--%>
<%@ CodeTemplate Src="..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Business object base class"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Connection" Description="Table Object should be based on." %>
<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Connection" Description="Tables of the sytem." %>

<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
	
<%@ Property Name="NameSpace" Optional="True" Type="System.String" Category="Style" Description="Object Namespace." %>
<%
	/* string className = GetClassName(SourceTable.Name); */
	string structName = GetStructName(SourceTable.Name);
%>
		
	/// <summary>
	///		The data structure representation of the '<%=SourceTable.Name%>' table.
	/// </summary>
	/// <remarks>
	/// 	This struct is generated by a tool and should never be modified.
	/// </remarks>
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Serializable]
	internal class <%=structName%> : ICloneable
	{
		#region Variable Declarations
		
		#region Primary key(s)
		<%
			for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++)
			{%>
			/// <summary>			
			/// <%=SourceTable.PrimaryKey.MemberColumns[i].Name%> : <%= GetColumnXmlComment(SourceTable.PrimaryKey.MemberColumns[i],2)%>
			/// </summary>
			/// <remarks>Member of the primary key of the underlying table "<%=SourceTable.Name%>"</remarks>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
				
			<%
				if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i])))
				{%>
			/// <summary>
			/// keep a copy of the original so it can be used for editable primary keys.
			/// </summary>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
			
				<%}
			}
		%>
		#endregion
		
		#region Non Primary key(s)
		
		<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
		
		/// <summary>
		/// <%=SourceTable.NonPrimaryKeyColumns[x].Name%> : <%=GetColumnXmlComment(SourceTable.NonPrimaryKeyColumns[x],2)%>
		/// </summary>
		public <%= GetCSType(SourceTable.NonPrimaryKeyColumns[x]) %><%= Tab(2) %>  <%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %> = <% if ( SourceTable.NonPrimaryKeyColumns[x].AllowDBNull) { %>null<% } else { %><%=GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x])%><% }%>;
		<% } //end for each non PK column %>
		#endregion
			
		#endregion "Variable Declarations"
		
		public Object Clone()
		{
			<%=structName%> _tmp = new <%=structName%>();
						
			<% for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
			_tmp.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%> = this.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
			<% if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i]))) {%>
			_tmp.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%> = this.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
			<% } %>
			<% } %>
			
			<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
			_tmp.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %> = this.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %>;
			<% } %>
			
			return _tmp;
		}
		
<% 
		
if(IncludeRelations)
{	
	WriteRelationshipPropertyString();
}
		
%>
	}//End struct

<script runat="template">
///<summary>
/// Many To Many Relationship Class Template Property String
///</summary>
protected static string MANY_TO_MANY = @"
	  private {1} {2};
      public {1} {0}
      {{
         get
         {{
            if ({2} == null)
            {{
               {2} = new {1}();
            }}

            return {2};
         }}
         set {{ {2} = value; }}
      }}
";

///<summary>
/// One to One Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_ONE = @"
	  private {0} {1};
      public {0} {0}
      {{
         get {{		return {1};		}}
         set {{ 	{1} = value; 	}}
      }}
";
		
///<summary>
/// One To Many Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_MANY = @"
	  private {3} {1};
      public {3} {0}
      {{
         get
         {{
            if ({1} == null)
            {{
               {1} = new {3}();
            }}

            return {1};
         }}
         set {{ {1} = value; }}
      }}
";
		
///<summary>
///   Writes out the property string of all the relationship object collections.
///</summary>
private void WriteRelationshipPropertyString()
{	
	///Loop Child Collections
	foreach (CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables))
	{
		
		///Assign by RelationshipType, Then Write to Response
		switch((int)item.CollectionRelationshipType)
		{
			///One To One Relationship
			case (int)RelationshipType.OneToOne:
				object[] oneToOneParams = {
							GetClassName(item.SecondaryTable), 
							GetPrivateName(item.SecondaryTable)
				};
				item.PropertyString = string.Format(ONE_TO_ONE, oneToOneParams);
				break;
				
			///One To Many, Many To One
			case (int)RelationshipType.OneToMany:
			case (int)RelationshipType.ManyToOne:
			    object[] oneToManyParams = {
						GetCollectionPropertyName(item.SecondaryTable)
						, GetPrivateName(item.SecondaryTable)
						, GetClassName(item.SecondaryTable)
						, GetCollectionClassName(item.SecondaryTable)						
				};
			item.PropertyString = string.Format(ONE_TO_MANY, oneToManyParams);
			break;
			
			///Many To Many
			case (int)RelationshipType.ManyToMany:
				object[] manyToManyParams = {
						//GetCollectionClassName(item.CleanName) + "_From_" + GetClassName(item.JunctionTable), 
						item.CollectionName,
						GetCollectionClassName(item.SecondaryTable),
						GetPrivateName(item.SecondaryTable)
				};
				item.PropertyString = string.Format(MANY_TO_MANY, manyToManyParams);
				break;
			default:
				break;
		}
		
		if (!RenderedChildren.Contains(item.CleanName))
		{
			///Write it out to the resonse stream
			Response.Write(item.PropertyString);	
			RenderedChildren.Add(item.CleanName);
		}
	}///End foreach loop
	
	///enable use for the next template
	RenderedChildren.Clear();
}
</script>

