<%--
 * $Id: IEntity.cst,v 1.13 2006/02/27 22:09:40 bgjohnso Exp $
 * Last modified by $Author: bgjohnso $
 * Last modified at $Date: 2006/02/27 22:09:40 $
 * $Revision: 1.13 $
--%>
<%@ CodeTemplate Src="..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="The interface that each business object of the domain implements."%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Import Namespace="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="True" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeCustoms" Type="System.Boolean" Default="True" Category="Options" Description="If true customs stored procedures will be generated as functions." %>
<%@ Property Name="IncludeInsert" Type="System.Boolean" Default="True" Category="Options" Description="If true insert functions will be generated." %>
<%@ Property Name="IncludeUpdate" Type="System.Boolean" Default="True" Category="Options" Description="If true update functions will be generated." %>
<%@ Property Name="IncludeSave" Type="System.Boolean" Default="True" Category="Options" Description="If true combined insert/update functions will be generated." %>
<%@ Property Name="IncludeDelete" Type="System.Boolean" Default="True" Category="Options" Description="If true delete functions will be generated." %>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="True" Category="Options" Description="If true select statements will be generated for any many to many relationship." %>
<%@ Property Name="IncludeGetList" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>
<%@ Property Name="IncludeGetListByIX" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeFind" Type="System.Boolean" Default="True" Category="Options" Description="If true find functions will be generated." %>

<%@ Property Name="NameSpace" Optional="False" Type="System.String" Category="Style" Description="Object Namespace." %>
<%@ Property Name="BLLNameSpace" Optional="False" Type="System.String" Category="Style" Description="BLL Object Namespace." %>
<%@ Property Name="DALNameSpace" Optional="False" Type="System.String" Category="Style" Description="DAL Object Namespace." %>
<%@ Assembly Name="SchemaExplorer" %>
#region Using Directives
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using <%=BLLNameSpace%>;
using <%=BLLNameSpace%>.Validation;
using <%=DALNameSpace%>;
using <%=DALNameSpace%>.Bases;

using Microsoft.Practices.EnterpriseLibrary.Logging;
#endregion

namespace <%=NameSpace%>
{
	/// <summary>
	/// The interface that each component business domain service of the model implements.
	/// </summary>
	public abstract class ServiceBaseCore<Entity, EntityKey> : EntityProviderBase<Entity, EntityKey>, IComponentService
		where Entity : IEntityId<EntityKey>, new() 
		where EntityKey : IEntityKey, new()
	{
		
		private IList<IProcessor> processorList = new List<IProcessor>();
		private ServiceResult serviceResult = null;
		private bool abortOnFailure = true;
		private int currentProcessorIndex = 0;
		
		/// <summary>
		///	Provides the beginning
		/// </summary>
		///<value>A list of business rule processors to execute</value>
		public virtual ServiceResult Execute()
		{
			return Execute(false);
		}
		
		/// <summary>
		///	Provides the beginning
		/// </summary>
		///<value>A list of business rule processors to execute</value>
		public virtual ServiceResult Execute(bool abortIfFailure)
		{
			AbortOnFailure = abortIfFailure;
			ServiceResult result = new ServiceResult();
		
		
			for(int i=0; i < ProcessorList.Count; i++)
			{
				currentProcessorIndex = i;
				
				if (ProcessorList[i] == null)
					throw new ArgumentNullException(string.Format("The process located at index {0} of the ProcessorList is null.", i));
					
				//Fire Process Starting Event
				OnProcessStarting((ProcessorBase)ProcessorList[i]);
				
				ProcessorList[i].ChangeProcessorState(ProcessorState.Running);
				IProcessorResult processResult = null;
				
				try
				{
					//Begin Process
					processResult = ProcessorList[i].Process();
				}
				catch(Exception exc)
				{
					Logger.Write(exc);
					result.ExceptionList.Add((ProcessorBase)ProcessorList[i], exc);
				}
				
				//if the processor didn't do cleanup, cleanup by default.
				if (ProcessorList[i].CurrentProcessorState == ProcessorState.Running)
					ProcessorList[i].ChangeProcessorState(processResult.Result ? ProcessorState.Completed : ProcessorState.Stopped);

				if (processResult != null)
				{
					//Add to Processor Result List
					result.ProcessorResultList.Add(processResult);
	
					//Add To Aggregated Broken Rules List
 					foreach(BrokenRulesList list in processResult.BrokenRulesLists.Values)
                        result.ProcessBrokenRuleLists.Add((ProcessorBase)ProcessorList[i], list);				
				}
				
				//Fire Process Ending Event
				OnProcessEnded(ProcessorList[i] as ProcessorBase);

				if ((processResult == null || !processResult.Result) && AbortOnFailure)
					return result;

			}
			return result;
		}
		
		/// <summary>
		///	Provides a List of Processors to execute external business process logic in.
		/// </summary>
		///<value>A list of business rule processors to execute</value>
		public virtual IList<IProcessor> ProcessorList 
		{
			get
				{
					return processorList;
				} 
			set
				{
					processorList = value;
				}
		}

		/// <summary>
		///	Provides a Notification Pattern of Process Results.
		/// </summary>
		///<value>A list of business rule processors to execute</value>
		public virtual ServiceResult ServiceProcessResult
		{
			get{
				if (serviceResult == null)
					serviceResult = new ServiceResult();
				
				return serviceResult;
			}
		}

		/// <summary>
		///	Provides a way to terminate the Processor calls upon an exception. 
		/// </summary>
		///<value>bool value determining to stop once an exceptions been thrown. </value>		
		public virtual bool AbortOnFailure 
		{
			get
			{
				return abortOnFailure;
			} 
			set
			{
				abortOnFailure = value;
			} 
		}

		/// <summary>
		/// Current Processor being executed
		/// </summary>
		public virtual string CurrentProcessor
		{
			get {
					if (ProcessorList.Count > CurrentProcessorIndex)
						return ProcessorList[CurrentProcessorIndex].ProcessName;
					
					return null;
				}	
		}

		/// <summary>
		/// Current Number of Processes completed thus far.
		/// </summary>
		public virtual int ProcessCounter
		{
			get {return currentProcessorIndex + 1;}
		}
		
		/// <summary>
		/// Current index of the processor currently or last executed 
		/// </summary>
		public virtual int CurrentProcessorIndex
		{
			get {return currentProcessorIndex;}
		}
		
		/// <summary>
		/// Total Number of Processes currently enlisted in this service 
		/// </summary>
		public virtual int TotalProcesses
		{
			get {return ProcessorList.Count;}		
		}
		
		#region Events
		/// <summary>
		///	Provides the notification on the change of process state to interested parties.
		/// </summary>
		public virtual void OnProcessStarting(ProcessorBase processor)
		{
			if (ProcessStarting != null)
				ProcessStarting(this, new ProcessorEventArgs(processor));
		}

		/// <summary>
		///	Provides the notification on the change of process state to interested parties.
		/// </summary>
		public virtual void OnProcessEnded(ProcessorBase processor)
		{
			if (ProcessEnded != null)
				ProcessEnded(this, new ProcessorEventArgs(processor));
		}
		
		/// <summary>
		/// Event to indicate that a processor has began.
		/// </summary>
		[field: NonSerialized]
		public event ProcessStartingHandler ProcessStarting;

		/// <summary>
		/// Event to indicate that a processor has ended.
		/// </summary>
		[field: NonSerialized]
		public event ProcessEndedHandler ProcessEnded;
	
		#endregion Events	

		#region IEntityProvider Implementation
		
		<% if ( IncludeGetList ) { %>
		#region GetAll Methods

		/// <summary>
		/// Gets all rows from the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out. The number of rows that match this query.</param>
		/// <returns>Returns a TList of Entity objects.</returns>
		public override TList<Entity> GetAll(TransactionManager mgr, int start, int pageLength, out int count)
		{
			return GetAll(mgr, start, pageLength, out count, null, null);
		}

		/// <summary>
		/// Gets all rows from the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out. The number of rows that match this query.</param>
		/// <param name="connectionStringKey">A pre-configured key for usage of another dataprovider.</param>
		/// <param name="dynamicConnectionString">A dynamic connection string to use for this particular instance.</param>
		/// <returns>Returns a TList of Entity objects.</returns>
		public abstract TList<Entity> GetAll(TransactionManager mgr, int start, int pageLength, out int count, string connectionStringKey, string dynamicConnectionString);

		#endregion

		#region GetPaged Methods

		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC).</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <returns>Returns a TList of Entity objects.</returns>
		public override TList<Entity> GetPaged(TransactionManager mgr, String whereClause, String orderBy, int start, int pageLength, out int count)
		{
			return GetPaged(mgr, whereClause, orderBy, start, pageLength, out count, null, null);
		}

		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC).</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <param name="connectionStringKey">A pre-configured key for usage of another dataprovider.</param>
		/// <param name="dynamicConnectionString">A dynamic connection string to use for this particular instance.</param>
		/// <returns>Returns a TList of Entity objects.</returns>
		public abstract TList<Entity> GetPaged(TransactionManager mgr, String whereClause, String orderBy, int start, int pageLength, out int count, string connectionStringKey, string dynamicConnectionString);

		#endregion

		<% } // end if ( IncludeGetList ) %>
		<% if ( IncludeFind ) { %>
		#region Find Functions
		
		/// <summary>
		/// Returns rows meeting the whereClause condition from the DataSource.
		/// </summary>
		/// <param name="transactionManager">A <see cref="TransactionManager"/> object.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of Entity objects.</returns>
		public override TList<Entity> Find(TransactionManager transactionManager, string whereClause, int start, int pageLength, out int count)
		{
			return Find(transactionManager, whereClause, start, pageLength, out count, null, null);
		}
		
		/// <summary>
		/// Returns rows meeting the whereClause condition from the DataSource.
		/// </summary>
		/// <param name="transactionManager">A <see cref="TransactionManager"/> object.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <param name="connectionStringKey">A pre-configured key for usage of another dataprovider.</param>
		/// <param name="dynamicConnectionString">A dynamic connection string to use for this particular instance.</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of Entity objects.</returns>
		public abstract TList<Entity> Find(TransactionManager transactionManager, string whereClause, int start, int pageLength, out int count, string connectionStringKey, string dynamicConnectionString);
		
		#endregion "Find Functions"
		
		<% } // end if ( IncludeFind ) %>
		<% if ( IncludeInsert ) { %>
		#region Insert Methods

		/// <summary>
		/// Inserts a row into the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to insert.</param>
		/// <returns>Returns true if the operation is successful.</returns>
		public override bool Insert(TransactionManager mgr, Entity entity)
		{
			// check if borrowed transaction
			bool isBorrowedTransaction = (mgr != null && mgr.IsOpen);
			Insert(mgr, isBorrowedTransaction, entity, null, null);
			return true;
		}

		/// <summary>
		/// Inserts a row into the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="isBorrowedTransaction">Bool, determines if the call is already made in the context of a transaction.</param>
		/// <param name="entity">The Entity object to insert.</param>
		/// <param name="connectionStringKey" >Already Configured Connection String Key</param>
		/// <param name="dynamicConnectionString" >Dynamic Connection String</param>
		/// <returns>Returns true if the operation is successful.</returns>
		public abstract Entity Insert(TransactionManager mgr, bool isBorrowedTransaction, Entity entity, string connectionStringKey, string dynamicConnectionString);

		/// <summary>
		/// Efficiently inserts multiple rows into the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entities">TList of Entity objects to insert.</param>
		public override void BulkInsert(TransactionManager mgr, TList<Entity> entities)
		{
			throw new NotImplementedException("The BulkInsert method has not been implemented.");
		}

		#endregion
		
		<%	} // end if ( IncludeInsert ) %>
		<% if ( IncludeUpdate ) { %>
		#region Update Methods

		/// <summary>
		/// Updates an existing row in the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to update.</param>
		/// <returns>Returns true if the operation is successful.</returns>
		public override bool Update(TransactionManager mgr, Entity entity)
		{
			// check if borrowed transaction
			bool isBorrowedTransaction = (mgr != null && mgr.IsOpen);
			Update(mgr, isBorrowedTransaction, entity, null, null);
			return true;
		}

		/// <summary>
		/// Updates an existing row in the DataSource.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="isBorrowedTransaction">Bool, determines if the call is already made in the context of a transaction.</param>
		/// <param name="entity">The Entity object to update.</param>
		/// <param name="connectionStringKey" >Already Configured Connection String Key</param>
		/// <param name="dynamicConnectionString" >Dynamic Connection String</param>
		/// <returns>Returns true if the operation is successful.</returns>
		public abstract Entity Update(TransactionManager mgr, bool isBorrowedTransaction, Entity entity, string connectionStringKey, string dynamicConnectionString);

		#endregion

		<%	} // end if ( IncludeUpdate ) %>
		<% if ( IncludeGetListByFK ) { %>
		#region DeepLoad

		#region DeepLoad Entity

		/// <summary>
		/// Deep Load the entire Entity object with criteria based on the child types array and the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to load.</param>
		/// <param name="deep">A flag that indicates whether to recursively load all Property Collections that are descendants of this instance. If True, loads the complete object graph below this object. If False, loads this object only.</param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Load.</param>
		public override void DeepLoad(TransactionManager mgr, Entity entity, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			DeepLoad(mgr, entity, deep, deepLoadType, null, null, childTypes);
		}

		/// <summary>
		/// Deep Load the entire Entity object with criteria based on the child types array and the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to load.</param>
		/// <param name="deep">A flag that indicates whether to recursively load all Property Collections that are descendants of this instance. If True, loads the complete object graph below this object. If False, loads this object only.</param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Load.</param>
		/// <param name="innerList">A Hashtable of child types for easy access.</param>
		protected override void DeepLoad(TransactionManager mgr, Entity entity, bool deep, DeepLoadType deepLoadType, System.Type[] childTypes, Hashtable innerList)
		{
			DeepLoad(mgr, entity, deep, deepLoadType, null, null, childTypes);
		}

		/// <summary>
		/// Deep Load the entire Entity object with criteria based on the child types array and the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to load.</param>
		/// <param name="deep">A flag that indicates whether to recursively load all Property Collections that are descendants of this instance. If True, loads the complete object graph below this object. If False, loads this object only.</param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="connectionStringKey">a pre-configured connection string to use.</param>
		/// <param name="dynamicConnectionString">a runtime dynamic connection string to use (connectionStringKey is required if you supply a dynamicConnectionString).  If already added to the DataRepository.Connections, only the connectionStringKey is required.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Load.</param>
		public abstract void DeepLoad(TransactionManager mgr, Entity entity, bool deep, DeepLoadType deepLoadType, string connectionStringKey, string dynamicConnectionString, params System.Type[] childTypes);

		#endregion DeepLoad Entity

		#region DeepLoad Entity Collection

		/// <summary>
		/// Deep Load the Entity objects with criteria based on the child types array and the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entities">TList of Entity objects to load.</param>
		/// <param name="deep">A flag that indicates whether to recursively load all Property Collections that are descendants of this instance. If True, loads the complete object graph below this object. If False, loads this object only.</param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Load.</param>
		public override void DeepLoad(TransactionManager mgr, TList<Entity> entities, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			DeepLoad(mgr, entities, deep, deepLoadType, null, null, childTypes);
		}

		/// <summary>
		/// Deep Loads the entire <see cref="TList{Entity}" /> object with criteria based of the child 
		/// property collections only N Levels Deep based on the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with Recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection">The <see cref="TList{Entity}" /> instance to load.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively save all Property Collection that are descendants of this instance. If True, saves the complete object graph below this object. If False, saves this object only. </param>
		/// <param name="deepLoadType"><see cref="DeepLoadType"/> Enumeration to Include/Exclude object property collections from Load.
		///		Use DeepLoadType.IncludeChildren, ExcludeChildren to traverse the entire object graph.
		///	</param>
		/// <param name="connectionStringKey">a pre-configured connection string to use.</param>
		/// <param name="dynamicConnectionString">a runtime dynamic connection string to use (connectionStringKey is required if you supply a dynamicConnectionString).  If already added to the DataRepository.Connections, only the connectionStringKey is required.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Load</param>
		public abstract void DeepLoad(TransactionManager transactionManager, TList<Entity> entityCollection, bool deep, DeepLoadType deepLoadType, string connectionStringKey, string dynamicConnectionString, params System.Type[] childTypes);

		#endregion DeepLoad Entity Collection

		#endregion
		
		<% } // end if ( IncludeGetListByFK ) %>
		<% if ( IncludeSave ) { %>
		#region DeepSave

		#region DeepSave Entity

		/// <summary>
		/// Deep Save the entire Entity object with criteria based on the child types array and the DeepSaveType.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to save.</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Save.</param>
		public override bool DeepSave(TransactionManager mgr, Entity entity, DeepSaveType deepSaveType, params System.Type[] childTypes)
		{
			// check if borrowed transaction
			bool isBorrowedTransaction = ( mgr != null && mgr.IsOpen );
			DeepSave(mgr, entity, deepSaveType, isBorrowedTransaction, null, null, childTypes);
			return true;
		}

		/// <summary>
		/// Deep Save the entire Entity object with criteria based on the child types array and the DeepSaveType.
		/// </summary>
		/// <remarks>
		/// This method should be implemented by sub-classes to provide specific deep save functionality.
		/// </remarks>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entity">The Entity object to save.</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Save.</param>
		/// <param name="innerList">A Hashtable of child types for easy access.</param>
		protected override void DeepSave(TransactionManager mgr, Entity entity, DeepSaveType deepSaveType, System.Type[] childTypes, Hashtable innerList)
		{
			// check if borrowed transaction
			bool isBorrowedTransaction = ( mgr != null && mgr.IsOpen );
			DeepSave(mgr, entity, deepSaveType, isBorrowedTransaction, null, null, childTypes);
		}

		/// <summary>
		/// public virtualDeep Saves the entire object graph of the Entity object with criteria based of the child 
		/// Type property array and DeepSaveType.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entity">The Entity object to save.</param>
		/// <param name="isBorrowedTransaction">specifies whether the transaction is part of a larger transaction context, if true the transaction must be created and open.</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="connectionStringKey">a pre-configured connection string to use.</param>
		/// <param name="dynamicConnectionString">a runtime dynamic connection string to use (connectionStringKey is required if you supply a dynamicConnectionString).  If already added to the DataRepository.Connections, only the connectionStringKey is required.</param>		
		/// <param name="childTypes">Entity property Type Array To Include or Exclude from Save</param>
		public abstract bool DeepSave(TransactionManager transactionManager, Entity entity, DeepSaveType deepSaveType, bool isBorrowedTransaction, string connectionStringKey, string dynamicConnectionString, params System.Type[] childTypes);

		#endregion DeepSave Entity

		#region DeepSave Entity Collection

		/// <summary>
		/// Deep Save the Entity objects with criteria based on the child types array and the DeepSaveType.
		/// </summary>
		/// <param name="mgr">A <see cref="TransactionManager"/> object.</param>
		/// <param name="entities">TList of Entity objects to save.</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Save.</param>
		public override bool DeepSave(TransactionManager mgr, TList<Entity> entities, DeepSaveType deepSaveType, params System.Type[] childTypes)
		{
			// check if borrowed transaction
			bool isBorrowedTransaction = ( mgr != null && mgr.IsOpen );
			DeepSave(mgr, entities, deepSaveType, isBorrowedTransaction, null, null, childTypes);
			return true;
		}

		/// <summary>
		/// Deep Save the entire object graph of the <see cref="TList{Entity}" /> object with criteria based of the child 
		/// property collections.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection"><see cref="TList{Entity}" /> Object</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="isBorrowedTransaction">specifies whether the transaction is part of a larger transaction context, if true the transaction must be created and open.</param>
		/// <param name="connectionStringKey">a pre-configured connection string to use.</param>
		/// <param name="dynamicConnectionString">a runtime dynamic connection string to use (connectionStringKey is required if you supply a dynamicConnectionString).  If already added to the DataRepository.Connections, only the connectionStringKey is required.</param>		
		/// <param name="childTypes">Entity Property Collection Type Array To Include or Exclude from Save</param>
		public abstract bool DeepSave(TransactionManager transactionManager, TList<Entity> entityCollection, DeepSaveType deepSaveType, bool isBorrowedTransaction, string connectionStringKey, string dynamicConnectionString, params System.Type[] childTypes);

		#endregion DeepSave Entity Collection

		#endregion
		
		<% } // end if ( IncludeSave ) %>
		#endregion IEntityProvider Implementation
	}

	/// <summary>
	/// ProcessStartingHandler
	/// </summary>
	/// <param name="sender"></param>
	/// <param name="args"></param>
	public delegate void ProcessStartingHandler(object sender, ProcessorEventArgs args);

	/// <summary>
	/// ProcessEndedHandler
	/// </summary>
	/// <param name="sender"></param>
	/// <param name="args"></param>
	public delegate void ProcessEndedHandler(object sender, ProcessorEventArgs args);
	
	/// <summary>
	/// ProcessorEventArgs
	/// </summary>
	public class ProcessorEventArgs : EventArgs
	{
		private ProcessorBase processor;
		
		/// <summary>
		/// Initializes a new instance of the ProcessorEventArgs class.
		/// </summary>
		/// <param name="processor"></param>
		public ProcessorEventArgs(ProcessorBase processor)
		{
			this.processor = processor;
		}
	}
}
