<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>Matches spans containing a term. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>Base class for span-based queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="M:Lucene.Net.Search.Query.SetBoost(System.Single)">
            <summary>Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.GetBoost">
            <summary>Gets the boost for this clause.  Documents matching
            this clause will (in addition to the normal weightings) have their score
            multiplied by <code>b</code>.   The boost is 1.0 by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.ToString(System.String)" -->
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.Searcher)" -->
        <member name="M:Lucene.Net.Search.Query.Weight(Lucene.Net.Search.Searcher)">
            <summary>Expert: Constructs an initializes a Weight for a top-level query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Expert: called to re-write queries into primitive queries. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.Combine(Lucene.Net.Search.Query[])" -->
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Hashtable)">
            <summary> Expert: adds all terms occuring in this query to the terms set</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.MergeBooleanQueries(Lucene.Net.Search.Query[])" -->
        <member name="M:Lucene.Net.Search.Query.GetSimilarity(Lucene.Net.Search.Searcher)">
            <summary>Expert: Returns the Similarity implementation to be used for this query.
            Subclasses may override this method to specify their own Similarity
            implementation, perhaps one that delegates through that of the Searcher.
            By default the Searcher's Similarity implementation is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>Returns a clone of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.IndexReader)">
            <summary>Expert: Returns the matches for this query in an index.  Used internally
            to search for spans. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetField">
            <summary>Returns the name of the Field matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerm">
            <summary>Return the term whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Start">
            <summary>Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.End">
            <summary>Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PriorityQueue">
            <summary>A PriorityQueue maintains a partial ordering of its elements such that the
            least element can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.LessThan(System.Object,System.Object)">
            <summary>Determines the ordering of objects in this priority queue.  Subclasses
            must define this one method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Initialize(System.Int32)">
            <summary>Subclass constructors must call this. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Put(System.Object)">
            <summary> Adds an Object to a PriorityQueue in log(size) time.
            If one tries to add more objects than maxSize from initialize
            a RuntimeException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Insert(System.Object)">
            <summary> Adds element to the PriorityQueue in log(size) time if either
            the PriorityQueue is not full, or not lessThan(element, top()).
            </summary>
            <param name="">element
            </param>
            <returns> true if element is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Top">
            <summary>Returns the least element of the PriorityQueue in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Pop">
            <summary>Removes and returns the least element of the PriorityQueue in log(size)
            time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.AdjustTop">
            <summary>Should be called when the Object at top changes values.  Still log(n)
            worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Size">
            <summary>Returns the number of elements currently stored in the PriorityQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Clear">
            <summary>Removes all entries from the PriorityQueue. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpans.SpansCell">
            <summary>Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Scorer" -->
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Constructs a Scorer.</summary>
            <param name="similarity">The <code>Similarity</code> implementation used by this scorer.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetSimilarity">
            <summary>Returns the Similarity implementation used by this scorer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector,System.Int32)">
            <summary>Expert: Collects matching documents in a range.  Hook for optimization.
            Note that {@link #next()} must be called once before this method is called
            for the first time.
            </summary>
            <param name="hc">The collector to which all matching documents are passed through
            {@link HitCollector#Collect(int, float)}.
            </param>
            <param name="max">Do not score documents past this.
            </param>
            <returns> true if more matching documents may remain.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Next" -->
        <member name="M:Lucene.Net.Search.Scorer.Doc">
            <summary>Returns the current document number matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #next()} or {@link #skipTo(int)}
            is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Explain(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms matching <code>term</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTerm">
            <summary>Returns the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetEnum(Lucene.Net.Index.IndexReader)">
            <summary>Construct the enumeration to be used, expanding the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiSearcher" -->
        <member name="T:Lucene.Net.Search.Searcher">
            <summary>An abstract base class for search implementations.
            Implements some common utility methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searchable" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)">
            <summary>Expert: Low-level search implementation.
            Identical to {@link #Search(Query, Filter, HitCollector)}, but takes
            a Weight instead of a query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Close">
            <summary>Frees resources associated with this Searcher.
            Be careful not to call this method while you are still using objects
            like {@link Hits}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreq(Lucene.Net.Index.Term)">
            <summary>Expert: Returns the number of documents containing <code>term</code>.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="!:IndexReader#docFreq(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreqs(Lucene.Net.Index.Term[])">
            <summary>Expert: For each term in the terms array, calculates the number of
            documents containing <code>term</code>. Returns an array with these
            document frequencies. Used to minimize number of remote calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.MaxDoc">
            <summary>Expert: Returns one greater than the largest possible document number.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="!:IndexReader#maxDoc()">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)">
            <summary>Expert: Low-level search implementation.
            Identical to {@link #Search(Query, Filter, int)}, but takes
            a Weight instead of a query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32)">
            <summary>Expert: Returns the stored fields of document <code>i</code>.
            Called by {@link HitCollector} implementations.
            </summary>
            <seealso cref="!:IndexReader#document(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Rewrite(Lucene.Net.Search.Query)">
            <summary>Expert: called to re-write queries into primitive queries.</summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <member name="M:Lucene.Net.Search.Searchable.Explain(Lucene.Net.Search.Weight,System.Int32)">
            <summary> Identical to {@link #Search(Query, Filter, HitCollector)}, but takes
            a Weight instead of a query.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary>Expert: Low-level search implementation.
            Identical to {@link #Search(Query, Filter, int, Sort)}, but takes
            a Weight instead of a query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query)">
            <summary>Returns the documents matching <code>query</code>. </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>Returns the documents matching <code>query</code> and
            <code>filter</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> sorted by
            <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> and <code>filter</code>,
            sorted by <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.HitCollector)" -->
        <member name="F:Lucene.Net.Search.Searcher.similarity">
            <summary>The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this Searcher.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.GetSimilarity" -->
        <member name="M:Lucene.Net.Search.MultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.GetSearchables">
            <summary>Return the array of {@link Searchable}s this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SearcherIndex(System.Int32)">
            <summary>Call {@link #subSearcher} instead.</summary>
            <deprecated>
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubSearcher(System.Int32)">
            <summary>Returns index of the searcher for document <code>n</code> in the array
            used to construct this searcher. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubDoc(System.Int32)">
            <summary>Returns the document number of document <code>n</code> within its
            sub-index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.PrepareWeight(Lucene.Net.Search.Query)">
            <summary> Distributed query processing is done in the following steps:
            1. rewrite query
            2. extract necessary terms
            3. collect dfs for these terms from the Searchables
            4. create query weight using aggregate dfs.
            5. distribute that weight to Searchables
            6. merge results
            
            Steps 1-4 are done here, 5+6 in the search() methods
            
            </summary>
            <returns> rewritten queries
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.HitCollector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitCollector.Collect(System.Int32,System.Single)" -->
        <member name="T:Lucene.Net.Search.MultiSearcher.CachedDfSource">
            <summary> Document Frequency cache acting as a Dummy-Searcher.
            This class is no full-fledged Searcher, but only supports
            the methods necessary to initialize Weights.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery">
            <summary> A query that applies a filter to the results of another query.
            
            <p>Note: the bits are retrieved from the filter each time this
            query is used in a search - use a CachingWrapperFilter to avoid
            regenerating the bits every time.</p>
            
            <p>Created: Apr 20, 2004 8:58:29 AM</p>
            
            </summary>
            <author>   Tim Jones
            </author>
            <since>   1.4
            </since>
            <version>  $Id$
            </version>
            <seealso cref="T:Lucene.Net.Search.CachingWrapperFilter">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary> Constructs a new query which applies a filter to the results of the original query.
            Filter.bits() will be called every time this query is used in a search.
            </summary>
            <param name="query"> Query to be filtered, cannot be <code>null</code>.
            </param>
            <param name="filter">Filter to apply to query results, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.Searcher)">
            <summary> Returns a Weight that applies the filter to the enclosed query's Weight.
            This is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Rewrites the wrapped query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.GetQuery">
            <summary>The query that this concerns. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetValue">
            <summary>The weight for this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.SumOfSquaredWeights">
            <summary>The sum of squared weights of contained query clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single)">
            <summary>Assigns the query normalization factor to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.IndexReader)">
            <summary>Constructs a scorer for this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>An explanation of the score computation for the named document. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsWriter">
            <summary> Writer works by opening a document and then opening the fields within the document and then
            writing out the vectors for each Field.
            
            Rough usage:
            
            <CODE>
            for each document
            {
            writer.openDocument();
            for each Field on the document
            {
            writer.openField(Field);
            for all of the terms
            {
            writer.addTerm(...)
            }
            writer.closeField
            }
            writer.closeDocument()    
            }
            </CODE>
            
            </summary>
            <version>  $Id$
            
            </version>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.OpenField(System.String)">
            <summary>Start processing a Field. This can be followed by a number of calls to
            addTerm, and a final call to closeField to indicate the end of
            processing of this Field. If a Field was previously open, it is
            closed automatically.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.CloseField">
            <summary>Finished processing current Field. This should be followed by a call to
            openField before future calls to addTerm.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.IsFieldOpen">
            <summary>Return true if a Field is currently open. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddTerm(System.String,System.Int32)">
            <summary>Add term to the field's term vector. Field must already be open.
            Terms should be added in
            increasing order of terms, one call per unique termNum. ProxPointer
            is a pointer into the TermPosition file (prx). Freq is the number of
            times this term appears in this field, in this document.
            </summary>
            <throws>  IllegalStateException if document or field is not open </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.TermFreqVector[])">
            <summary> Add a complete document specified by all its term vectors. If document has no
            term vectors, add value for tvx.
            
            </summary>
            <param name="">vectors
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.Close">
            <summary>Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsReader">
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Size">
            <summary> </summary>
            <returns> The number of documents in the reader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32,System.String)">
            <summary> Retrieve the term vector for the given document and field</summary>
            <param name="docNum">The document number to retrieve the vector for
            </param>
            <param name="field">The field within the document to retrieve
            </param>
            <returns> The TermFreqVector for the document and field or null if there is no termVector for this field.
            </returns>
            <throws>  IOException if there is an error reading the term vector files </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32)">
            <summary> Return all term vectors stored for this document or null if the could not be read in.
            
            </summary>
            <param name="docNum">The document number to retrieve the vector for
            </param>
            <returns> All term frequency vectors
            </returns>
            <throws>  IOException if there is an error reading the term vector files  </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.ReadTermVector(System.String,System.Int64)">
            <summary> </summary>
            <param name="field">The field to read in
            </param>
            <param name="tvfPointer">The pointer within the tvf file where we should start reading
            </param>
            <returns> The TermVector located at that position
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>Access to the Field Info file that describes document fields and whether or
            not they are indexed. Each segment has a separate Field Info file. Objects
            of this class are thread-safe for multiple readers, but only one thread can
            be adding documents at a time, with no other reader or writer threads
            accessing this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary> Construct a FieldInfos object using the directory and the name of the file
            IndexInput
            </summary>
            <param name="d">The directory to open the IndexInput from
            </param>
            <param name="name">The name of the file to open the IndexInput from in the Directory
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(Lucene.Net.Documents.Document)">
            <summary>Adds Field info for a Document. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.AddIndexed(System.Collections.ICollection,System.Boolean,System.Boolean,System.Boolean)">
            <summary> Add fields that are indexed. Whether they have termvectors has to be specified.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="storeTermVectors">Whether the fields store term vectors or not
            </param>
            <param name="storePositionWithTermVector">treu if positions should be stored.
            </param>
            <param name="storeOffsetWithTermVector">true if offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.Collections.ICollection,System.Boolean)">
            <summary> Assumes the fields are not storing term vectors.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="isIndexed">Whether the fields are indexed or not
            
            </param>
            <seealso cref="!:boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean)">
            <summary> Calls 5 parameter add with false for all TermVector parameters.
            
            </summary>
            <param name="name">The name of the Field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <seealso cref="!:boolean, boolean, boolean, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean)">
            <summary> Calls 5 parameter add with false for term vector positions and offsets.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed"> true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldName(System.Int32)">
            <summary> Return the fieldName identified by its number.
            
            </summary>
            <param name="">fieldNumber
            </param>
            <returns> the fieldName or an empty string when the field
            with the given number doesn't exist.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary> Return the fieldinfo object referenced by the fieldNumber.</summary>
            <param name="">fieldNumber
            </param>
            <returns> the FieldInfo object or null when the given fieldNumber
            doesn't exist.
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceAnalyzer">
            <summary>An Analyzer that uses WhitespaceTokenizer. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer">
            <summary>An Analyzer builds TokenStreams, which analyze text.  It thus represents a
            policy for extracting index terms from text.
            <p>
            Typical implementations first build a Tokenizer, which breaks the stream of
            characters from the Reader into raw Tokens.  One or more TokenFilters may
            then be applied to the output of the Tokenizer.
            </p>
            <p>
            WARNING: You must override one of the methods defined by this class in your
            subclass or the Analyzer will enter an infinite loop.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Default implementation forwards to tokenStream(Reader) for 
            compatibility with older version.  Override to allow Analyzer to choose 
            strategy based on document and/or Field.  Must be able to handle null
            Field name for backward compatibility. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Provided for backward compatibility only.
            </summary>
            <deprecated> use TokenStream(String, Reader) instead.
            </deprecated>
            <seealso cref="!:Reader)">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Analysis.Token">
            <summary>A Token is an occurence of a term from the text of a Field.  It consists of
            a term's text, the start and end offset of the term in the text of the Field,
            and a type string.
            The start and end offsets permit applications to re-associate a token with
            its source text, e.g., to display highlighted query terms in a document
            browser, or to show matching text fragments in a KWIC (KeyWord In Context)
            display, etc.
            The type is an interned string, assigned by a lexical analyzer
            (a.k.a. tokenizer), naming the lexical or syntactic class that the token
            belongs to.  For example an end of sentence marker token might be implemented
            with type "eos".  The default token type is "word".  
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.SetPositionIncrement(System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.GetPositionIncrement">
            <summary>Returns the position increment of this Token.</summary>
            <seealso cref="!:#setPositionIncrement">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermText">
            <summary>Returns the Token's term text. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.StartOffset">
            <summary>Returns this Token's starting offset, the position of the first character
            corresponding to this token in the source text.
            Note that the difference between endOffset() and startOffset() may not be
            equal to termText.length(), as the term text may have been altered by a
            stemmer or some other filter. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.EndOffset">
            <summary>Returns this Token's ending offset, one greater than the position of the
            last character corresponding to this token in the source text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Type">
            <summary>Returns this Token's lexical type.  Defaults to "word". </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Standard.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.FastCharStream" -->
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexInput">
            <summary>Abstract base class for input from a file in a {@link Directory}.  A
            random-access input stream.  Used for all Lucene index input operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadByte">
            <summary>Reads and returns a single byte.</summary>
            <seealso cref="!:IndexOutput#WriteByte(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a specified number of bytes into an array at the specified offset.</summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <seealso cref="!:IndexOutput#WriteBytes(byte[],int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadInt">
            <summary>Reads four bytes and returns an int.</summary>
            <seealso cref="!:IndexOutput#WriteInt(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVInt">
            <summary>Reads an int stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:IndexOutput#WriteVInt(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadLong">
            <summary>Reads eight bytes and returns a long.</summary>
            <seealso cref="!:IndexOutput#WriteLong(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVLong">
            <summary>Reads a long stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadString">
            <summary>Reads a string.</summary>
            <seealso cref="!:IndexOutput#WriteString(String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadChars(System.Char[],System.Int32,System.Int32)">
            <summary>Reads UTF-8 encoded characters into an array.</summary>
            <param name="buffer">the array to read characters into
            </param>
            <param name="start">the offset in the array to start storing characters
            </param>
            <param name="length">the number of characters to read
            </param>
            <seealso cref="!:IndexOutput#WriteChars(String,int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Close">
            <summary>Closes the stream to futher operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            <summary>Returns the current position in this file, where the next read will
            occur.
            </summary>
            <seealso cref="!:#Seek(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next read will occur.</summary>
            <seealso cref="!:#GetFilePointer()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexInput.Clone" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopFieldDocs" -->
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="!:Searcher#Search(Query,Filter,int)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.totalHits">
            <summary>Expert: The total number of hits for the query.</summary>
            <seealso cref="!:Hits#Length()">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.scoreDocs">
            <summary>Expert: The top hits for the query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[])">
            <summary>Expert: Constructs a TopDocs.</summary>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldDocs.fields">
            <summary>The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[])">
            <summary>Creates one of these objects.</summary>
            <param name="totalHits"> Total number of hits for the query.
            </param>
            <param name="scoreDocs"> The top hits for the query.
            </param>
            <param name="fields">    The sort criteria used to find the top hits.
            </param>
        </member>
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="T:Lucene.Net.Search.TopDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.score">
            <summary>Expert: The score of this document for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.doc">
            <summary>Expert: A hit document's number.</summary>
            <seealso cref="!:Searcher#Doc(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Constructs a ScoreDoc. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this Field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this Field.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.specialToken">
            <summary> This Field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this Field is set to null.
            When there are more than one such special token, this Field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken Field, and so on
            until the first special token (whose specialToken Field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this Field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Term">
            <summary>A Term represents a word from text.  This is the unit of search.  It is
            composed of two elements, the text of the word, as a string, and the name of
            the Field that the text occured in, an interned string.
            Note that terms may represent more than words from text fields, but also
            things like dates, email addresses, urls, etc.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String,System.String)">
            <summary>Constructs a Term with the given Field and text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Field">
            <summary>Returns the Field of this term, an interned string.   The Field indicates
            the part of a document which this term came from. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>Returns the text of this term.  In the case of words, this is simply the
            text of the word.  In the case of dates and other types, this is an
            encoding of the object as a string.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Equals(System.Object)">
            <summary>Compares two terms, returning true iff they have the same
            Field and text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.GetHashCode">
            <summary>Combines the hashCode() of the Field and the text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
            <summary>Compares two terms, returning a negative integer if this
            term belongs before the argument, zero if this term is equal to the
            argument, and a positive integer if this term belongs after the argument.
            The ordering of terms is first by field, then by text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Set(System.String,System.String)">
            <summary>Resets the Field and text of a Term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateField" -->
        <member name="M:Lucene.Net.Documents.DateField.DateToString(System.DateTime)">
            <summary> Converts a Date to a string suitable for indexing.</summary>
            <throws>  RuntimeException if the date specified in the </throws>
            <summary> method argument is before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.TimeToString(System.Int64)">
            <summary> Converts a millisecond time to a string suitable for indexing.</summary>
            <throws>  RuntimeException if the time specified in the </throws>
            <summary> method argument is negative, that is, before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToTime(System.String)">
            <summary>Converts a string-encoded date into a millisecond time. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToDate(System.String)">
            <summary>Converts a string-encoded date into a Date object. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer">
            <summary>Filters LetterTokenizer with LowerCaseFilter and StopFilter. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.StopAnalyzer.ENGLISH_STOP_WORDS">
            <summary>An array containing some common English words that are not usually useful
            for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor">
            <summary>Builds an analyzer which removes words in ENGLISH_STOP_WORDS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer which removes words in the provided array. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:IThreadRunnable">
            <summary>
            This interface should be implemented by any class whose instances are intended 
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:IThreadRunnable.Run">
            <summary>
            This method has to be implemented in order that starting of the thread causes the object's 
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:SupportClass.ThreadClass.threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
            <param name="NanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread. Calling this method 
            usually terminates the thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread while also providing
            exception information about the thread termination. 
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current Object
            </summary>
            <returns>A String that represents the current Object</returns>
        </member>
        <member name="M:SupportClass.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="P:SupportClass.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="T:SupportClass.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:SupportClass.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="T:SupportClass.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:SupportClass.Character.ForDigit(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="digit"></param>
            <param name="radix"></param>
            <returns></returns>
        </member>
        <member name="P:SupportClass.Character.MAX_RADIX">
            <summary>
            </summary>
        </member>
        <member name="P:SupportClass.Character.MIN_RADIX">
            <summary>
            </summary>
        </member>
        <member name="T:SupportClass.Date">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Date.GetTime(System.DateTime)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Single">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.AppSettings">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary> A memory-resident {@link InputStream} implementation.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>Base implementation class for buffered {@link IndexInput}. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current position
            in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="length">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where the
            next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="!:#ReadInternal(byte[],int,int)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.MMapDirectory" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.FSDirectory" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Directory" -->
        <member name="M:Lucene.Net.Store.Directory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.
            If a file already exists with the new name, then it is replaced.
            This replacement should be atomic. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>Returns the length of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateFile(System.String)">
            <deprecated> use {@link #CreateOutput(String)} 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenFile(System.String)">
            <deprecated> use {@link #OpenInput(String)} 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Close">
            <summary>Closes the store. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.DIRECTORIES">
            <summary>This cache of directories ensures that there is a unique Directory
            instance per path, so that synchronization on the Directory can be used to
            synchronize access between readers and writers.
            
            This should be a WeakHashMap, so that entries can be GC'd, but that would
            require Java 1.2.  Instead we use refcounts...
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.LOCK_DIR">
            <summary> Directory specified by <code>Lucene.Net.lockdir</code>
            or <code>java.io.tmpdir</code> system property
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.IMPL">
            <summary>The default class which implements filesystem-based directories. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.buffer">
            <summary>A buffer optionally used in renameTo method </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,System.Boolean)" -->
        <member name="M:Lucene.Net.Store.FSDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.IO.FileInfo,System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.HEX_DIGITS">
            <summary> So we can do some byte-to-hexchar conversion below</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.MakeLock(System.String)" -->
        <member name="M:Lucene.Net.Store.FSDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>For debug output. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Lock" -->
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>Attempts to obtain exclusive access and immediately return
            upon success or failure.
            </summary>
            <returns> true iff exclusive access is obtained
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>Attempts to obtain an exclusive lock within amount
            of time given. Currently polls once per second until
            lockWaitTimeout is passed.
            </summary>
            <param name="lockWaitTimeout">length of time to wait in ms
            </param>
            <returns> true if lock was obtained
            </returns>
            <throws>  IOException if lock wait times out or obtain() throws an IOException </throws>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Release">
            <summary>Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>Returns true if the resource is currently locked.  Note that one must
            still call {@link #Obtain()} before using the resource. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock)">
            <summary>Constructs an executor that will grab the named lock.
            Defaults lockWaitTimeout to Lock.COMMIT_LOCK_TIMEOUT.
            </summary>
            <deprecated> Kept only to avoid breaking existing code.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>Constructs an executor that will grab the named lock. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.DoBody">
            <summary>Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.Run">
            <summary>Calls {@link #doBody} while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            {@link #doBody} exits. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarity" -->
        <member name="F:Lucene.Net.Search.Similarity.defaultImpl">
            <summary>The Similarity implementation used by default. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            <summary>Set the default Similarity implementation used by indexing and search
            code.
            
            </summary>
            <seealso cref="!:Searcher#SetSimilarity(Similarity)">
            </seealso>
            <seealso cref="!:IndexWriter#SetSimilarity(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.GetDefault" -->
        <member name="F:Lucene.Net.Search.Similarity.NORM_TABLE">
            <summary>Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            <summary>Decodes a normalization factor stored in an index.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.GetNormDecoder">
            <summary>Returns a table for decoding normalization bytes.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.LengthNorm(System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.EncodeNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.SloppyFreq(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(Lucene.Net.Index.Term,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Collections.ICollection,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Coord(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.SimilarityDelegator.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Construct a {@link Similarity} that delegates all methods to another.
            
            </summary>
            <param name="delegee">the Similarity implementation to delegate to
            </param>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Precedence.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.Precedence.ParseException.#ctor(Lucene.Net.QueryParsers.Precedence.Token,System.Int32[][],System.String[])" -->
        <member name="M:Lucene.Net.QueryParsers.Precedence.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.Precedence.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenizer" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenStream" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Next">
            <summary>Returns the next token in the stream, or null at EOS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Close">
            <summary>Releases resources associated with this stream. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.input">
            <summary>The text source for this Tokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor">
            <summary>Construct a tokenizer with null input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Close">
            <summary>By default, closes the input Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.#ctor(Lucene.Net.Analysis.Standard.Token,System.Int32[][],System.String[])">
            <summary> This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.  The boolean
            flag "specialConstructor" is also set to true to indicate that
            this constructor was used to create this object.
            This constructor calls its super class with the empty string
            to force the "toString" method of parent class "Throwable" to
            print the error message in the form:
            ParseException: &lt;result of getMessage&gt;
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Standard.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PorterStemFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenFilter" -->
        <member name="F:Lucene.Net.Analysis.TokenFilter.input">
            <summary>The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor">
            <summary>Call TokenFilter(TokenStream) instead.</summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Close">
            <summary>Close the input TokenStream. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemFilter.Next">
            <summary>Returns the next input Token, after being stemmed </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>Matches the union of its clauses.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.NonMatchingScorer">
            <summary>A scorer that matches no document at all. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermFreqVector">
            <summary>Provides access to stored term vector of 
            a document Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetField">
            <summary> </summary>
            <returns> The Field this vector is associated with.
            
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.Size">
            <returns> The number of terms in the term vector.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTerms">
            <returns> An Array of term texts in ascending order.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTermFrequencies">
            <summary>Array of term frequencies. Locations of the array correspond one to one
            to the terms in the array obtained from <code>getTerms</code>
            method. Each location in the array contains the number of times this
            term occurs in the document or the document Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexOf(System.String)">
            <summary>Return an index in the term numbers array returned from
            <code>getTerms</code> at which the term with the specified
            <code>term</code> appears. If this term does not appear in the array,
            return -1.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexesOf(System.String[],System.Int32,System.Int32)">
            <summary>Just like <code>indexOf(int)</code> but searches for a number of terms
            at the same time. Returns an array that has the same size as the number
            of terms searched for, each slot containing the result of searching for
            that term number.
            
            </summary>
            <param name="terms">array containing terms to look for
            </param>
            <param name="start">index in the array where the list of terms starts
            </param>
            <param name="len">the number of terms in the list
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.StandardTokenizer" -->
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader)">
            <summary>Constructs a tokenizer for this Reader. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardTokenizer.Next" -->
        <member name="T:Lucene.Net.Analysis.LowerCaseFilter">
            <summary> Normalizes token text to lower case.
            
            </summary>
            <version>  $Id: LowerCaseFilter.java,v 1.4 2004/03/29 22:48:00 cutting Exp $
            </version>
        </member>
        <member name="T:Lucene.Net.Util.BitVector">
            <summary>Optimized implementation of a vector of bits.  This is more-or-less like
            java.util.BitSet, but also includes the following:
            <ul>
            <li>a count() method, which efficiently computes the number of one bits;</li>
            <li>optimized read from and write to disk;</li>
            <li>inlinable get() method;</li>
            </ul>
            </summary>
            <author>  Doug Cutting
            </author>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(System.Int32)">
            <summary>Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Set(System.Int32)">
            <summary>Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Clear(System.Int32)">
            <summary>Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Get(System.Int32)">
            <summary>Returns <code>true</code> if <code>bit</code> is one and
            <code>false</code> if it is zero. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Size">
            <summary>Returns the number of bits in this vector.  This is also one greater than
            the number of the largest valid bit number. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Count">
            <summary>Returns the total number of one bits in this vector.  This is efficiently
            computed and cached, so that, if the vector is not changed, no
            recomputation is done for repeated calls. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Write(Lucene.Net.Store.Directory,System.String)">
            <summary>Writes this vector to the file <code>name</code> in Directory
            <code>d</code>, in a format that can be read by the constructor {@link
            #BitVector(Directory, String)}.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Constructs a bit vector from the file <code>name</code> in Directory
            <code>d</code>, as written by the {@link #write} method.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexOutput">
            <summary>Abstract base class for output to a file in a Directory.  A random-access
            output stream.  Used for all Lucene index output operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.IndexInput">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="!:IndexInput#ReadByte()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="!:IndexInput#ReadBytes(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteInt(System.Int32)">
            <summary>Writes an int as four bytes.</summary>
            <seealso cref="!:IndexInput#ReadInt()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVInt(System.Int32)">
            <summary>Writes an int in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:IndexInput#ReadVInt()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteLong(System.Int64)">
            <summary>Writes a long as eight bytes.</summary>
            <seealso cref="!:IndexInput#ReadLong()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVLong(System.Int64)">
            <summary>Writes an long in a variable-length format.  Writes between one and five
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="!:IndexInput#ReadVLong()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteString(System.String)">
            <summary>Writes a string.</summary>
            <seealso cref="!:IndexInput#ReadString()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteChars(System.String,System.Int32,System.Int32)">
            <summary>Writes a sequence of UTF-8 encoded characters from a string.</summary>
            <param name="s">the source of the characters
            </param>
            <param name="start">the first character in the sequence
            </param>
            <param name="length">the number of characters in the sequence
            </param>
            <seealso cref="!:IndexInput#ReadChars(char[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="!:#Seek(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="!:#GetFilePointer()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="T:Lucene.Net.Search.RangeFilter">
            <summary> A Filter that restricts search results to a range of values in a given
            field.
            
            <p>
            This code borrows heavily from {@link RangeQuery}, but is implemented as a Filter
            (much like {@link DateFilter}).
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>Abstract base class providing a mechanism to restrict searches to a subset
            of an index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.Bits(Lucene.Net.Index.IndexReader)">
            <summary>Returns a BitSet with true for documents which should be permitted in
            search results, and false for those that should not. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <param name="fieldName">The field this range applies to
            </param>
            <param name="lowerTerm">The lower bound on this range
            </param>
            <param name="upperTerm">The upper bound on this range
            </param>
            <param name="includeLower">Does this range include the lower bound?
            </param>
            <param name="includeUpper">Does this range include the upper bound?
            </param>
            <throws>  IllegalArgumentException if both terms are null or if </throws>
            <summary>  lowerTerm is null and includeLower is true (similar for upperTerm
            and includeUpper)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Less(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            less than or equal to <code>upperTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.More(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            greater than or equal to <code>lowerTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Returns a BitSet with true for documents which should be
            permitted in search results, and false for those that should
            not.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ParallelMultiSearcher" -->
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.DocFreq(Lucene.Net.Index.Term)">
            <summary> TODO: parallelize this one too</summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)">
            <summary> A search implementation which spans a new thread for each
            Searchable, waits for each search to complete and merge
            the results back together.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary> A search implementation allowing sorting which spans a new thread for each
            Searchable, waits for each search to complete and merges
            the results back together.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="T:Lucene.Net.Search.MultiSearcherThread">
            <summary> A thread subclass for searching a single searchable </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>A simple hash table of document scores within a range. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Precedence.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <deprecated> 
            </deprecated>
            <seealso cref="!:#getEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.MultiFieldQueryParser">
            <summary> A QueryParser which constructs queries to search multiple fields.
            
            </summary>
            <author>  <a href="mailto:kelvin@relevanz.com">Kelvin Tan</a>
            </author>
            <version>  $Revision$
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.QueryParser" -->
        <member name="F:Lucene.Net.QueryParsers.QueryParser.DEFAULT_OPERATOR_OR">
            <deprecated> use {@link #OR_OPERATOR} instead 
            </deprecated>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.DEFAULT_OPERATOR_AND">
            <deprecated> use {@link #AND_OPERATOR} instead 
            </deprecated>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.operator_Renamed">
            <summary>The actual operator that parser uses to combine query terms </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String,System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Parses a query string, returning a {@link Lucene.Net.search.Query}.</summary>
            <param name="query"> the query string to be parsed.
            </param>
            <param name="field"> the default field for query terms.
            </param>
            <param name="analyzer">  used to find terms in the query text.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Constructs a query parser.</summary>
            <param name="f"> the default field for query terms.
            </param>
            <param name="a">  used to find terms in the query text.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String)">
            <summary>Parses a query string, returning a {@link Lucene.Net.search.Query}.</summary>
            <param name="query"> the query string to be parsed.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAnalyzer">
            <returns> Returns the analyzer.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetField">
            <returns> Returns the field.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyMinSim">
            <summary> Get the minimal similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyMinSim(System.Single)">
            <summary> Set the minimum similarity for fuzzy queries.
            Default is 0.5f.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyPrefixLength">
            <summary> Get the prefix length for fuzzy queries. </summary>
            <returns> Returns the fuzzyPrefixLength.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyPrefixLength(System.Int32)">
            <summary> Set the prefix length for fuzzy queries. Default is 0.</summary>
            <param name="fuzzyPrefixLength">The fuzzyPrefixLength to set.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetPhraseSlop(System.Int32)">
            <summary> Sets the default slop for phrases.  If zero, then exact phrase matches
            are required.  Default value is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetPhraseSlop">
            <summary> Gets the default slop for phrases.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetOperator(System.Int32)">
            <summary> Sets the boolean operator of the QueryParser.
            In default mode (<code>DEFAULT_OPERATOR_OR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>DEFAULT_OPERATOR_AND</code> terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
            <deprecated> use {@link #SetDefaultOperator(QueryParser.Operator)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDefaultOperator(Lucene.Net.QueryParsers.QueryParser.Operator)">
            <summary> Sets the boolean operator of the QueryParser.
            In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>AND_OPERATOR</code> mode terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetOperator">
            <summary> Gets implicit operator setting, which will be either DEFAULT_OPERATOR_AND
            or DEFAULT_OPERATOR_OR.
            </summary>
            <deprecated> use {@link #GetDefaultOperator()} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetDefaultOperator">
            <summary> Gets implicit operator setting, which will be either AND_OPERATOR
            or OR_OPERATOR.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLowercaseWildcardTerms(System.Boolean)">
            <summary> Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
            <deprecated> use {@link #SetLowercaseExpandedTerms(boolean)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLowercaseExpandedTerms(System.Boolean)">
            <summary> Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLowercaseWildcardTerms">
            <deprecated> use {@link #GetLowercaseExpandedTerms()} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLowercaseExpandedTerms">
            <seealso cref="!:#SetLowercaseExpandedTerms(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLocale(System.Globalization.CultureInfo)">
            <summary> Set locale used by date range parsing.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLocale">
            <summary> Returns current locale, allowing access by subclasses.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String)">
            <summary> Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyzer.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
            <deprecated> use {@link #GetFieldQuery(String, String)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String,System.Int32)">
            <summary> Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyzer.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
            <deprecated> use {@link #GetFieldQuery(String, String, int)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String,String)}.
            This method may be overridden, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String,System.String,System.Boolean)">
            <summary> Note that parameter analyzer is ignored. Calls inside the parser always
            use class member analyzer.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
            <deprecated> use {@link #GetRangeQuery(String, String, String, boolean)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList,System.Boolean)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            </param>
            <param name="disableCoord">true if coord scoring should be disabled.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetWildcardQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetPrefixQuery(System.String,System.String)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String)">
            <deprecated> use {@link #GetFuzzyQuery(String, String, float)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String,System.Single)">
            <summary> Factory method for generating a query (similar to
            {@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.DiscardEscapeChar(System.String)">
            <summary> Returns a String where the escape char has been
            removed, or kept only once if there was a double escape.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Escape(System.String)">
            <summary> Returns a String where those characters that QueryParser
            expects to be escaped are escaped by a preceding <code>\</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.Main(System.String[])" -->
        <member name="T:Lucene.Net.Util.Parameter">
            <summary> A serializable Enum class.</summary>
        </member>
        <member name="M:Lucene.Net.Util.Parameter.ReadResolve">
            <summary> Resolves the deserialized instance to the local reference for accurate
            equals() and == comparisons.
            
            </summary>
            <returns> a reference to Parameter as resolved in the local VM
            </returns>
            <throws>  ObjectStreamException </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String[],Lucene.Net.Analysis.Analyzer)">
            <summary> Creates a MultiFieldQueryParser.
            
            <p>It will, when parse(String query)
            is called, construct a query like this (assuming the query consists of
            two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
            
            <code>
            (title:term1 body:term1) (title:term2 body:term2)
            </code>
            
            <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
            
            <code>
            +(title:term1 body:term1) +(title:term2 body:term2)
            </code>
            
            <p>In other words, all the query's terms must appear, but it doesn't matter in
            what fields they appear.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.GetFuzzyQuery(System.String,System.String)">
            <deprecated> use {@link #GetFuzzyQuery(String, String, float)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.GetRangeQuery(System.String,Lucene.Net.Analysis.Analyzer,System.String,System.String,System.Boolean)">
            <throws>  ParseException </throws>
            <deprecated> use {@link #GetRangeQuery(String, String, String, boolean)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(Lucene.Net.QueryParsers.QueryParserTokenManager)">
            <deprecated> use {@link #MultiFieldQueryParser(String[], Analyzer)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(Lucene.Net.QueryParsers.CharStream)">
            <deprecated> use {@link #MultiFieldQueryParser(String[], Analyzer)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <deprecated> use {@link #MultiFieldQueryParser(String[], Analyzer)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],Lucene.Net.Analysis.Analyzer)">
            <summary> <p>Parses a query which searches on the fields specified.
            If x fields are specified, this effectively constructs:</p>
            
            <code>
            (field1:query) (field2:query) (field3:query)...(fieldx:query)
            </code>
            
            </summary>
            <param name="query">Query string to parse
            </param>
            <param name="fields">Fields to search on
            </param>
            <param name="analyzer">Analyzer to use
            </param>
            <throws>  ParseException if query parsing fails </throws>
            <throws>  TokenMgrError if query parsing fails </throws>
            <deprecated> use {@link #Parse(String)} instead but note that it
            returns a different query for queries where all terms are required:
            its query excepts all terms, no matter in what field they occur whereas
            the query built by this (deprecated) method expected all terms in all fields 
            at the same time.
            </deprecated>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],System.Int32[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],System.Int32[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="M:Lucene.Net.Index.SegmentMerger.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>This ctor used only by test code.
            
            </summary>
            <param name="dir">The Directory to merge the other segments into
            </param>
            <param name="name">The name of the new segment
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Add(Lucene.Net.Index.IndexReader)">
            <summary> Add an IndexReader to the collection of readers that are to be merged</summary>
            <param name="">reader
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.SegmentReader(System.Int32)">
            <summary> </summary>
            <param name="i">The index of the reader to return
            </param>
            <returns> The ith reader to be merged
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary> Merges the readers specified by the {@link #add} method into the directory passed to the constructor</summary>
            <returns> The number of documents that were merged
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CloseReaders">
            <summary> close all IndexReaders that have been added.
            Should not be called before merge().
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            <summary> </summary>
            <returns> The number of documents in all of the readers
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary> Merge the TermVectors from each of the segments into the new one.</summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeTermInfo(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Merge one term found in one or more segments. The array <code>smis</code>
            contains segments that are positioned at the same term. <code>N</code>
            is the number of cells in the array actually occupied.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.AppendPostings(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Process postings from multiple segments all positioned on the
            same term. Writes out merged entries into freqOutput and
            the proxOutput streams.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <returns> number of documents across all segments where this term was found
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceTokenizer">
            <summary>A WhitespaceTokenizer is a tokenizer that divides text at whitespace.
            Adjacent sequences of non-Whitespace characters form tokens. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharTokenizer">
            <summary>An abstract base class for simple, character-oriented tokenizers.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.IsTokenChar(System.Char)">
            <summary>Returns true iff a character should be included in a token.  This
            tokenizer generates as tokens adjacent sequences of characters which
            satisfy this predicate.  Characters for which this is false are used to
            define token boundaries and are not included in tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Normalize(System.Char)">
            <summary>Called on each token character to normalize it before it is added to the
            token.  The default implementation does nothing.  Subclasses may use this
            to, e.g., lowercase tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Next">
            <summary>Returns the next token in the stream, or null at EOS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new WhitespaceTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which do not satisfy
            {@link Character#isWhitespace(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardFilter">
            <summary>Normalizes tokens extracted with {@link StandardTokenizer}. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct filtering <i>in</i>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardFilter.Next" -->
        <member name="T:Lucene.Net.Util.Constants">
            <summary> Some useful constants.
            
            </summary>
            <author>   Doug Cutting
            </author>
            <version>  $Id$
            
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.JAVA_VERSION" -->
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_1">
            <summary>True iff this is Java version 1.1. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_2">
            <summary>True iff this is Java version 1.2. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.JAVA_1_3">
            <summary>True iff this is Java version 1.3. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.OS_NAME" -->
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>True iff running on SunOS. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetSlop">
            <summary>Return the maximum number of intervening unmatched positions permitted.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>Return true if matches are required to be in-order.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
            <summary>Matches spans near the beginning of a Field. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetMatch">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetEnd">
            <summary>Return the maximum end position permitted in a match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparator" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparatorSource" -->
        <member name="M:Lucene.Net.Search.SortComparatorSource.NewComparator(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Creates a comparator for the Field in the given index.</summary>
            <param name="reader">Index to create comparator for.
            </param>
            <param name="fieldname"> Field to create comparator for.
            </param>
            <returns> Comparator of ScoreDoc objects.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SortComparator.GetComparable(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ScoreDocComparator.Compare(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.ScoreDoc)" -->
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortValue(Lucene.Net.Search.ScoreDoc)">
            <summary> Returns the value used to sort the given document.  The
            object returned must implement the java.io.Serializable
            interface.  This is used by multisearchers to determine how to collate results from their searchers.
            </summary>
            <seealso cref="T:Lucene.Net.Search.FieldDoc">
            </seealso>
            <param name="i">Document
            </param>
            <returns> Serializable object
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortType">
            <summary> Returns the type of sort.  Should return <code>SortField.SCORE</code>, <code>SortField.DOC</code>, <code>SortField.STRING</code>, <code>SortField.INTEGER</code>, 
            <code>SortField.FLOAT</code> or <code>SortField.CUSTOM</code>.  It is not valid to return <code>SortField.AUTO</code>.
            This is used by multisearchers to determine how to collate results from their searchers.
            </summary>
            <returns> One of the constants in SortField.
            </returns>
            <seealso cref="T:Lucene.Net.Search.SortField">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.StringIndex" -->
        <member name="F:Lucene.Net.Search.StringIndex.lookup">
            <summary>All the term values, in natural order. </summary>
        </member>
        <member name="F:Lucene.Net.Search.StringIndex.order">
            <summary>For each document, an index into the lookup array. </summary>
        </member>
        <member name="M:Lucene.Net.Search.StringIndex.#ctor(System.Int32[],System.String[])">
            <summary>Creates one of these objects </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.STRING_INDEX">
            <summary>Indicator for StringIndex values in the cache. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.DEFAULT">
            <summary>Expert: The cache used internally by sorting and range query classes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>Field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the integers.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>Field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the floats.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStrings(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>Field</code> and returns an array
            of size <code>reader.maxDoc()</code> containing the value each document
            has in the given Field.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the strings.
            </param>
            <returns> The values in the given Field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStringIndex(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the term values in <code>Field</code> and returns
            an array of them in natural order, along with an array telling
            which element in the term array each document uses.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the strings.
            </param>
            <returns> Array of terms and index into the array for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found reads <code>Field</code> to see if it contains integers, floats
            or strings, and then calls one of the other methods in this class to get the
            values.  For string values, a StringIndex is returned.  After
            calling this method, there is an entry in the cache for both
            type <code>AUTO</code> and the actual found type.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the values.
            </param>
            <returns> int[], float[] or StringIndex.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetCustom(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.SortComparator)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the terms out of <code>Field</code> and calls the given SortComparator
            to get the sort values.  A hit in the cache will happen if <code>reader</code>,
            <code>Field</code>, and <code>comparator</code> are the same (using <code>equals()</code>)
            as a previous call to this method.
            </summary>
            <param name="reader"> Used to get Field values.
            </param>
            <param name="Field">  Which Field contains the values.
            </param>
            <param name="comparator">Used to convert terms into something to sort by.
            </param>
            <returns> Array of sort objects, one for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="T:Lucene.Net.Index.TermPositionVector">
            <summary>Extends <code>TermFreqVector</code> to provide additional information about
            positions in which each of the terms is found. A TermPositionVector not necessarily
            contains both positions and offsets, but at least one of these arrays exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetTermPositions(System.Int32)">
            <summary>Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            May return null if positions have not been stored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            May return null if offsets have not been stored.
            
            </summary>
            <seealso cref="!:Lucene.Net.analysis.Token">
            
            </seealso>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermPositions" -->
        <member name="T:Lucene.Net.Index.TermDocs">
            <summary>TermDocs provides an interface for enumerating &lt;document, frequency&gt;
            pairs for a term.  <p> The document portion names each document containing
            the term.  Documents are indicated by number.  The frequency portion gives
            the number of times the term occurred in each document. </p> <p> The pairs are
            ordered by document number.</p>
            </summary>
            <seealso cref="!:IndexReader#TermDocs()">
            </seealso>	
        </member>
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.Term)">
            <summary>Sets this to the data for a term.
            The enumeration is reset to the start of the data for this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.TermEnum)">
            <summary>Sets this to the data for the current term in a {@link TermEnum}.
            This may be optimized in some implementations.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Doc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Freq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Read(System.Int32[],System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Index.TermDocs.Close">
            <summary>Frees associated resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.NextPosition" -->
        <member name="T:Lucene.Net.Analysis.StopFilter">
            <summary> Removes stop words from a token stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[])">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the array of words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the Hashtable.
            
            </summary>
            <deprecated> Use {@link #StopFilter(TokenStream, Set)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopTable(System.String[])">
            <summary> Builds a Hashtable from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this table construction to be cached once when
            an Analyzer is constructed.
            
            </summary>
            <deprecated> Use {@link #MakeStopSet(String[])} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[])">
            <summary> Builds a Set from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this stopWords construction to be cached once when
            an Analyzer is constructed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.Next">
            <summary> Returns the next input Token whose termText() is not a stop word.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.LowerCaseTokenizer" -->
        <member name="T:Lucene.Net.Analysis.LetterTokenizer">
            <summary>A LetterTokenizer is a tokenizer that divides text at non-letters.  That's
            to say, it defines tokens as maximal strings of adjacent letters, as defined
            by java.lang.Character.isLetter() predicate.
            Note: this does a decent job for most European languages, but does a terrible
            job for some Asian languages, where words are not separated by spaces. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LetterTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LowerCaseTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.Normalize(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.WildcardQuery">
            <summary>Implements the wildcard search query. Supported wildcards are <code>*</code>, which
            matches any character sequence (including the empty one), and <code>?</code>,
            which matches any single character. Note this query can be slow, as it
            needs to iterate over all terms. In order to prevent extremely slow WildcardQueries,
            a Wildcard term must not start with one of the wildcards <code>*</code> or
            <code>?</code>.
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.WildcardTermEnum">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary> Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary> Sorts by computed relevance. This is the same sort criteria as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String)">
            <summary> Sorts by the terms in <code>field</code> then by index order (document
            number). The type of value in <code>field</code> is determined
            automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String,System.Boolean)">
            <summary> Sorts possibly in reverse by the terms in <code>field</code> then by
            index order (document number). The type of value in <code>field</code> is
            determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String[])">
            <summary> Sorts in succession by the terms in each field. The type of value in
            <code>field</code> is determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String)">
            <summary> Sets the sort to the terms in <code>Field</code> then by index order
            (document number). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String,System.Boolean)">
            <summary> Sets the sort to the terms in <code>Field</code> possibly in reverse,
            then by index order (document number). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String[])">
            <summary>Sets the sort to the terms in each Field in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of SortField objects used in this sort criteria
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.RemoteSearchable">
            <summary>A remote searchable implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.#ctor(Lucene.Net.Search.Searchable)">
            <summary>Constructs and exports a remote searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.Main(System.String[])">
            <summary>Exports a searcher for the index in args[0] named
            "//localhost/Searchable". 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhraseQuery">
            <summary>A Query that matches documents containing a particular sequence of terms.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>Constructs an empty phrase query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.SetSlop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.GetSlop">
            <summary>Returns the slop.  See setSlop(). </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term within the phrase is specified explicitly.
            This allows e.g. phrases with more than one term at the same position
            or phrases with gaps (e.g. in connection with stopwords).
            
            </summary>
            <param name="">term
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Hashtable)">
            <seealso cref="!:Lucene.Net.search.Query#ExtractTerms(java.util.Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDocSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.#ctor(Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="fields">Field names, in priority order (highest priority first).
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.SetFields(Lucene.Net.Search.SortField[])">
            <summary> Allows redefinition of sort fields if they are <code>null</code>.
            This is to handle the case using ParallelMultiSearcher where the
            original list contains AUTO and we don't know the actual sort
            type until the values come back.  The fields can only be set once.
            This method is thread safe.
            </summary>
            <param name="">fields
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.GetFields">
            <summary>Returns the fields being used to sort. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.HasCollators(Lucene.Net.Search.SortField[])">
            <summary>Returns an array of collators, possibly <code>null</code>.  The collators
            correspond to any SortFields which were given a specific locale.
            </summary>
            <param name="fields">Array of sort fields.
            </param>
            <returns> Array, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.DefaultSimilarity">
            <summary>Expert: Default scoring implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.LengthNorm(System.String,System.Int32)">
            <summary>Implemented as <code>1/sqrt(numTerms)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Tf(System.Single)">
            <summary>Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Idf(System.Int32,System.Int32)">
            <summary>Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BooleanScorer2" -->
        <member name="F:Lucene.Net.Search.BooleanScorer2.countingSumScorer">
            <summary>The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.InitCountingSumScorer" -->
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer2(Lucene.Net.Search.Scorer,System.Collections.IList)">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses the arguments and prohibitedScorers.
            </summary>
            <param name="requiredCountingSumScorer">A required scorer already built.
            </param>
            <param name="optionalScorers">A list of optional scorers, possibly empty.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer3(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses the arguments and prohibitedScorers.
            </summary>
            <param name="requiredCountingSumScorer">A required scorer already built.
            </param>
            <param name="optionalCountingSumScorer">An optional scorer already built.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector,System.Int32)" -->
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>A Scorer for OR like queries, counterpart of Lucene's <code>ConjunctionScorer</code>.
            This Scorer implements {@link Scorer#SkipTo(int)} and uses SkipTo() on the given Scorers. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrScorers">
            <summary>The number of subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.subScorers">
            <summary>The subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.minimumNrMatchers">
            <summary>The minimum number of scorers that should match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.DisjunctionSumScorer.scorerQueue" -->
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.currentDoc">
            <summary>The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrMatchers">
            <summary>The number of subscorers that provide the current match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList,System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList)">
            <summary>Construct a <code>DisjunctionScorer</code>, using one as the minimum number
            of matching subscorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.InitScorerQueue">
            <summary>Called the first time Next() or SkipTo() is called to
            initialize <code>scorerQueue</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.AdvanceAfterCurrent" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.NrMatchers">
            <summary>Returns the number of subscorers matching the current document.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Explain(System.Int32)">
            <summary>Gives and explanation for the score of a given document.</summary>
            <todo>  Show the resulting score. See BooleanScorer.explain() on how to do this. </todo>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer.ScorerQueue">
            <summary>A <code>PriorityQueue</code> that orders by {@link Scorer#Doc()}. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>Count a scorer as a single match. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Precedence.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.Token.specialToken">
            <summary> This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermVector.GetField">
            <summary> </summary>
            <returns> The number of the Field this vector is associated with
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            
            </summary>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
            <seealso cref="!:Lucene.Net.analysis.Token">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetTermPositions(System.Int32)">
            <summary> Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexReader" -->
        <member name="M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory)">
            <summary> Constructor used if IndexReader is not owner of its directory. 
            This is used for IndexReaders that are used within other IndexReaders that take care or locking directories.
            
            </summary>
            <param name="directory">Directory where IndexReader files reside.
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary> Constructor used if IndexReader is owner of its directory.
            If IndexReader is owner of its directory, it locks its directory in case of write operations.
            
            </summary>
            <param name="directory">Directory where IndexReader files reside.
            </param>
            <param name="segmentInfos">Used for write-l
            </param>
            <param name="">closeDirectory
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.String)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.IO.FileInfo)">
            <summary>Returns an IndexReader reading the index in an FSDirectory in the named
            path. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>Returns an IndexReader reading the index in the given Directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Directory">
            <summary>Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.String)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(String)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.IO.FileInfo)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(File)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(Lucene.Net.Store.Directory)">
            <summary> Returns the time the index in the named directory was last modified. 
            
            <p>Synchronization of IndexReader and IndexWriter instances is 
            no longer done via time stamps of the segments file since the time resolution 
            depends on the hardware platform. Instead, a version number is maintained
            within the segments file, which is incremented everytime when the index is
            changed.</p>
            
            </summary>
            <deprecated>  Replaced by {@link #GetCurrentVersion(Directory)}
            
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.String)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.IO.FileInfo)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Reads version number from segments files. The version number counts the
            number of changes of the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  IOException if segments file cannot be read. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVectors(System.Int32)">
            <summary>  Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized field in the document.
            Each vector contains terms and frequencies for all terms in a given vectorized field.
            If no such fields existed, the method returns null. The term vectors that are
            returned my either be of type TermFreqVector or of type TermPositionsVector if
            positions or offsets have been stored.
            
            </summary>
            <param name="docNumber">document for which term frequency vectors are returned
            </param>
            <returns> array of term frequency vectors. May be null if no term vectors have been
            stored for the specified document.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="!:Lucene.Net.document.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>  Return a term frequency vector for the specified document and field. The
            returned vector contains terms and frequencies for the terms in
            the specified field of this document, if the field had the storeTermVector
            flag set. If termvectors had been stored with positions or offsets, a 
            TermPositionsVector is returned.
            
            </summary>
            <param name="docNumber">document for which the term frequency vector is returned
            </param>
            <param name="field">field for which the term frequency vector is returned.
            </param>
            <returns> term frequency vector May be null if field does not exist in the specified
            document or term vector was not stored.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="!:Lucene.Net.document.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.String)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            <code>false</code> is returned.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.IO.FileInfo)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>Returns the number of documents in this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>Returns one greater than the largest possible document number.
            This may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>Returns the stored fields of the <code>n</code><sup>th</sup>
            <code>Document</code> in this index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsDeleted(System.Int32)">
            <summary>Returns true if document <i>n</i> has been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>Returns true if any documents have been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            <summary>Returns the byte-encoded normalization factor for the named Field of
            every document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Field#SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Reads the byte-encoded normalization factor for the named Field of every
            document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Field#SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Byte)">
            <summary>Expert: Resets the normalization factor for the named Field of the named
            document.  The norm represents the product of the Field's {@link
            Field#SetBoost(float) boost} and its {@link Similarity#LengthNorm(String,
            int) length normalization}.  Thus, to preserve the length normalization
            values when resetting this, one should base the new value upon the old.
            
            </summary>
            <seealso cref="!:#Norms(String)">
            </seealso>
            <seealso cref="!:Similarity#DecodeNorm(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoSetNorm(System.Int32,System.String,System.Byte)">
            <summary>Implements setNorm in subclass.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Single)">
            <summary>Expert: Resets the normalization factor for the named Field of the named
            document.
            
            </summary>
            <seealso cref="!:#Norms(String)">
            </seealso>
            <seealso cref="!:Similarity#DecodeNorm(byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms">
            <summary>Returns an enumeration of all the terms in the index.
            The enumeration is ordered by Term.compareTo().  Each term
            is greater than all that precede it in the enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of all terms after a given term.
            The enumeration is ordered by Term.compareTo().  Each term
            is greater than all that precede it in the enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>Returns the number of documents containing the term <code>t</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermDocs(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermDocs">
            <summary>Returns an unpositioned {@link TermDocs} enumerator. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermPositions(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermPositions">
            <summary>Returns an unpositioned {@link TermPositions} enumerator. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AquireWriteLock">
            <summary> Tries to acquire the WriteLock on this directory.
            this method is only valid if this IndexReader is directory owner.
            
            </summary>
            <throws>  IOException If WriteLock cannot be acquired. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Delete(System.Int32)">
            <summary>Deletes the document numbered <code>docNum</code>.  Once a document is
            deleted it will not appear in TermDocs or TermPostitions enumerations.
            Attempts to read its Field with the {@link #document}
            method will result in an error.  The presence of this document may still be
            reflected in the {@link #docFreq} statistic, though
            this will be corrected eventually as the index is further modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoDelete(System.Int32)">
            <summary>Implements deletion of the document numbered <code>docNum</code>.
            Applications should call {@link #Delete(int)} or {@link #Delete(Term)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Delete(Lucene.Net.Index.Term)">
            <summary>Deletes all documents containing <code>term</code>.
            This is useful if one uses a document Field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate Field and the unique ID string as its text and
            passes it to this method.  Returns the number of documents deleted.
            See {@link #Delete(int)} for information about when this deletion will 
            become effective.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.UndeleteAll">
            <summary>Undeletes all documents currently marked as deleted in this index.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoUndeleteAll">
            <summary>Implements actual undeleteAll() in subclass. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Commit">
            <summary> Commit changes resulting from delete, undeleteAll, or setNorm operations
            
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoCommit">
            <summary>Implements commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Close">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>Implements close. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames">
            <summary> Returns a list of all unique field names that exist in the index pointed
            to by this IndexReader.
            </summary>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
            <summary> 
            </summary>
            <deprecated>  Replaced by {@link #GetFieldNames(IndexReader.FieldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames(System.Boolean)">
            <summary> Returns a list of all unique Field names that exist in the index pointed
            to by this IndexReader.  The boolean argument specifies whether the fields
            returned are indexed or not.
            </summary>
            <param name="indexed"><code>true</code> if only indexed fields should be returned;
            <code>false</code> if only unindexed fields should be returned.
            </param>
            <returns> Collection of Strings indicating the names of the fields
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
            <summary> 
            </summary>
            <deprecated>  Replaced by {@link #GetFieldNames(IndexReader.FieldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetIndexedFieldNames(System.Boolean)">
            <summary> </summary>
            <param name="storedTermVector">if true, returns only Indexed fields that have term vector info, 
            else only indexed fields without term vector info 
            </param>
            <returns> Collection of Strings indicating the names of the fields
            
            </returns>
            <deprecated>  Replaced by {@link #GetFieldNames(IndexReader.FieldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetIndexedFieldNames(Lucene.Net.Documents.Field.TermVector)">
            <summary> Get a list of unique field names that exist in this index, are indexed, and have
            the specified term vector information.
            
            </summary>
            <param name="tvSpec">specifies which term vector information should be available for the fields
            </param>
            <returns> Collection of Strings indicating the names of the fields
            
            </returns>
            <deprecated>  Replaced by {@link #GetFieldNames(IndexReader.FieldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <summary> Get a list of unique field names that exist in this index and have the specified
            field option information.
            </summary>
            <param name="fldOption">specifies which field option should be available for the returned fields
            </param>
            <returns> Collection of Strings indicating the names of the fields.
            </returns>
            <seealso cref="T:Lucene.Net.Index.IndexReader.FieldOption">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(System.String)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Unlock(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.IndexReader.Main(System.String[])">
            <summary> Prints the filename and size of each file within a given compound file.
            Add the -extract flag to extract files to the current working directory.
            In order to make the extracted version of the index work, you have to copy
            the segments file from the compound index into the directory where the extracted files are stored.
            </summary>
            <param name="">args
            </param>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this Field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this Field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.Token.specialToken">
            <summary> This Field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this Field is set to null.
            When there are more than one such special token, this Field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken Field, and so on
            until the first special token (whose specialToken Field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this Field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.Token.NewToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            case MyParserConstants.ID : return new IDToken();
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortField" -->
        <member name="F:Lucene.Net.Search.SortField.SCORE">
            <summary>Sort by document score (relevancy).  Sort values are Float and higher
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOC">
            <summary>Sort by document number (index order).  Sort values are Integer and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.AUTO">
            <summary>Guess type of sort based on Field contents.  A regular expression is used
            to look at the first term indexed for the Field and determine if it
            represents an integer number, a floating point number, or just arbitrary
            string characters. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING">
            <summary>Sort using term values as Strings.  Sort values are String and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.INT">
            <summary>Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FLOAT">
            <summary>Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.CUSTOM">
            <summary>Sort using a custom Comparator.  Sort values are any Comparable and
            sorting is done according to natural order. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>Represents sorting by document score (relevancy). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String)">
            <summary>Creates a sort by terms in the given Field where the type of term value
            is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="Field">Name of Field to sort by, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field where
            the type of term value is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="Field">Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32)">
            <summary>Creates a sort by terms in the given Field with the type of term
            values explicitly given.
            </summary>
            <param name="Field"> Name of Field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field with the
            type of term values explicitly given.
            </summary>
            <param name="Field"> Name of Field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>Creates a sort by terms in the given Field sorted
            according to the given locale.
            </summary>
            <param name="Field"> Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the Field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given Field sorted
            according to the given locale.
            </summary>
            <param name="Field"> Name of Field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the Field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource)">
            <summary>Creates a sort with a custom comparison function.</summary>
            <param name="Field">Name of Field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, with a custom comparison function.</summary>
            <param name="Field">Name of Field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetField">
            <summary>Returns the name of the Field.  Could return <code>null</code>
            if the sort is by SCORE or DOC.
            </summary>
            <returns> Name of Field, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetType">
            <summary>Returns the type of contents in the Field.</summary>
            <returns> One of the constants SCORE, DOC, AUTO, STRING, INT or FLOAT.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetLocale">
            <summary>Returns the Locale by which term values are interpreted.
            May return <code>null</code> if no Locale was specified.
            </summary>
            <returns> Locale, or <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetReverse">
            <summary>Returns whether the sort should be reversed.</summary>
            <returns>  True if natural order should be reversed.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetValue">
            <summary>The value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetValue(System.Single)">
            <summary>Sets the value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDescription">
            <summary>A description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetDescription(System.String)">
            <summary>Sets the description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>Render an explanation as HTML. </summary>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary> Wraps another filters result and caches it.  The caching
            behavior is like {@link QueryFilter}.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add
            caching, keeping the two concerns decoupled yet composable.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.cache">
            <todo>  What about serialization in RemoteSearchable?  Caching won't work. </todo>
            <summary>       Should transient be removed?
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipProx(System.Int64)">
            <summary>Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
            <summary>An IndexWriter creates and maintains an index.
            The third argument to the 
            <a href="#IndexWriter(Lucene.Net.store.Directory, Lucene.Net.analysis.Analyzer, boolean)"><b>constructor</b></a>
            determines whether a new index is created, or whether an existing index is
            opened for the addition of new documents.
            In either case, documents are added with the <a
            href="#addDocument(Lucene.Net.document.Document)"><b>addDocument</b></a> method.  
            When finished adding documents, <a href="#close()"><b>close</b></a> should be called.
            If an index will not have more documents added for a while and optimal search
            performance is desired, then the <a href="#optimize()"><b>optimize</b></a>
            method should be called before the index is closed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT">
            <summary> Default value is 1000.  Use <code>Lucene.Net.writeLockTimeout</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.COMMIT_LOCK_TIMEOUT">
            <summary> Default value is 10000.  Use <code>Lucene.Net.commitLockTimeout</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MERGE_FACTOR">
            <summary> Default value is 10.  Use <code>Lucene.Net.mergeFactor</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MIN_MERGE_DOCS">
            <summary> Default value is 10.  Use <code>Lucene.Net.minMergeDocs</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_MERGE_DOCS">
            <summary> Default value is {@link Integer#MAX_VALUE}.
            Use <code>Lucene.Net.maxMergeDocs</code> system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH">
            <summary> Default value is 10000.  Use <code>Lucene.Net.maxFieldLength</code>
            system property to override.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL">
            <summary>The default value for {@link #GetTermIndexInterval()}.  This is
            determined by the <code>Lucene.Net.termIndexInterval</code> system
            property.  The default is 128.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.useCompoundFile">
            <summary>Use compound file setting. Defaults to true, minimizing the number of
            files used.  Setting this to false may improve indexing performance, but
            may also cause file handle problems.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetUseCompoundFile">
            <summary>Get the current setting of whether to use the compound file format.
            Note that this just returns the value you set with setUseCompoundFile(boolean)
            or the default. You cannot use this to query the status of an existing index.
            </summary>
            <seealso cref="!:#SetUseCompoundFile(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetUseCompoundFile(System.Boolean)">
            <summary>Setting to turn on usage of a compound file. When on, multiple files
            for each segment are merged into a single file once the segment creation
            is finished. This is done regardless of what directory is in use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this IndexWriter.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.GetSimilarity" -->
        <member name="M:Lucene.Net.Index.IndexWriter.SetTermIndexInterval(System.Int32)">
            <summary>Expert: Set the interval between indexed terms.  Large values cause less
            memory to be used by IndexReader, but slow random-access to terms.  Small
            values cause more memory to be used by an IndexReader, and speed
            random-access to terms.
            
            This parameter determines the amount of computation required per query
            term, regardless of the number of documents that contain that term.  In
            particular, it is the maximum number of other terms that must be
            scanned before a term is located and its frequency and position information
            may be processed.  In a large index with user-entered query terms, query
            processing time is likely to be dominated not by term lookup but rather
            by the processing of frequency and positional data.  In a small index
            or when many uncommon query terms are generated (e.g., by wildcard
            queries) term lookup may become a dominant cost.
            
            In particular, <code>numUniqueTerms/interval</code> terms are read into
            memory by an IndexReader, and, on average, <code>interval/2</code> terms
            must be scanned for each random term access.
            
            </summary>
            <seealso cref="!:#DEFAULT_TERM_INDEX_INTERVAL">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetTermIndexInterval">
            <summary>Expert: Return the interval between indexed terms.
            
            </summary>
            <seealso cref="!:#SetTermIndexInterval(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            
            </summary>
            <param name="path">the path to the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Constructs an IndexWriter for the index in <code>d</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            
            </summary>
            <param name="d">the index directory
            </param>
            <param name="a">the analyzer to use
            </param>
            <param name="create"><code>true</code> to create the index or overwrite
            the existing one; <code>false</code> to append to the existing
            index
            </param>
            <throws>  IOException if the directory cannot be read/written to, or </throws>
            <summary>  if it does not exist, and <code>create</code> is
            <code>false</code>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.SetMaxMergeDocs(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxMergeDocs">
            <seealso cref="!:#setMaxMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxFieldLength(System.Int32)">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxFieldLength">
            <seealso cref="!:#setMaxFieldLength">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxBufferedDocs">
            <seealso cref="!:#setMaxBufferedDocs">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergeFactor">
            <seealso cref="!:#setMergeFactor">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetInfoStream(System.IO.TextWriter)">
            <summary>If non-null, information about merges and a message when
            maxFieldLength is reached will be printed to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetInfoStream">
            <seealso cref="!:#setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Close">
            <summary>Flushes all changes to an index and closes all associated files. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDirectory">
            <summary>Returns the Directory used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetAnalyzer">
            <summary>Returns the analyzer used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DocCount">
            <summary>Returns the number of documents currently in this index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.maxFieldLength">
            <summary> The maximum number of terms that will be indexed for a single Field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a Field.
            
            </summary>
            <deprecated> use {@link #setMaxFieldLength} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)">
            <summary> Adds a document to this index.  If the document contains more than
            {@link #maxFieldLength} terms for a given Field, the remainder are
            discarded.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            value of {@link #GetAnalyzer()}.  If the document contains more than
            {@link #maxFieldLength} terms for a given Field, the remainder are
            discarded.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.mergeFactor" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.minMergeDocs" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriter.maxMergeDocs" -->
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>If non-null, information about merges will be printed to this. </summary>
            <deprecated> use {@link #setInfoStream} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize">
            <summary>Merges all segments together into a single segment, optimizing an index
            for search. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>Merges the provided indexes into this index.
            <p>After this completes, the index is optimized. </p>
            <p>The provided IndexReaders are not closed.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.FlushRamSegments">
            <summary>Merges all RAM-resident segments. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMergeSegments">
            <summary>Incremental segment merger.  </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeSegments(System.Int32)">
            <summary>Pops segments off of segmentInfos stack down to minSegment, merges them,
            and pushes the merged index onto the top of the segmentInfos stack. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Similarity,System.Int32)">
            <summary>This ctor used by test code only.
            
            </summary>
            <param name="directory">The directory to write the document information to
            </param>
            <param name="analyzer">The analyzer to use for the document
            </param>
            <param name="similarity">The Similarity function
            </param>
            <param name="maxFieldLength">The maximum number of tokens a field may have
            </param>
        </member>
        <member name="M:Lucene.Net.Index.DocumentWriter.SetInfoStream(System.IO.TextWriter)">
            <summary>If non-null, a message will be printed to this if maxFieldLength is reached.</summary>
        </member>
        <member name="T:Lucene.Net.Analysis.SimpleAnalyzer">
            <summary>An Analyzer that filters LetterTokenizer with LowerCaseFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.DE.WordlistLoader">
            <summary> Loader for text files that represent a list of stopwords.
            
            </summary>
            <deprecated> Use {@link Lucene.Net.analysis.WordlistLoader} instead
            
            </deprecated>
            <author>  Gerhard Schwarz
            </author>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordSet(System.IO.FileInfo)">
            <summary> Loads a text file and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the file should contain only 
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like GermanAnalyzer).
            
            </summary>
            <param name="wordfile">File containing the wordlist
            </param>
            <returns> A HashSet with the file's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.String,System.String)">
            <param name="path">     Path to the wordlist
            </param>
            <param name="wordfile"> Name of the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.String)">
            <param name="wordfile"> Complete path to the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.GetWordtable(System.IO.FileInfo)">
            <param name="wordfile"> File object that points to the wordlist
            
            </param>
            <deprecated> Use {@link #GetWordSet(File)} getWordSet(File)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.DE.WordlistLoader.MakeWordTable(System.Collections.Hashtable)">
            <summary> Builds a wordlist table, using words as both keys and values
            for backward compatibility.
            
            </summary>
            <param name="wordSet">  stopword set
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoreDocComparator_Fields" -->
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.RELEVANCE">
            <summary>Special comparator for sorting hits according to computed relevance (document score). </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.INDEXORDER">
            <summary>Special comparator for sorting hits according to index order (document number). </summary>
        </member>
        <member name="T:Lucene.Net.Search.Hits">
            <summary>A ranked list of documents, used to hold search results. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.GetMoreDocs(System.Int32)">
            <summary> Tries to add new documents to hitDocs.
            Ensures that the hit numbered <code>min</code> has been retrieved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Length">
            <summary>Returns the total number of hits available in this set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Hits.Doc(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            <summary>Returns the score for the nth document in this set. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Id(System.Int32)">
            <summary>Returns the id for the nth document in this set. </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Precedence.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.TokenMgrError.AddEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.Precedence.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="T:Lucene.Net.LucenePackage">
            <summary>
            Lucene's package information, including version. *
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermEnum" -->
        <member name="M:Lucene.Net.Index.TermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Term">
            <summary>Returns the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.DocFreq">
            <summary>Returns the docFreq of the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermEnum.SkipTo(Lucene.Net.Index.Term)" -->
        <member name="T:Lucene.Net.Documents.Field">
            <summary>A field is a section of a Document.  Each field has two parts, a name and a
            value.  Values may be free text, provided as a String or as a Reader, or they
            may be atomic keywords, which are not further processed.  Such keywords may
            be used to represent dates, urls, etc.  Fields are optionally stored in the
            index, so that they may be returned with hits on the document.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Field.Keyword(System.String,System.String)">
            <summary>Constructs a String-valued Field that is not tokenized, but is indexed
            and stored.  Useful for non-text fields, e.g. date or url.  
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)
            Field(name, value, Field.Store.YES, Field.Index.UN_TOKENIZED)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnIndexed(System.String,System.String)">
            <summary>Constructs a String-valued Field that is not tokenized nor indexed,
            but is stored in the index, for return with hits.
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)
            Field(name, value, Field.Store.YES, Field.Index.NO)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.String)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            and is stored in the index, for return with hits.  Useful for short text
            fields, like "title" or "subject". Term vector will not be stored for this field.
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)
            Field(name, value, Field.Store.YES, Field.Index.TOKENIZED)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Keyword(System.String,System.DateTime)">
            <summary>Constructs a Date-valued Field that is not tokenized and is indexed,
            and stored in the index, for return with hits.
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)
            Field(name, value, Field.Store.YES, Field.Index.UN_TOKENIZED)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.String,System.Boolean)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            and is stored in the index, for return with hits.  Useful for short text
            fields, like "title" or "subject".
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index, Field.TermVector)
            Field(name, value, Field.Store.YES, Field.Index.TOKENIZED, storeTermVector)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnStored(System.String,System.String)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            but that is not stored in the index.  Term vector will not be stored for this field.
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)
            Field(name, value, Field.Store.NO, Field.Index.TOKENIZED)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.UnStored(System.String,System.String,System.Boolean)">
            <summary>Constructs a String-valued Field that is tokenized and indexed,
            but that is not stored in the index.
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index, Field.TermVector)
            Field(name, value, Field.Store.NO, Field.Index.TOKENIZED, storeTermVector)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.IO.TextReader)">
            <summary>Constructs a Reader-valued Field that is tokenized and indexed, but is
            not stored in the index verbatim.  Useful for longer text fields, like
            "body". Term vector will not be stored for this field.
            </summary>
            <deprecated> use {@link #Field(String, Reader) Field(name, value)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Text(System.String,System.IO.TextReader,System.Boolean)">
            <summary>Constructs a Reader-valued Field that is tokenized and indexed, but is
            not stored in the index verbatim.  Useful for longer text fields, like
            "body".
            </summary>
            <deprecated> use {@link #Field(String, Reader, Field.TermVector)
            Field(name, value, storeTermVector)} instead 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Name">
            <summary>Returns the name of the field as an interned string.
            For example "date", "title", "body", ...
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value
            or binary value is used.  Exactly one of stringValue(), readerValue(), and
            binaryValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value
            or binary value is  used.  Exactly one of stringValue(), readerValue(),
            and binaryValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader or
            String value is used.  Exactly one of stringValue(), readerValue() and
            binaryValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index. Term vectors will not be stored in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException if the field is neither stored nor indexed  </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException in any of the following situations: </throws>
            <summary> <ul> 
            <li>the field is neither stored nor indexed</li> 
            <li>the field is not indexed but termVector is <code>TermVector.YES</code></li>
            </ul> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader)">
            <summary> Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create a field by specifying all parameters except for <code>storeTermVector</code>,
            which is set to <code>false</code>.
            
            </summary>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.Field.Store)">
            <summary> Create a stored field with binary value. Optionally the value may be compressed.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The binary value
            </param>
            <param name="store">How <code>value</code> should be stored (compressed or not.)
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary> </summary>
            <param name="name">The name of the field
            </param>
            <param name="string">The string to process
            </param>
            <param name="store">true if the field should store the string
            </param>
            <param name="index">true if the field should be indexed
            </param>
            <param name="token">true if the field should be tokenized
            </param>
            <param name="storeTermVector">true if we should store the Term Vector info
            
            </param>
            <deprecated> use {@link #Field(String, String, Field.Store, Field.Index, Field.TermVector)} instead
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsStored">
            <summary>True iff the value of the field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsIndexed">
            <summary>True iff the value of the field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsTokenized">
            <summary>True iff the value of the field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsCompressed">
            <summary>True if the value of the field is stored and compressed within the index </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsTermVectorStored">
            <summary>True iff the term or terms used to index this field are stored as a term
            vector, available from {@link IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="!:String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsStoreOffsetWithTermVector">
            <summary> True iff terms are stored as term vector together with their offsets 
            (start and end positon in source text).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsStorePositionWithTermVector">
            <summary> True iff terms are stored as term vector together with their token positions.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.IsBinary">
            <summary>True iff the value of the filed is stored as binary </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ToString">
            <summary>Prints a Field for human consumption. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.COMPRESS">
            <summary>Store the original field value in the index in a compressed form. This is
            useful for long documents and for binary valued fields.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>Store the original field value in the index. This is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>Do not store the field value in the index. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is 
            {@link Field.Store stored}. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.TOKENIZED">
            <summary>Index the field's value so it can be searched. An Analyzer will be used
            to tokenize and possibly further normalize the text before its
            terms will be stored in the index. This is useful for common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.UN_TOKENIZED">
            <summary>Index the field's value without using an Analyzer, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is 
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>Do not store term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurences in that document. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
            <summary> Store the term vector + token position information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
            <summary> Store the term vector + Token offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
            <summary> Store the term vector + Token position and offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
            <seealso cref="!:#WITH_POSITIONS">
            </seealso>
            <seealso cref="!:#WITH_OFFSETS">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
            <summary> A memory-resident {@link Directory} implementation.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>Constructs an empty {@link Directory}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.IO.FileInfo)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>File</code> specifying the index directory
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.String)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>String</code> specifying the full index directory path
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.RenameFile(System.String,System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(System.String)">
            <summary>Creates a searcher searching the index in the named directory. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Store.Directory)">
            <summary>Creates a searcher searching the index in the provided directory. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.GetIndexReader">
            <summary>Return the {@link IndexReader} this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Close">
            <summary> Note that the underlying IndexReader is not closed, if
            IndexSearcher was constructed with IndexSearcher(IndexReader r).
            If the IndexReader was supplied implicitly by specifying a directory, then
            the IndexReader gets closed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredTermEnum" -->
        <member name="M:Lucene.Net.Search.FilteredTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary>Equality compare on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Difference">
            <summary>Equality measure on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.EndEnum">
            <summary>Indiciates the end of the enumeration has been reached </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.DocFreq">
            <summary> Returns the docFreq of the current Term in the enumeration.
            Returns -1 if no Term matches or all terms have been enumerated.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Returns null if no Term matches or all terms have been enumerated. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources.  </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheImpl" -->
        <member name="F:Lucene.Net.Search.FieldCacheImpl.cache">
            <summary>The internal cache. Maps Entry to array of interpreted term values. *</summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Int32)">
            <summary>See if an object is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Object)">
            <summary>See if a custom object is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Store(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object)">
            <summary>Put an object into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Store(Lucene.Net.Index.IndexReader,System.String,System.Object,System.Object)">
            <summary>Put a custom object into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>The pattern used to detect float values in a Field </summary>
            <summary> removed for java 1.3 compatibility
            protected static final Object pFloats = Pattern.compile ("[0-9+\\-\\.eEfFdD]+");
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Entry">
            <summary>Expert: Every key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Int32)">
            <summary>Creates one of these objects. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Object)">
            <summary>Creates one of these objects for a custom comparator. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.Equals(System.Object)">
            <summary>Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.GetHashCode">
            <summary>Composes a hashcode based on the field and type. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>The query whose matching documents are combined by the boolean query.</summary>
            <deprecated> use {@link #SetQuery(Query)} instead 
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.required">
            <summary>If true, documents documents which <i>do not</i>
            match this sub-query will <i>not</i> match the boolean query. 
            </summary>
            <deprecated> use {@link #SetOccur(BooleanClause.Occur)} instead 
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.prohibited">
            <summary>If true, documents documents which <i>do</i>
            match this sub-query will <i>not</i> match the boolean query. 
            </summary>
            <deprecated> use {@link #SetOccur(BooleanClause.Occur)} instead 
            </deprecated>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Constructs a BooleanClause.</summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST">
            <summary>Use this operator for terms that <i>must</i> appear in the matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.SHOULD">
            <summary>Use this operator for terms of which <i>should</i> appear in the 
            matching documents. For a BooleanQuery with two <code>SHOULD</code> 
            subqueries, at least one of the queries must appear in the matching documents. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST_NOT">
            <summary>Use this operator for terms that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <code>MUST_NOT</code> query. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader">
            <summary>A <code>FilterIndexReader</code> contains another IndexReader, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <code>FilterIndexReader</code> itself simply implements all abstract methods
            of <code>IndexReader</code> with versions that pass all requests to the
            contained index reader. Subclasses of <code>FilterIndexReader</code> may
            further override some of these methods and may also provide additional
            methods and fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterIndexReader.#ctor(Lucene.Net.Index.IndexReader)">
            <summary> <p>Construct a FilterIndexReader based on the specified base reader.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the base reader.</p>
            <p>Note that base reader is closed if this FilterIndexReader is closed.</p>
            </summary>
            <param name="in">specified base reader.
            </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermDocs">
            <summary>Base class for filtering {@link TermDocs} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermPositions">
            <summary>Base class for filtering {@link TermPositions} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermEnum">
            <summary>Base class for filtering {@link TermEnum} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader">
            <summary> Class responsible for access to stored document fields.
            
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="T:Lucene.Net.Analysis.PorterStemmer">
            <summary> 
            Stemmer, implementing the Porter Stemming Algorithm
            
            The Stemmer class transforms a word into its root form.  The input
            word can be provided a character at time (by calling add()), or at once
            by calling one of the various stem(something) methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Reset">
            <summary> reset() resets the stemmer so it can stem another word.  If you invoke
            the stemmer by calling add(char) and then stem(), you must call reset()
            before starting another word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Add(System.Char)">
            <summary> Add a character to the word being stemmed.  When you are finished
            adding characters, you can call stem(void) to process the word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.ToString">
            <summary> After a word has been stemmed, it can be retrieved by toString(),
            or a reference to the internal buffer can be retrieved by getResultBuffer
            and getResultLength (which is generally more efficient.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultLength">
            <summary> Returns the length of the word resulting from the stemming process.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultBuffer">
            <summary> Returns a reference to a character buffer containing the results of
            the stemming process.  You also need to consult getResultLength()
            to determine the length of the result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.String)">
            <summary> Stem a word provided as a String.  Returns the result as a String.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[])">
            <summary>Stem a word contained in a char[].  Returns true if the stemming process
            resulted in a word different from the input.  You can retrieve the
            result with getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32,System.Int32)">
            <summary>Stem a word contained in a portion of a char[] array.  Returns
            true if the stemming process resulted in a word different from
            the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32)">
            <summary>Stem a word contained in a leading portion of a char[] array.
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem">
            <summary>Stem the word placed into the Stemmer buffer through calls to add().
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Main(System.String[])">
            <summary>Test program for demonstrating the Stemmer.  It reads a file and
            stems each word, writing the result to standard out.
            Usage: Stemmer file-name
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
            <summary> Methods for manipulating strings.
            
            $Id$
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StringDifference(System.String,System.String)">
            <summary> Compares two strings, character by character, and returns the
            first position where the two strings differ from one another.
            
            </summary>
            <param name="s1">The first string to compare
            </param>
            <param name="s2">The second string to compare
            </param>
            <returns> The first position where the two strings differ.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.RangeQuery">
            <summary> A Query that matches documents within an exclusive range.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.Term,System.Boolean)">
            <summary>Constructs a query selecting all terms greater than
            <code>lowerTerm</code> but less than <code>upperTerm</code>.
            There must be at least one term and either term may be null,
            in which case there is no bound on that side, but if there are
            two terms, both terms <b>must</b> be for the same Field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetField">
            <summary>Returns the Field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetLowerTerm">
            <summary>Returns the lower term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetUpperTerm">
            <summary>Returns the upper term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.IsInclusive">
            <summary>Returns <code>true</code> if the range query is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryTermVector">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryTermVector.#ctor(System.String[])">
            <summary> </summary>
            <param name="queryTerms">The original list of terms from the query, can contain duplicates
            </param>
        </member>
        <member name="T:Lucene.Net.Search.PrefixQuery">
            <summary>A Query that matches documents containing terms with a specified prefix. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetPrefix">
            <summary>Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePrefixQuery">
            <summary> PhrasePrefixQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that has "app" as
            prefix using IndexReader.terms(Term), and use PhrasePrefixQuery.add(Term[]
            terms) to add them to the query.
            
            </summary>
            <deprecated> use {@link Lucene.Net.search.MultiPhraseQuery} instead
            </deprecated>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.SetSlop(System.Int32)">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#SetSlop(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.GetSlop">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#GetSlop()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term)">
            <summary>Add a single term at the next position in the phrase.</summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term[])">
            <summary>Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            
            </summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary> Allows to specify the relative position of terms within the phrase.
            
            </summary>
            <seealso cref="!:int)">
            </seealso>
            <param name="">terms
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.FastCharStream" -->
        <member name="M:Lucene.Net.QueryParsers.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.TermDocs,Lucene.Net.Search.Similarity,System.Byte[])" -->
        <member name="M:Lucene.Net.Search.TermScorer.Doc">
            <summary>Returns the current document number matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Explain(System.Int32)" -->
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>Removes matches which overlap with another SpanQuery. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetInclude">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetExclude">
            <summary>Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryFilter" -->
        <member name="M:Lucene.Net.Search.QueryFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermInfo">
            <summary>A TermInfo is the record of information stored for a term.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfo.docFreq">
            <summary>The number of documents which contain the term. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary> A memory-resident {@link OutputStream} implementation.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>Base implementation class for buffered {@link IndexOutput}. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="!:IndexInput#ReadByte()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="!:IndexInput#ReadBytes(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="!:#Seek(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="!:#GetFilePointer()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.IndexOutput)">
            <summary>Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>Resets this to an empty buffer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardTermEnum" -->
        <member name="F:Lucene.Net.Search.WildcardTermEnum.WILDCARD_STRING">
            <summary>*****************************************
            String equality with support for wildcards
            ******************************************
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.WildcardTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Search.WildcardTermEnum.WildcardEquals(System.String,System.Int32,System.String,System.Int32)">
            <summary> Determines if a word matches a wildcard pattern.
            <small>Work released by Granta Design Ltd after originally being done on
            company time.</small>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DateFilter">
            <summary> A Filter that restricts search results to a range of time.
            
            <p>For this to work, documents must have been indexed with a
            {@link DateField}.</p>
            
            </summary>
            <deprecated> Instead, use {@link RangeFilter} combined with 
            {@link Lucene.Net.document.DateTools}.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.#ctor(System.String,System.DateTime,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching dates
            between <code>from</code> and <code>to</code> inclusively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.#ctor(System.String,System.Int64,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching times
            between <code>from</code> and <code>to</code> inclusively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Before(System.String,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching
            dates on or before before <code>date</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Before(System.String,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching times
            on or before <code>time</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.After(System.String,System.DateTime)">
            <summary> Constructs a filter for Field <code>f</code> matching
            dates on or after <code>date</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.After(System.String,System.Int64)">
            <summary> Constructs a filter for Field <code>f</code> matching
            times on or after <code>time</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DateFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Returns a BitSet with true for documents which should be
            permitted in search results, and false for those that should
            not.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>A Query that matches documents matching boolean combinations of other
            queries, typically {@link TermQuery}s or {@link PhraseQuery}s.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.BooleanQuery.maxClauseCount" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMaxClauseCount">
            <summary>Return the maximum number of clauses permitted, 1024 by default.
            Attempts to add more than the permitted number of clauses cause {@link
            TooManyClauses} to be thrown.
            </summary>
            <seealso cref="!:#maxClauseCount">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetMaxClauseCount(System.Int32)">
            <summary>Set the maximum number of clauses permitted. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
            <summary>Constructs an empty boolean query.
            
            {@link Similarity#Coord(int,int)} may be disabled in scoring, as
            appropriate. For example, this score factor does not make sense for most
            automatically generated queries, like {@link WildcardQuery} and {@link
            FuzzyQuery}.
            
            </summary>
            <param name="disableCoord">disables {@link Similarity#Coord(int,int)} in scoring.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.IsCoordDisabled">
            <summary>Returns true iff {@link Similarity#Coord(int,int)} is disabled in
            scoring for this query instance.
            </summary>
            <seealso cref="!:#BooleanQuery(boolean)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Adds a clause to a boolean query.
            
            </summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)">
            <summary>Adds a clause to a boolean query.</summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>Returns the set of clauses in this query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.useScorer14">
            <summary>Indicates whether to use good old 1.4 BooleanScorer. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClauses">
            <summary>Thrown when an attempt is made to add more than {@link
            #GetMaxClauseCount()} clauses. This typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or RangeQuery 
            is expanded to many terms during search. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.BooleanWeight.Scorer(Lucene.Net.Index.IndexReader)">
            <returns> A good old 1.4 Scorer 
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.BooleanWeight2.Scorer(Lucene.Net.Index.IndexReader)">
            <returns> An alternative Scorer that uses and provides skipTo(),
            and scores documents in document number order.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader">
            <summary> FIXME: Describe class <code>SegmentReader</code> here.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReader.IMPL">
            <summary>The class which implements SegmentReader. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames">
            <seealso cref="!:IndexReader#GetFieldNames()">
            </seealso>
            <deprecated>  Replaced by {@link #GetFieldNames (IndexReader.FieldOption fldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames(System.Boolean)">
            <seealso cref="!:IndexReader#GetFieldNames(boolean)">
            </seealso>
            <deprecated>  Replaced by {@link #GetFieldNames (IndexReader.FieldOption fldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetIndexedFieldNames(Lucene.Net.Documents.Field.TermVector)">
            <seealso cref="!:tvSpec)">
            </seealso>
            <deprecated>  Replaced by {@link #GetFieldNames (IndexReader.FieldOption fldOption)}
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <seealso cref="!:fldOption)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norms(System.String)">
            <seealso cref="!:fldOption)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Read norms into a pre-allocated array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermVectorsReader">
            <summary> Create a clone from the initial TermVectorsReader and store it in the ThreadLocal.</summary>
            <returns> TermVectorsReader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>Return a term frequency vector for the specified document and Field. The
            vector returned contains term numbers and frequencies for all terms in
            the specified Field of this document, if the Field had storeTermVector
            flag set.  If the flag was not set, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized Field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized Field.
            If no such fields existed, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.MultipleTermPositions">
            <summary> Describe class <code>MultipleTermPositions</code> here.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term[])">
            <summary> Creates a new <code>MultipleTermPositions</code> instance.
            
            </summary>
            <param name="indexReader">an <code>IndexReader</code> value
            </param>
            <param name="terms">a <code>Term[]</code> value
            </param>
            <exception cref="!:"> IOException if an error occurs
            </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.Term)">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.TermEnum)">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Read(System.Int32[],System.Int32[])">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CompoundFileWriter" -->
        <member name="M:Lucene.Net.Index.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <throws>  NullPointerException if <code>dir</code> or <code>name</code> is null </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetDirectory">
            <summary>Returns the directory of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetName">
            <summary>Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.AddFile(System.String)">
            <summary>Add a source stream. <code>file</code> is the string by which the 
            sub-stream will be known in the compound stream.
            
            </summary>
            <throws>  IllegalStateException if this writer is closed </throws>
            <throws>  NullPointerException if <code>file</code> is null </throws>
            <throws>  IllegalArgumentException if a file with the same name </throws>
            <summary>   has been added already
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.Close">
            <summary>Merge files with the extensions added up to now.
            All files with these extensions are combined sequentially into the
            compound stream. After successful merge, the source files
            are deleted.
            </summary>
            <throws>  IllegalStateException if close() had been called before or </throws>
            <summary>   if no file has been added to this object
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.CopyFile(Lucene.Net.Index.CompoundFileWriter.FileEntry,Lucene.Net.Store.IndexOutput,System.Byte[])">
            <summary>Copy the contents of the file with specified extension into the
            provided output stream. Use the provided buffer for moving data
            to reduce memory allocation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.file">
            <summary>source file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.directoryOffset">
            <summary>temporary holder for the start of directory entry for this file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.dataOffset">
            <summary>temporary holder for the start of this file's data section </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader">
            <summary> Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            
            </summary>
            <author>  Dmitry Serebrennikov
            </author>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.DeleteFile(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.RenameFile(System.String,System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileLength(System.String)">
            <summary>Returns the length of a file in the directory.</summary>
            <throws>  IOException if the file does not exist  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CreateOutput(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.MakeLock(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader.CSIndexInput">
            <summary>Implementation of an IndexInput that reads from a portion of the
            compound file. The visibility is left as "package" *only* because
            this helps with testing since JUnit test cases in a different class
            can then access package fields of this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current
            position in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where
            the next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="!:#ReadInternal(byte[],int,int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.Close">
            <summary>Closes the stream to further operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.NumberTools" -->
        <member name="F:Lucene.Net.Documents.NumberTools.MIN_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MIN_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.MAX_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MAX_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.STR_SIZE">
            <summary> The length of (all) strings returned by {@link #longToString}</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.LongToString(System.Int64)">
            <summary> Converts a long to a String suitable for indexing.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.StringToLong(System.String)">
            <summary> Converts a String that was returned by {@link #longToString} back to a
            long.
            
            </summary>
            <throws>  IllegalArgumentException </throws>
            <summary>             if the input is null
            </summary>
            <throws>  NumberFormatException </throws>
            <summary>             if the input does not parse (it was not a String returned by
            longToString()).
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.ParseException.#ctor(Lucene.Net.QueryParsers.Token,System.Int32[][],System.String[])" -->
        <member name="M:Lucene.Net.QueryParsers.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.Document" -->
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>Constructs a new document with no fields. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Documents.Field)">
            <summary> <p>Adds a Field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</p>
            <p> Note that add like the removeField(s) methods only makes sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary> <p>Removes Field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first Field that has been added.
            If there is no Field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary> <p>Removes all fields with the given name from the document.
            If there is no Field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>Returns a Field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Fields">
            <summary>Returns an Enumeration of all the fields in a document. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary> Returns an array of {@link Field}s with the given name.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the Field
            </param>
            <returns> a <code>Field[]</code> array
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary> Returns an array of values of the Field specified as the method parameter.
            This method can return <code>null</code>.
            
            </summary>
            <param name="name">the name of the Field
            </param>
            <returns> a <code>String[]</code> of Field values
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary> Returns an array of byte arrays for of the fields that have the name specified
            as the method parameter. This method will return <code>null</code> if no
            binary fields with the specified name are available.
            
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a  <code>byte[][]</code> of binary field values.
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary> Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. This method will return <code>null</code>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            
            </summary>
            <param name="name">the name of the field.
            </param>
            <returns> a <code>byte[]</code> containing the binary field value.
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.PerFieldAnalyzerWrapper">
            <summary> This analyzer is used to facilitate scenarios where different
            fields require different analysis techniques.  Use {@link #addAnalyzer}
            to add a non-default analyzer on a Field name basis.
            See TestPerFieldAnalyzerWrapper.java for example usage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs with default analyzer.
            
            </summary>
            <param name="defaultAnalyzer">Any fields not specifically
            defined to use a different analyzer will use the one provided here.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.AddAnalyzer(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary> Defines an analyzer to use for the specified Field.
            
            </summary>
            <param name="fieldName">Field name requiring a non-default analyzer.
            </param>
            <param name="analyzer">non-default analyzer to use for Field
            </param>
        </member>
        <member name="T:Lucene.Net.Store.OutputStream">
            <deprecated> Use {@link IndexOutput} or {@link BufferedIndexOutput}
            instead.
            </deprecated>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqOptSumScorer" -->
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.reqScorer">
            <summary>The scorers passed from the constructor.
            These are set to null as soon as their Next() or SkipTo() returns false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqOptScorer</code>.</summary>
            <param name="reqScorer">The required scorer. This must match.
            </param>
            <param name="optScorer">The optional scorer. This is used for scoring only.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Explain(System.Int32)">
            <summary>Explain the score of a document.</summary>
            <todo>  Also show the total score. </todo>
            <summary> See BooleanScorer.explain() on how to do this.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyQuery">
            <summary>Implements the fuzzy search query. The similiarity measurement
            is based on the Levenshtein (edit distance) algorithm.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary> Create a new FuzzyQuery that will match terms with a similarity 
            of at least <code>minimumSimilarity</code> to <code>term</code>.
            If a <code>prefixLength</code> &gt; 0 is specified, a common prefix
            of that length is also required.
            
            </summary>
            <param name="term">the term to search for
            </param>
            <param name="minimumSimilarity">a value between 0 and 1 to set the required similarity
            between the query term and the matching terms. For example, for a
            <code>minimumSimilarity</code> of <code>0.5</code> a term of the same length
            as the query term is considered similar to the query term if the edit distance
            between both terms is less than <code>length(term)*0.5</code>
            </param>
            <param name="prefixLength">length of common (non-fuzzy) prefix
            </param>
            <throws>  IllegalArgumentException if minimumSimilarity is &gt;= 1 or &lt; 0 </throws>
            <summary> or if prefixLength &lt; 0
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, minimumSimilarity, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, 0.5f, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetMinSimilarity">
            <summary> Returns the minimum similarity that is required for this query to match.</summary>
            <returns> float value between 0.0 and 1.0
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetPrefixLength">
            <summary> Returns the non-fuzzy prefix length. This is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositions.SkipProx(System.Int64)">
            <summary>Called by base.SkipTo(). </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateTools" -->
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a Date to a string suitable for indexing.
            
            </summary>
            <param name="date">the date to be converted
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(Date, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a millisecond time to a string suitable for indexing.
            
            </summary>
            <param name="time">the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(long, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as a
            Date object.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the parsed time as a Date object 
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
            will be changed to <code>2004-09-01 00:00:00</code> when using
            <code>Resolution.MONTH</code>. 
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>1095767411000</code>
            (which represents 2004-09-21 13:50:11) will be changed to 
            <code>1093989600000</code> (2004-09-01 00:00:00) when using
            <code>Resolution.MONTH</code>.
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>A Query that matches documents containing a term.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetTerm">
            <summary>Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqExclScorer" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqExclScorer</code>.</summary>
            <param name="reqScorer">The scorer that must match, except where
            </param>
            <param name="exclScorer">indicates exclusion.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
            <returns> The score of the required scorer.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldSortedHitQueue" -->
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fields">Field names, in priority order (highest priority first).  Cannot be <code>null</code> or empty.
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.comparators">
            <summary>Stores a comparator corresponding to each Field being sorted by </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.fields">
            <summary>Stores the sort criteria being used. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.maxscore">
            <summary>Stores the maximum score value encountered, for normalizing.
            we only care about scores greater than 1.0 - if all the scores
            are less than 1.0, we don't have to normalize. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.FillFields(Lucene.Net.Search.FieldDoc)">
            <summary> Given a FieldDoc object, stores the values used
            to sort the given document.  These values are not the raw
            values out of the index, but the internal representation
            of them.  This is so the given search hit can be collated
            by a MultiSearcher with other search hits.
            </summary>
            <param name="doc"> The FieldDoc to store sort values into.
            </param>
            <returns>  The same FieldDoc passed in.
            </returns>
            <seealso cref="!:Searchable#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetFields">
            <summary>Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.Comparators">
            <summary>Internal cache of comparators. Similar to FieldCache, only
            caches comparators instead of term values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.Lookup(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object)">
            <summary>Returns a comparator if it is in the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.Store(Lucene.Net.Index.IndexReader,System.String,System.Int32,System.Object,System.Object)">
            <summary>Stores a comparator into the cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorInt(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorFloat(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing floats.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorString(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a Field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorStringLocale(Lucene.Net.Index.IndexReader,System.String,System.Globalization.CultureInfo)">
            <summary> Returns a comparator for sorting hits according to a Field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to values in the given Field.
            The terms in the Field are looked at to determine whether they contain integers,
            floats or strings.  Once the type is determined, one of the other static methods
            in this class is called to get the comparator.
            </summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Field containg values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDoc" -->
        <member name="F:Lucene.Net.Search.FieldDoc.fields">
            <summary>Expert: The values which are used to sort the referenced document.
            The order of these will match the original sort criteria given by a
            Sort object.  Each Object will be either an Integer, Float or String,
            depending on the type of values in the terms of the original Field.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Sort">
            </seealso>
            <seealso cref="!:Searchable#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[])">
            <summary>Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.ScanTo(Lucene.Net.Index.Term)">
            <summary>Optimized scan, without allocating new terms. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Prev">
            <summary>Returns the previous Term enumerated. Initially null.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo">
            <summary>Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo(Lucene.Net.Index.TermInfo)">
            <summary>Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.DocFreq">
            <summary>Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetVersion">
            <summary> version number when this SegmentInfos was generated.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ReadCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Current version number from segments file.</summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiReader">
            <summary>An IndexReader which reads multiple indexes, appending their content.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            <p>Note that all subreaders are closed if this Multireader is closed.</p>
            </summary>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean,Lucene.Net.Index.IndexReader[])">
            <summary>Construct reading the named set of readers. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized Field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized Field.
            If no such fields existed, the method returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetFieldNames">
            <seealso cref="!:IndexReader#GetFieldNames()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetFieldNames(System.Boolean)">
            <seealso cref="!:IndexReader#GetFieldNames(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <seealso cref="!:IndexReader#GetFieldNames(IndexReader.FieldOption)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermDocs.SkipTo(System.Int32)">
            <summary>As yet unoptimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Store.InputStream">
            <deprecated> Use {@link IndexInput} or {@link BufferedIndexInput} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.FSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>InputStream methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSIndexInput.SeekInternal(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSIndexInput.IsFDValid">
            <summary>Method used for testing. Returns true if the underlying
            file descriptor is valid.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>output methods: </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSIndexOutput.Seek(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
            <summary> MultiPhraseQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that have "app" as
            prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
            terms) to add them to the query.
            
            </summary>
            <author>  Anders Nielsen
            </author>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.SetSlop(System.Int32)">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#SetSlop(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetSlop">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#GetSlop()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>Add a single term at the next position in the phrase.</summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])">
            <summary>Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            
            </summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary> Allows to specify the relative position of terms within the phrase.
            
            </summary>
            <seealso cref="!:int)">
            </seealso>
            <param name="">terms
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermEnum" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single,System.Int32)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary> The termCompare method in FuzzyTermEnum uses Levenshtein distance to 
            calculate the distance between the given term and the comparing term. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.min(System.Int32,System.Int32,System.Int32)">
            <summary> Finds and returns the smallest of three integers </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.Similarity(System.String)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GrowDistanceArray(System.Int32)">
            <summary> Grow the second dimension of the array, so that we can calculate the
            Levenshtein difference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GetMaxDistance(System.Int32)">
            <summary> The max Distance is the maximum Levenshtein distance for the text
            compared to some other value that results in score that is
            better than the minimum similarity.
            </summary>
            <param name="m">the length of the "other value"
            </param>
            <returns> the maximum levenshtein distance that we care about
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser" -->
        <member name="F:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.operator_Renamed">
            <summary>The actual operator that parser uses to combine query terms </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Constructs a query parser.</summary>
            <param name="f"> the default field for query terms.
            </param>
            <param name="a">  used to find terms in the query text.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.parse(System.String)">
            <summary>Parses a query string, returning a {@link Lucene.Net.search.Query}.</summary>
            <param name="expression"> the query string to be parsed.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetAnalyzer">
            <returns> Returns the analyzer.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetField">
            <returns> Returns the field.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetFuzzyMinSim">
            <summary> Get the minimal similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetFuzzyMinSim(System.Single)">
            <summary> Set the minimum similarity for fuzzy queries.
            Default is 0.5f.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetFuzzyPrefixLength">
            <summary> Get the prefix length for fuzzy queries. </summary>
            <returns> Returns the fuzzyPrefixLength.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetFuzzyPrefixLength(System.Int32)">
            <summary> Set the prefix length for fuzzy queries. Default is 0.</summary>
            <param name="fuzzyPrefixLength">The fuzzyPrefixLength to set.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetPhraseSlop(System.Int32)">
            <summary> Sets the default slop for phrases.  If zero, then exact phrase matches
            are required.  Default value is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetPhraseSlop">
            <summary> Gets the default slop for phrases.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetDefaultOperator(Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.Operator)">
            <summary> Sets the boolean operator of the QueryParser.
            In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>AND_OPERATOR</code> mode terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetDefaultOperator">
            <summary> Gets implicit operator setting, which will be either AND_OPERATOR
            or OR_OPERATOR.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetLowercaseExpandedTerms(System.Boolean)">
            <summary> Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetLowercaseExpandedTerms">
            <seealso cref="!:#SetLowercaseExpandedTerms(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.SetLocale(System.Globalization.CultureInfo)">
            <summary> Set locale used by date range parsing.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetLocale">
            <summary> Returns current locale, allowing access by subclasses.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetFieldQuery(System.String,System.String)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetFieldQuery(System.String,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String,String)}.
            This method may be overridden, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            </summary>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetBooleanQuery(System.Collections.ArrayList)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetBooleanQuery(System.Collections.ArrayList,System.Boolean)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            </param>
            <param name="disableCoord">true if coord scoring should be disabled.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetWildcardQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetPrefixQuery(System.String,System.String)" -->
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.GetFuzzyQuery(System.String,System.String,System.Single)">
            <summary> Factory method for generating a query (similar to
            {@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.DiscardEscapeChar(System.String)">
            <summary> Returns a String where the escape char has been
            removed, or kept only once if there was a double escape.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.escape(System.String)">
            <summary> Returns a String where those characters that QueryParser
            expects to be escaped are escaped by a preceding <code>\</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.Precedence.PrecedenceQueryParser.Main(System.String[])" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.Precedence.FastCharStream" -->
        <member name="M:Lucene.Net.QueryParsers.Precedence.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosWriter" -->
        <member name="F:Lucene.Net.Index.TermInfosWriter.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.indexInterval">
            <summary>Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.skipInterval">
            <summary>Expert: The fraction of {@link TermDocs} entries stored in skip tables,
            used to accellerate {@link TermDocs#SkipTo(int)}.  Larger values result in
            smaller indexes, greater acceleration, but fewer accelerable cases, while
            smaller values result in bigger indexes, less acceleration and more
            accelerable cases. More detailed experiments would be useful here. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermInfosWriter.Add(Lucene.Net.Index.Term,Lucene.Net.Index.TermInfo)" -->
        <member name="M:Lucene.Net.Index.TermInfosWriter.Close">
            <summary>Called to complete TermInfos creation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosReader" -->
        <member name="M:Lucene.Net.Index.TermInfosReader.Size">
            <summary>Returns the number of term/value pairs in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>Returns the offset of the greatest index entry which is less than or equal to term.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.ScanEnum(Lucene.Net.Index.Term)">
            <summary>Scans within block for matching term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(System.Int32)">
            <summary>Returns the nth term in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms">
            <summary>Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardAnalyzer">
            <summary> Filters {@link StandardTokenizer} with {@link StandardFilter}, {@link
            LowerCaseFilter} and {@link StopFilter}, using a list of English stop words.
            
            </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.STOP_WORDS">
            <summary>An array containing some common English words that are usually not
            useful for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor">
            <summary>Builds an analyzer with the default stop words ({@link #STOP_WORDS}). </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Constructs a {@link StandardTokenizer} filtered by a {@link
            StandardFilter}, a {@link LowerCaseFilter} and a {@link StopFilter}. 
            </summary>
        </member>
    </members>
</doc>
