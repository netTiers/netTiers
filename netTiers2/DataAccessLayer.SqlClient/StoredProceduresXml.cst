<%@ CodeTemplate Src="..\CommonSqlCode.cs" Debug="true" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="T-SQL"
	Description="Generates SELECT/INSERT/UPDATE/DELETE stored procedures based on one or more selected tables, or an entire database schema." ResponseEncoding="UTF-8"%>

<%@ Property Name="CompanyName" Optional="True" Type="System.String" Category="General" Description="The name of your company." %>
<%@ Property Name="CompanyURL" Optional="True" Type="System.String" Category="General" Description="The URL of your company." %>

<%@ Property Name="SourceViews" Type="SchemaExplorer.ViewSchemaCollection" Optional="True" Category="Context" Description="Views that the stored procedures should be based on." %>
<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Context" Description="Tables that the stored procedures should be based on." %>
<%@ Property Name="IncludeDrop" Type="System.Boolean" Default="True" Category="Options" Description="If true drop statements will be generated to drop existing stored procedures." %>
<%@ Property Name="IncludeInsert" Type="System.Boolean" Default="True" Category="Options" Description="If true insert procedures will be generated." %>
<%@ Property Name="IncludeUpdate" Type="System.Boolean" Default="True" Category="Options" Description="If true update procedures will be generated." %>
<%@ Property Name="IncludeDelete" Type="System.Boolean" Default="True" Category="Options" Description="If true delete procedures will be generated." %>

<%@ Property Name="IncludeGetList" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist procedures will be generated." %>
	
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get statements will be generated." %>
<%@ Property Name="IncludeGetListByIX" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist statements will be generated." %>
<%@ Property Name="IncludeFind" Type="System.Boolean" Default="True" Category="Options" Description="If true find statements will be generated." %>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="True" Category="Options" Description="If true select statements will be generated for any many to many relationship." %>

<%@ Property Name="IsolationLevel" Type="TransactionIsolationLevelEnum" Default="None" Category="Options" Description="Isolation level to use in generated procedures." %>
<%@ Property Name="ExcludeFields" Type="System.String[]" Optional="True" Category="Options" Description="Enter a list of fields to exclude from parameter generation" %>

<%@ Property Name="InsertSuffix" Type="System.String" Default="_Insert" Category="Style" Description="Suffix to use for all generated INSERT stored procedures." %>
<%@ Property Name="UpdateSuffix" Type="System.String" Default="_Update" Category="Style" Description="Suffix to use for all generated UPDATE stored procedures." %>
<%@ Property Name="DeleteSuffix" Type="System.String" Default="_Delete" Category="Style" Description="Suffix to use for all generated DELETE stored procedures." %>
<%@ Property Name="SelectSuffix" Type="System.String" Default="_Get" Category="Style" Description="Suffix to use for all generated SELECT stored procedures." %>
<%@ Property Name="SelectAllSuffix" Type="System.String" Default="List" Category="Style" Description="Suffix to use for all generated SELECT stored procedures." %>
<%@ Property Name="FindSuffix" Type="System.String" Default="_Find" Category="Style" Description="Suffix to use for all generated selective SELECT stored procedures." %>
<%@ Property Name="ProcedurePrefix" Type="System.String" Default="" Category="Style" Optional="True" Description="prefix to use for all generated stored procedures." %>
<%@ Property Name="GrantUser" Type="System.String" Category="Style" Description="Optional user or role to GRANT EXEC Procedure permissions to" Default="" Optional="True" %>
	
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>
<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="System.Text.RegularExpressions" %>
<%@ Import Namespace="System.Collections" %>
<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type='text/xsl' href="scriptsql.xsl"?>
<root xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<database><%=SourceTables[0].Database.Name%></database>
<procedures>
<%
	for (int st = 0; st < SourceTables.Count; st++)
	{
		TableSchema SourceTable = SourceTables[st];
		//Set table properties
		string owner = GetOwner(SourceTable);
		string name = GetSafeName(SourceTable);
		string commandStem = GetCleanName(SourceTable);
		string tableComment = SourceTable.Description;
		
		
		// Collection of all columns in the table.
		ColumnSchemaCollection cols = SourceTable.Columns;
		
		// Collection of all columns in the table that are not primary keys.
		ColumnSchemaCollection nonKeys = SourceTable.NonPrimaryKeyColumns;
		
		// Collection of all primary key columns.
		//ColumnSchemaCollection keys = SourceTable.PrimaryKey.MemberColumns;
				
		// Collection of ForeignKeys. Provides information about the foreign keys 
		//(keys where the current table is the foreign table) contained in the table. 
		TableKeySchemaCollection fkeys = SourceTable.ForeignKeys;
				
		//Provides information about the primary keys 
		//(keys where the current table is the primary table) contained in the table. 
		TableKeySchemaCollection pkeys = SourceTable.PrimaryKeys;
		
		//Provides information about the indexes contained in the table. 
		IndexSchemaCollection indexes = SourceTable.Indexes;
		
		//ColumnSchema primaryKey = SourceTable.PrimaryKey.MemberColumns[0];
		
		// [ab 012605] nonKeys/cols sans computed/read-only columns. This is for Insert/Update operations
		ColumnSchemaCollection colsUpdatable = new ColumnSchemaCollection(cols.Count);
		ColumnSchemaCollection nonKeysUpdatable = new ColumnSchemaCollection(nonKeys.Count);

		// Holds the RowVersion column is there's any
		ColumnSchema RowVersion = null;
		
		foreach (ColumnSchema column in cols)
		{
			if ( ! IsIdentityColumn(column) && ! IsComputed(column) )
				colsUpdatable.Add(column);
				
			if (column.NativeType.ToLower() == "timestamp")
				RowVersion = column;
		}
		
		foreach (ColumnSchema column in nonKeys)
		{
			if ( ! IsIdentityColumn(column) && ! IsComputed(column) )
				nonKeysUpdatable.Add(column);
		}
		
		bool JunctionTable = IsJunctionTable(SourceTable);

		// this array store each Get BY MemberColumns in order to avoid to create doublon Get methods
		System.Collections.ArrayList getbyKeys = new System.Collections.ArrayList();

		
		
		
		
		
		
		
		
		
		
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		// GetList
		if (IncludeGetList)
		{%>
		
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + SelectAllSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Gets all records from the {0} table", name), tableComment) %>]]></comment>
			<parameters/>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				SELECT
					<% for (int i = 0; i < cols.Count; i++) { %>
					[<%= cols[i].Name %>]<% if (i < cols.Count - 1) { %>,<% } %>
					<% } %>
				FROM
					<%=owner%>[<%= SourceTable.Name %>]
					
				Select @@ROWCOUNT
			]]></body>
		</procedure>
		
		<% 
		if (SourceTable.PrimaryKey != null) {
		%>
		
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix %>Paged" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Gets records from the {0} table passing page index and page count parameters", name), tableComment) %>]]></comment>
			<parameters>
				<parameter name="@WhereClause" type="varchar" direction="Input" size="2000" precision="0" scale="0" param="(2000)" />
				<parameter name="@OrderBy" type="varchar" direction="Input" size="2000" precision="0" scale="0" param="(2000)"/>
				<parameter name="@PageIndex" type="int" direction="Input" size="0" precision="10" scale="0" />
				<parameter name="@PageSize" type="int" direction="Input" size="0" precision="10" scale="0" /> 
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				DECLARE @RowsToReturn int
				DECLARE @RowCount int
				
				-- First set the rowcount
				SET @RowsToReturn = @PageSize * (@PageIndex + 1)
				--SET ROWCOUNT @RowsToReturn
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize
				
				-- Create a temp table to store the select results
				CREATE TABLE #PageIndex
				(
				    [IndexId] int IDENTITY (1, 1) NOT NULL,
				    <%=GetPagedHelper(SourceTable.PrimaryKey.MemberColumns)%> 
				)
				
				-- Insert into the temp table
				declare @SQL as nvarchar(3500)
				SET @SQL = 'INSERT INTO #PageIndex (<% for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++) { Response.Write(GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)); if (i < SourceTable.PrimaryKey.MemberColumns.Count-1) {Response.Write(", ");} } %>)'
				SET @SQL = @SQL + ' SELECT <% for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++) { Response.Write("[" + SourceTable.PrimaryKey.MemberColumns[i].Name + "]"); if (i < SourceTable.PrimaryKey.MemberColumns.Count-1) {Response.Write(", ");} } %>'
				SET @SQL = @SQL + ' FROM <%=owner%>[<%= SourceTable.Name %>]'
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + ' WHERE ' + @WhereClause
				END
				 
				IF LEN(@OrderBy) > 0
				BEGIN
					SET @SQL = @SQL + ' ORDER BY ' + @OrderBy
				END
				
				-- Populate the temp table
				exec sp_executesql @SQL

				-- Return total count
				SELECT @RowCount = @@ROWCOUNT
				
				IF @PageSize <= 0
				BEGIN
				--Return all rows
				SET @PageUpperBound = @RowCount
				END
				
				-- Return total count
				SELECT @RowCount 
					
				--Set RowCount After Total Rows is determined
				SET ROWCOUNT @RowsToReturn

				-- Return paged results
				SELECT <% for (int i = 0; i < cols.Count; i++) { %>O.[<%= cols[i].Name %>]<% if (i < cols.Count - 1) { %>, <% }} %>
				FROM
				    <%=owner%>[<%= SourceTable.Name %>] O,
				    #PageIndex PageIndex
				WHERE
					<%
					foreach (ColumnSchema column in SourceTable.PrimaryKey.MemberColumns)
					{
						Response.Write("O.[" + column.Name + "] = PageIndex.[" + column.Name + "] AND ");
					}
					%>
				    PageIndex.IndexID > @PageLowerBound AND
				    PageIndex.IndexID <= @PageUpperBound
				ORDER BY
				    PageIndex.IndexID
				
				END
			
			]]></body>
		</procedure>
		
		<%
		} // end if (paged)
		} // end if (IncludeGetList) 
				
		
		
		
		
		
		
		
		
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		// Insert
		if (IncludeInsert)
		{%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + InsertSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Inserts a record into the {0} table", name), tableComment) %>]]></comment>
			<parameters>
				<% 
				int countComputedColumns = 0;
				for (int i = 0; i < cols.Count; i++)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(cols[i], IsComputed(cols[i]) || IsIdentityColumn(cols[i])) + Environment.NewLine);
					if (IsComputed(cols[i]))
						countComputedColumns++;
				}%>
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>	
				INSERT INTO <%=owner + "[" + SourceTable.Name %>]
					(
					<% for (int i = 0; i < colsUpdatable.Count; i++) { %>[<%= colsUpdatable[i].Name %>]<% if (i < colsUpdatable.Count - 1) { %>
					,<% } } %>
					)
				VALUES
					(
					<% for (int i = 0; i < colsUpdatable.Count; i++) { %>@<%= GetPropertyName(colsUpdatable[i].Name) %><% if (i < colsUpdatable.Count - 1) { %>
					,<% } } %>
					)
				
				<% for (int i = 0; i < cols.Count; i++) { if (IsIdentityColumn(cols[i])) { %>
				-- Get the identity value
				SET @<%= GetPropertyName(cols[i].Name) %> = SCOPE_IDENTITY()
				<% } } %>
									
				<% if (countComputedColumns > 0) {%>
				-- Select computed columns into output parameters
				SELECT
				<%
					string tempParams = string.Empty;
					for (int i = 0; i < cols.Count; i++)
					{
						if (IsComputed(cols[i]))
						{
							tempParams += string.Format(", @{0} = [{1}]{2}", GetPropertyName(cols[i].Name), cols[i].Name, Environment.NewLine) ;
						}
					}
					Response.Write(tempParams.TrimStart(','));
				%>
				FROM
					<%=owner + "[" + SourceTable.Name %>]
				WHERE
				<%
					tempParams = string.Empty;
					for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++)
					{
						//if (IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) || IsComputed(SourceTable.PrimaryKey.MemberColumns[i]))
						//{
							tempParams += string.Format("AND [{1}] = @{0} {2}", GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name), SourceTable.PrimaryKey.MemberColumns[i].Name, Environment.NewLine) ;
						//}
					}
					if(tempParams.Length > 4)
					{
						Response.Write(tempParams.Substring(4));
					}
				%>
				<% } // endif countComputedColumns > 0 %>
							
			]]></body>
		</procedure>
		<%} // end if (IncludeInsert) 
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if (IncludeUpdate) 
		{%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + UpdateSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Updates a record in the {0} table", name), tableComment) %>]]></comment>
			<parameters>
				<% 
				int countComputedColumns = 0;
				for (int i = 0; i < cols.Count; i++)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(cols[i], IsComputed(cols[i]) && cols[i] != RowVersion) + Environment.NewLine);
					
					if (cols[i].IsPrimaryKeyMember && !IsComputed(cols[i]) && !IsIdentityColumn(cols[i]) && cols[i] != RowVersion)
					{
						Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(cols[i], "Original" + cols[i].Name, false) + Environment.NewLine);
					}
		
					if (IsComputed(cols[i]))
						countComputedColumns++;
				
				}
				if (RowVersion != null)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(RowVersion, "Returned" + GetPropertyName(RowVersion.Name), true) + Environment.NewLine);
				}
				%>
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				
				-- Modify the updatable columns
				UPDATE
					<%=owner + "[" + SourceTable.Name %>]
				SET
					<% for (int i = 0; i < colsUpdatable.Count; i++) { %>[<%= colsUpdatable[i].Name %>] = @<%= GetPropertyName(colsUpdatable[i].Name) %><% if (i < colsUpdatable.Count - 1) { %>
					,<% } } %>
				WHERE
				<%
					string tempParams = string.Empty;
					for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++)
					{
						string prefix = string.Empty;
						
						if (!IsComputed(SourceTable.PrimaryKey.MemberColumns[i]) && !IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && SourceTable.PrimaryKey.MemberColumns[i] != RowVersion)
							prefix = "Original";
						
						tempParams += string.Format("AND [{1}] = @{0} {2}", prefix + GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name), SourceTable.PrimaryKey.MemberColumns[i].Name, Environment.NewLine) ;
					}
					if(tempParams.Length > 4)
					{
						Response.Write(tempParams.Substring(4));
					}
					if (RowVersion != null)
					{
						Response.Write("AND [" + RowVersion.Name + "] = @" + GetPropertyName(RowVersion.Name) );
					} 
				%>
				
				<% if (countComputedColumns > 0) {%>
				
				-- Select computed columns into output parameters
				SELECT
				<%
					tempParams = string.Empty;
					for (int i = 0; i < cols.Count; i++)
					{
						if (IsComputed(cols[i]) && cols[i] != RowVersion)
						{
							tempParams += string.Format(", @{0} = [{1}]{2}", GetPropertyName(cols[i].Name), cols[i].Name, Environment.NewLine) ;
						}
					}
					if (RowVersion != null)
					{
						tempParams += string.Format(", @Returned{0} = [{1}]{2}", GetPropertyName(RowVersion.Name), RowVersion.Name, Environment.NewLine) ;		
					} 
					
					Response.Write(tempParams.TrimStart(','));
					
				%>
				FROM
					<%=owner + "[" + SourceTable.Name %>]
				WHERE
				<%
					tempParams = string.Empty;
					for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++)
					{
						tempParams += string.Format("AND [{1}] = @{0} {2}", GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name), SourceTable.PrimaryKey.MemberColumns[i].Name, Environment.NewLine) ;
					}
					if(tempParams.Length > 4)
					{
						Response.Write(tempParams.Substring(4));
					}
				%>
				<% } // endif countComputedColumns > 0 %>
			]]></body>
		</procedure>
		<%} // end if (IncludeUpdate) 
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if (IncludeDelete && SourceTable.PrimaryKey != null) 
		{%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + DeleteSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Deletes a record in the {0} table", name), tableComment) %>]]></comment>
			<parameters>
			<% 
				string tempParams = string.Empty;
				for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(SourceTable.PrimaryKey.MemberColumns[i], false) + Environment.NewLine);
				}
				if (RowVersion != null)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(RowVersion, false) + Environment.NewLine);
				}				
			%>
			</parameters>
			<body><![CDATA[
				DELETE FROM <%=owner%>[<%= SourceTable.Name %>] WITH (ROWLOCK) 
				WHERE
					<% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>			
					<% if (i > 0) { %>AND <% } %>[<%= SourceTable.PrimaryKey.MemberColumns[i].Name %>] = @<%= GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name) %>
					<% } 
					if (RowVersion != null)
					{
						Response.Write("\tAND [" + RowVersion.Name + "] = @" + GetPropertyName(RowVersion.Name) );
					} %>
					
			]]></body>
		</procedure>
		<%} // end if (IncludeDelete) 
		
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if (IncludeGetListByFK)
		{ 
			for (int j=0; j < fkeys.Count; j++) 
			{ 
				bool skipkey = false;
				foreach(IndexSchema i in indexes)
				{
					/*if(i.MemberColumns.Contains(fkeys[j].ForeignKeyMemberColumns[0]))
						skipkey = true;	*/
					if(i.MemberColumns.Equals(fkeys[j].ForeignKeyMemberColumns))
						skipkey = true;		
				}
				if(skipkey)
					continue;
					
				getbyKeys.Add(GetKeysName(fkeys[j].ForeignKeyMemberColumns));
%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + "By" + FKColumnName(fkeys[j]) %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Select records from the {0} table through a foreign key", SourceTable.Name), "") %>]]></comment>
			<parameters>
			<% 
				for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) 
  				{
  					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(fkeys[j].ForeignKeyMemberColumns[i], false) + Environment.NewLine);
  				}
  			%>
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				SELECT
					<% for (int i = 0; i < cols.Count; i++) { %>
					[<%= cols[i].Name %>]<% if (i < cols.Count - 1) { %>,<% } %>
					<% } %>
				FROM
					<%= owner %>[<%= SourceTable.Name %>]
				WHERE
					<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
					<% if (i > 0) { %>AND <% } %>[<%= fkeys[j].ForeignKeyMemberColumns[i].Name %>] = @<%= GetPropertyName(fkeys[j].ForeignKeyMemberColumns[i].Name) %>
					<% } %>
				
				Select @@ROWCOUNT
			]]></body>
		</procedure>
<%
			} // end for (each foreign key)

		}  // if (IncludeGetListByFK) 
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if (IncludeGetListByIX)
		{
			for (int j=0; j < indexes.Count; j++) 
			{ 
				// Check if this key is not already generated
				if(getbyKeys.IndexOf(GetKeysName(indexes[j].MemberColumns)) >=0 )
				{
					continue;
				}
				else
				{
					// add this key to the index list
					getbyKeys.Add(GetKeysName(indexes[j].MemberColumns));
				}
%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + "By" + IXColumnName(indexes[j]) %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Select records from the {0} table through an index", SourceTable.Name), "") %>]]></comment>
			<parameters>
			<% 
				for (int i = 0; i < indexes[j].MemberColumns.Count; i++) 
  				{
  					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(indexes[j].MemberColumns[i], false) + Environment.NewLine);
  				}
  			%>
			</parameters>
			<body><![CDATA[
				SELECT
					<% for (int i = 0; i < cols.Count; i++) { %>
					[<%= cols[i].Name %>]<% if (i < cols.Count - 1) { %>,<% } %>
					<% } %>
				FROM
					<%= owner %>[<%= SourceTable.Name %>]
				WHERE
					<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
					<% if (i > 0) { %>AND <% } %>[<%= indexes[j].MemberColumns[i].Name %>] = @<%= GetPropertyName(indexes[j].MemberColumns[i].Name) %>
					<% } %>
			Select @@ROWCOUNT
					
			]]></body>
			
		</procedure>
<%			
			} // end for (each index)

		} else {   // if (IncludeGetListByIX)

			// if the user doesn't want the IncludeGetListByIX functions, then we wont have our GetByPrimaryKey stored proc... create it so that we get RefreshEntity support
			 if (SourceTable.PrimaryKey != null)
			 {
%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + "By" + GetKeysName(SourceTable.PrimaryKey.MemberColumns) %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Supports the RefreshEntity method {0} for updating an entity when IncludeGetListByFK is disabled", SourceTable.Name), "") %>]]></comment>
			<parameters>
			<% 
				for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) 
  				{
  					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(SourceTable.PrimaryKey.MemberColumns[i], false) + Environment.NewLine);
  				}
  			%>
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				SELECT
					<% for (int i = 0; i < cols.Count; i++) { %>
					[<%= cols[i].Name %>]<% if (i < cols.Count - 1) { %>,<% } %>
					<% } %>
				FROM
					<%= owner %>[<%= SourceTable.Name %>]
				WHERE
					<% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
					<% if (i > 0) { %>AND <% } %>[<%= SourceTable.PrimaryKey.MemberColumns[i].Name %>] = @<%= GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name) %>
					<% } %>
				
				Select @@ROWCOUNT
			]]></body>
		</procedure>
<%
			 } // if (SourceTable.PrimaryKey != null)
		} // end if (IncludeGetListByIX) 
		
		
		
		
		
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if(IncludeManyToMany)
		{
			TableSchema primaryTable = SourceTable;
		
			foreach(TableKeySchema key in SourceTable.PrimaryKeys)
			{
				// Check that the key is related to a junction table
				if ( IsJunctionTable(key.ForeignKeyTable) )
				{
					TableSchema junctionTable = key.ForeignKeyTable;
					
					// Search for the other(s) key(s) of the junction table' primary key
					foreach(TableKeySchema junctionTableKey in junctionTable.ForeignKeys)
					{				
						if ( IsJunctionKey(junctionTableKey) && junctionTableKey.Name != key.Name )
						{
							TableSchema secondaryTable = junctionTableKey.PrimaryKeyTable;
																			
							string functionname = GetManyToManyName(junctionTableKey, GetCleanName(junctionTable.Name));
													
							// here query
%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + "By" + functionname %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment("Gets records through a junction table", "") %>]]></comment>
			<parameters>
			<% 
				for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) 
  				{
  					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(junctionTableKey.ForeignKeyMemberColumns[i], false) + Environment.NewLine);
  				}
  			%>
			</parameters>
			<body><![CDATA[
SELECT <% for (int i = 0; i < primaryTable.Columns.Count; i++)
          { if (i > 0) { %>
       ,<% } %><%=owner%>[<%=primaryTable.Name%>].[<%= primaryTable.Columns[i].Name %>]<%
          } // for %>
  FROM <%=owner%>[<%=primaryTable.Name%>]
 WHERE EXISTS (SELECT 1
                 FROM <%=owner%>[<%=junctionTable.Name%>] 
                WHERE <% 
				for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) {
					%><%=owner%>[<%=junctionTable.Name%>].[<%=junctionTableKey.ForeignKeyMemberColumns[i].Name%>] = @<%=GetPropertyName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>
                  <%if(i < junctionTableKey.ForeignKeyMemberColumns.Count-1) {%>AND <%}
				} // for
				// find the ForeignKey that points to the current table
				foreach(TableKeySchema primaryTableKey in junctionTable.ForeignKeys)
				{				
					if ( IsJunctionKey(primaryTableKey) && primaryTableKey.Name == key.Name )
					{
						%>AND <%
						for (int i = 0; i < primaryTableKey.ForeignKeyMemberColumns.Count; i++) {
							%><%=owner%>[<%=primaryTableKey.ForeignKeyTable.Name%>].[<%=primaryTableKey.ForeignKeyMemberColumns[i].Name%>] = <%=owner%>[<%=primaryTableKey.PrimaryKeyTable.Name %>].[<%=primaryTableKey.PrimaryKeyMemberColumns[i].Name%>]
                  <%if(i < primaryTableKey.ForeignKeyMemberColumns.Count-1) {%>AND <%}
						} // for
					} // if
				} // foreach
				
				%>)
				Select @@ROWCOUNT			
				]]></body>
		</procedure>
<%						
						}// //end if there is many to many relationship.
					} //end foreach		
				} // end if(IsJunctionTable(junctionTableKey.ForeignKeyTable))
			} //end foreach pkey
		} //end if(IncludeManyToMany)
		
		
		
		
		
		// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		if(IncludeFind)
		{%>
		<procedure owner="<%=SourceTable.Owner%>" name="<%= ProcedurePrefix + commandStem + FindSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Finds records in the {0} table passing nullable parameters", name), tableComment) %>]]></comment>
			<parameters>
				<parameter name="@SearchUsingOR" type="bit" direction="Input" size="0" precision="1" scale="0" param="" nulldefault="null"/>
				<% 
				for (int i = 0; i < cols.Count; i++)
				{
					Response.Write("\t\t\t\t" + GetSqlParameterXmlNode(cols[i], cols[i].Name, false, true) + Environment.NewLine);
				}%>
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
  IF ISNULL(@SearchUsingOR, 0) <> 1
  BEGIN
    SELECT
	<%= BuildColList(SourceTable) %>
    FROM
	<%=owner%>[<%= SourceTable.Name %>]
    WHERE 
					<% 
					string tmpWhere = "\t";
						
					for (int i = 0; i < cols.Count; i++)
					{
						if (IsColumnFindable(cols[i]))
						{ 
						tmpWhere  += string.Format("\tAND ([{0}] = @{2} OR @{2} is null){1}", cols[i].Name, Environment.NewLine, GetPropertyName(cols[i].Name)) ;
						}
					}
					if (tmpWhere.Length > 5)
					{
						Response.Write("\t" + tmpWhere.Remove(0,5));
					}
					%>					
						
  END
  ELSE
  BEGIN
    SELECT
	<%= BuildColList(SourceTable) %>
    FROM
	<%=owner%>[<%= SourceTable.Name %>]
    WHERE 
					<% 
					tmpWhere = "\t";
						
					for (int i = 0; i < cols.Count; i++)
					{
						if (IsColumnFindable(cols[i]))
						{ 
						tmpWhere  += string.Format("\tOR ([{0}] = @{2} AND @{2} is not null){1}", cols[i].Name, Environment.NewLine, GetPropertyName(cols[i].Name)) ;
						}
					}
					if (tmpWhere.Length > 4)
					{
						Response.Write("\t" + tmpWhere.Remove(0,4));
					}
					%>					
	Select @@ROWCOUNT			
  END
				]]></body>
		</procedure>
		<%} //end if(IncludeFind)

	} // end for each Table
	// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
	// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
	// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
	// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
	
	
	// Sql views management
	for (int vi = 0; vi < SourceViews.Count; vi++)
	{
		ViewSchema SourceView = SourceViews[vi];
		
		string owner = GetOwner(SourceView);
		string name = GetSafeName(SourceView);
		string commandStem = GetCleanName(SourceView);
		string tableComment = SourceView.Description;
		
		if (IncludeGetList) 
		{%>
		<procedure owner="<%=SourceView.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix + SelectAllSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Gets all records from the {0} view", name), tableComment) %>]]></comment>
			<parameters/>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				SELECT
					<% for (int i = 0; i < SourceView.Columns.Count; i++) { %>
					[<%= SourceView.Columns[i].Name %>]<% if (i < SourceView.Columns.Count - 1) { %>,<% } %>
					<% } %>
				FROM
					<%=owner%>[<%= SourceView.Name %>]
				Select @@ROWCOUNT			
										
			]]></body>
		</procedure>
		
		<procedure owner="<%=SourceView.Owner%>" name="<%= ProcedurePrefix + commandStem + SelectSuffix %>" <%if (GrantUser != "") {%>grant="<%=GrantUser%>"<%}%>>
			<comment><![CDATA[<%= GetProcSqlComment(string.Format("Gets records from the {0} view passing page index and page count parameters", name), tableComment) %>]]></comment>
			<parameters>
				<parameter name="@WhereClause" type="varchar" direction="Input" size="2000" precision="0" scale="0" param="(2000)" />
				<parameter name="@OrderBy" type="varchar" direction="Input" size="2000" precision="0" scale="0" param="(2000)"/>			
			</parameters>
			<body><![CDATA[
				<%= GetSetTransactionIsolationLevelStatement() %>
				BEGIN

				-- Build the sql query
				declare @SQL as nvarchar(4000)
				SET @SQL = ' SELECT * FROM <%=owner%>[<%= SourceView.Name %>]'
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + ' WHERE ' + @WhereClause
				END
				 
				IF LEN(@OrderBy) > 0
				BEGIN
					SET @SQL = @SQL + ' ORDER BY ' + @OrderBy
				END
				SET @SQL = @SQL + ';Select @@ROWCOUNT'
				-- Execution the query
				exec sp_executesql @SQL
								
				END
								
			]]></body>
		</procedure>
		
		<%} //end if(IncludeGetList)
		
	} // end for each View
%>
</procedures>
</root>
<script runat="template">

public enum TransactionIsolationLevelEnum
{
	None,
	ReadCommitted,
	ReadUncommitted,
	RepeatableRead,
	Serializable
}
public string GetSetTransactionIsolationLevelStatement()
{
	switch (IsolationLevel)
	{
		case TransactionIsolationLevelEnum.None:
			return "";
		case TransactionIsolationLevelEnum.ReadCommitted:
			return "SET TRANSACTION ISOLATION LEVEL READ COMMITTED";
		case TransactionIsolationLevelEnum.ReadUncommitted:
			return "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED";
		case TransactionIsolationLevelEnum.RepeatableRead:
			return "SET TRANSACTION ISOLATION LEVEL REPEATABLE READ";
		case TransactionIsolationLevelEnum.Serializable:
			return "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE";
		default:
			return "SET TRANSACTION ISOLATION LEVEL READ COMMITTED";
	}
}

//Build the SQL comment header for the procedure
public string GetProcSqlComment(string purpose, string tableComment)
{
	StringBuilder sqlComment = new StringBuilder();
	sqlComment.AppendFormat("/*{0}", Environment.NewLine);
	sqlComment.AppendFormat("{0}{1}", new String('-', 100), Environment.NewLine); 
	sqlComment.AppendFormat("-- Date Created: {0}{1}", DateTime.Now.ToLongDateString(), Environment.NewLine);
	sqlComment.AppendFormat("\r\n-- Created By: " + CompanyName + " (" + CompanyURL + ")" + Environment.NewLine);
	sqlComment.AppendFormat("-- Purpose: {0}{1}", purpose, Environment.NewLine);
	//if the tableComment is not empty, prefix it with a label
	if (!tableComment.Equals(string.Empty))
		sqlComment.AppendFormat("-- Table Comment: {0}{1}", tableComment,  Environment.NewLine);
	sqlComment.Append(new String('-', 100) + Environment.NewLine);
	sqlComment.AppendFormat("*/{0}", Environment.NewLine);
	return sqlComment.ToString();
}


public string BuildColList(TableSchema table)
{
	string prefix = "";
	string retVal = "";
	for (int i = 0; i < table.Columns.Count; i++) { 
		if (i > 0) prefix = "\r\n\t";
		retVal += prefix + GetComma(i) + "[" + table.Columns[i].Name + "]";
	}
	return retVal;
}
public string GetComma()
{
	return ", ";
}
public string GetComma(int i)
{
	string retVal = "  ";
 	if (i > 0) {
		retVal = ", ";
	}
	return retVal;
}

public string GetPagedHelper(ColumnSchemaCollection columns)
{
	string result = string.Empty;
	for(int i=0; i< columns.Count; i++)
	{
		result += GetPagedHelper(columns[i]);
		if (i < columns.Count-1)
		{
			result += ", "; 
		}
	}
	return result;
}

/// <summary>
/// Get a SqlParameter statement for a column
/// </summary>
/// <param name="column">Column for which to get the Sql parameter statement</param>
/// <returns>Sql Parameter statement</returns>
public string GetPagedHelper(ColumnSchema column)
{
	string param = "[" + column.Name + "] " + column.NativeType;
	
	// user defined data types do not need size components
	if ( ! IsUserDefinedType(column) )
	{
	switch (column.DataType)
	{
		case DbType.Decimal:
		{
			param += "(" + column.Precision + ", " + column.Scale + ")";
			break;
		}
		case DbType.AnsiString:
		case DbType.AnsiStringFixedLength:
		case DbType.String:
		case DbType.StringFixedLength:
		{
			if (column.NativeType != "text" && column.NativeType != "ntext")
			{
				if (column.Size > 0)
				{
					param += "(" + column.Size + ") COLLATE database_default ";
				}
			}
			break;
		}
	}	
	}
	return param;
}
</script>
