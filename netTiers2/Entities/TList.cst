<%--
 * $Id: TList.cst,v 1.21 2006/02/27 22:09:40 bgjohnso Exp $
 * Last modified by $Author: bgjohnso $
 * Last modified at $Date: 2006/02/27 22:09:40 $
 * $Revision: 1.21 $
--%>
<%@ CodeTemplate Language="C#" TargetLanguage="C#" Description="Generate a generic Colelction for our framework." %>

<%@ Property Name="NameSpace" Type="System.String" Category="Data" Description="Object Namespace." %>	

using System;
using System.Text;

using System.ComponentModel;
using System.Collections;
using System.Collections.Generic;

using System.Runtime.Serialization;
using System.Xml.Serialization;


namespace <%=NameSpace%>
{
	/// <summary>
	/// A generic collection for the nettiers entities that are generated from tables. 
	/// Supports filtering, databinding, searching and sorting.
	/// </summary>
	/// <remarks>
	/// An online quick start guide to generics can be found here:
	/// <see cref="http://www.ondotnet.com/pub/a/dotnet/excerpt/progcsharp4_ch09-04/index.html?page=1">ondotnet.com</see>
	/// </remarks>
	[Serializable]
	public class TList<T> : ListBase<T> where T : IEntity, new()
   	{
		
		/// <summary>
		/// Initializes a new instance of the <see cref="T:TList{T}"/> class.
		/// </summary>
		public TList()
		{
		}

      #region BindingList overrides

      /// <summary>
      /// Inserts the specified item in the list at the specified index.
      /// </summary>
      /// <param name="index">The zero-based index where the item is to be inserted.</param>
      /// <param name="item">The item to insert in the list.</param>
      protected override void InsertItem(int index, T item)
      {
         //Set the parentCollection property
         item.ParentCollection = this;

         base.InsertItem(index, item);
      }

      /// <summary>
      /// Removes the item at the specified index.
      /// </summary>
      /// <param name="index">The zero-based index of the item to remove.</param>
      protected override void RemoveItem(int index)
      {
         T item = Items[index];

         if (item != null)
         {
            //Move item to deleted collection(if not in added state)
            if (item.EntityState != EntityState.Added)
            {
               DeletedItems.Add(item);
            }
            base.RemoveItem(index);
         }
      }

      #endregion

      #region ICloneable

      ///<summary>
      /// Creates an exact copy of this TList{T} instance.
      ///</summary>
      ///<returns>The TList{T} object this method creates, cast as an object.</returns>
      ///<implements><see cref="ICloneable.Clone"/></implements>
      public override object Clone()
      {
         return this.Copy();
      }

      ///<summary>
      /// Creates an exact copy of this TList{T} object.
      ///</summary>
      ///<returns>A new, identical copy of the TList{T}.</returns>
      public virtual TList<T> Copy()
      {
         TList<T> copy = new TList<T>();
         foreach (T item in this)
         {
            T itemCopy = (T)MakeCopyOf(item);
            copy.Add(itemCopy);
         }
         return copy;
      }
      #endregion ICloneable

      #region Added Functionality

      /// <summary>
      ///		Indicates whether the collection was modified or not, and thus if it needs to be saved.
      /// </summary>
      ///<returns>true is the collection needs to be saved; otherwise false.</returns>
      public virtual bool IsDirty
      {
         get
         {
            return IsNewCount > 0 || IsDeletedCount > 0 || IsDirtyCount > 0;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked new in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked new in the collection</returns>
      public virtual int IsNewCount
      {
         get
         {
            int count = 0;
            foreach (T item in this)
            {
               //if(item.IsNew)
               if (item.EntityState == EntityState.Added)
                  count += 1;
            }
            return count;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked to delete in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked for deletation in the collection</returns>
      public virtual int IsDeletedCount
      {
         get
         {
            /*
            int count = 0;
            foreach(T item in this)
            {
                //if(item.IsDeleted)
                if(item.EntityState == EntityState.Deleted)
                    count += 1;
            }
            return count;
            */
            return DeletedItems.Count;
         }
      }

      /// <summary>
      ///		Returns the number of items that have been marked as modified in the collection.
      /// </summary>
      ///<returns>the number of items that have been marked as modified in the collection</returns>
      public virtual int IsDirtyCount
      {
         get
         {
            int count = 0;
            foreach (T item in this)
            {
               //if(item.IsDirty)
               if (item.EntityState == EntityState.Changed)
                  count += 1;
            }
            return count;
         }
      }

      #region Deleted items

      private List<T> deletedItems;

      /// <summary>
      /// Hold a collection of item that we want to delete. they are removed from the main collection, so the databinding is working.
      /// </summary>
      /// <remark>The save method will loop on this collection to delete item from the datasource.</remark>
      public List<T> DeletedItems
      {
         get
         {
            if (this.deletedItems == null)
            {
               this.deletedItems = new List<T>();
            }
            return this.deletedItems;
         }
      }

      #endregion

      /// <summary>
      /// Performs the specified action on each element of the specified array.
      /// </summary>
      /// <param name="list">The list.</param>
      /// <param name="action">The action.</param>
      public static void ForEach<U>(TList<U> list, Action<U> action) where U : IEntity, new()
      {
         list.ForEach(action);
      }

      #endregion	Added Functionality

      #region Find
    
      ///<summary>
		/// Finds a collection of <see cref="IEntity" /> objects in the current list matching the search criteria.
		///</summary>
		/// <param name="column">Property of the object to search, given as a value of the 'Entity'Columns enum.</param>
		/// <param name="value">Value to find.</param>
		public virtual TList<T> FindAll(System.Enum column, object value)
		{
			return FindAll(column.ToString(), value, true);
		}

      ///<summary>
      /// Finds a collection of <see cref="IEntity" /> objects in the current list matching the search criteria.
      ///</summary>
      /// <param name="column">Property of the object to search, given as a value of the 'Entity'Columns enum.</param>
      /// <param name="value">Value to find.</param>
      /// <param name="ignoreCase">A Boolean indicating a case-sensitive or insensitive comparison (true indicates a case-insensitive comparison).  String properties only.</param>
      public virtual TList<T> FindAll(System.Enum column, object value, bool ignoreCase)
      {
         return FindAll(column.ToString(), value, ignoreCase);
      }

      ///<summary>
		/// Finds a collection of <see cref="IEntity" /> objects in the current list matching the search criteria.
		///</summary>
		/// <param name="propertyName">Property of the object to search.</param>
		/// <param name="value">Value to find.</param>
      public virtual TList<T> FindAll(string propertyName, object value)
      {
         return FindAll(propertyName, value, true);
      }

		///<summary>
		/// Finds a collection of <see cref="IEntity" /> objects in the current list matching the search criteria.
		///</summary>
		/// <param name="propertyName">Property of the object to search.</param>
		/// <param name="value">Value to find.</param>
      /// <param name="ignoreCase">A Boolean indicating a case-sensitive or insensitive comparison (true indicates a case-insensitive comparison).  String properties only.</param>
		public virtual TList<T> FindAll(string propertyName, object value, bool ignoreCase)
		{
			PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(T));
			PropertyDescriptor searchBy = props.Find(propertyName, true);
			
			TList<T> copy = new TList<T>();
			
			int index = 0;
			
			while (index > -1)
			{
				index = this.FindCore(searchBy, value, index, ignoreCase);
				
				if (index > -1)
				{
				   T entity = this[index];
				   if (entity is ICloneable)
				   {
				      copy.Add((T)((ICloneable)entity).Clone());
				   }
				
				   //Increment the index to start at the next item
				   index++;
				}
			}
			
			return copy;		
		}
		
		/// <summary>
		/// Retrieves the all the elements that match the conditions defined by the specified predicate.
		/// </summary>
		/// <param name="match">The <c>Predicate</c> delegate that defines the conditions of the elements to search for.</param>
		/// <returns>A TList containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty TList. </returns>
		public new TList<T> FindAll(Predicate<T> match) 
		{
			TList<T> result = new TList<T>();
			foreach (T item in this.Items)
			{
				if (match(item))
				{
					result.Add(item);
				}
			}
			return result;
		}

      #endregion Find

   }
}