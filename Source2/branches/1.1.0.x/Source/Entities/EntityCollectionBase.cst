<%--
 * $Id: EntityCollectionBase.cst,v 1.8 2006/02/28 15:23:16 jcteague Exp $
 * Last modified by $Author$
 * Last modified at $Date$
 * $Revision$
--%>
<%@ CodeTemplate Src="..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Template description here." %>
<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Context" Description="None" %>
<%@ Property Name="NameSpace" Type="System.String" Category="Style" Description="Root Namespace of the project." %>
<%@ Property Name="UsePartialClass" Type="System.Boolean" Default="true" Category="General" Description="Indicates if partial class should be generated." %>

<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>
	
<%
	string today = DateTime.Now.ToLongDateString();
	string abstractCollectionClassName = UsePartialClass ? GetCollectionClassName(SourceTable.Name) : GetAbstractCollectionClassName(SourceTable.Name);
	string collectionClassName = GetCollectionClassName(SourceTable.Name); 
	string className = GetClassName(SourceTable.Name); 
	string classBaseName = UsePartialClass ? className : GetAbstractClassName(SourceTable.Name);
	string constructorAccessModifier = UsePartialClass ? "public" : "protected";

	
	ColumnSchemaCollection cols = SourceTable.Columns;
	
	ColumnSchemaCollection colsUpdatable = new ColumnSchemaCollection();
	foreach (ColumnSchema column in cols)
	{
		if ( ! IsIdentityColumn(column) && ! IsComputed(column) )
			colsUpdatable.Add(column);
	}
%>
/*
	Code Generated by the "3-Tiers application" templates for CodeSmith.
	http://www.sourceforge.net/projects/cstemplates
	<%=today%>
	Do not modify this file, it will be overwritten at next generation.
*/
#region Using Directives

using System;
using System.Xml.Serialization;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.Reflection;

#endregion

namespace <%=NameSpace%>
{
	///<summary>
	/// This class is a strong typed collection of <see cref="<%=className%>"/> objects that support sorting and binding.
	/// <remarks>
	///		This class provides a strongly-typed implementation of the following classes/interfaces:
	/// 	<list type="bullet">
	/// 		<item><description><see cref="System.Collections.CollectionBase"/></description></item>
	/// 		<item><description><see cref="IComponent"/></description></item>
	/// 		<item><description><see cref="ITypedList"/></description></item>
	/// 		<item><description><see cref="IListSource"/></description></item>
	/// 		<item><description><see cref="IBindingList"/></description></item>
	/// 		<item><description><see cref="ICloneable"/></description></item>
	/// 		<item><description><see cref="ISerializable"/></description></item>
	/// 		<item><description><see cref="IList"/></description></item>
	/// 		<item><description><see cref="IDisposable"/></description></item>
	/// 	</list>
	/// </remarks>
	///</summary>		
	[DesignerCategoryAttribute("code")]
	[ToolboxItem(true)]
	[DesignTimeVisible (true)]	
	[Serializable]
	[CLSCompliant(true)]
	<% if (!UsePartialClass) { %>[EditorBrowsable(EditorBrowsableState.Never)]<% } %>
	public <% if (UsePartialClass) { Response.Write("partial "); } else { Response.Write("abstract "); } %>class <%=abstractCollectionClassName%> : CollectionBase, ISerializable, IBindingList, IList, ICloneable, IListSource, ITypedList, IDisposable, IComponent
	{
		#region Members
		
		//private ArrayList _SortedList = new ArrayList();
		private ArrayList _OriginalList;
		private bool _isSorted = false;
		private PropertyDescriptor _sortby;
		private ListSortDirection _sortDirection = ListSortDirection.Descending;
	
		private readonly string _listName;
		//private PropertyDescriptor _sortProperty;
		private bool _containsListCollection = false;
		private readonly PropertyDescriptorCollection _propertyCollection;
	
		#endregion Members
	
		#region Constructors
		
		/// <summary>
		/// Initializes a new instance of the <see cref="<%=abstractCollectionClassName%>"/> class.
		/// </summary>		
		<%=constructorAccessModifier%> <%=abstractCollectionClassName%> ()
		{			
			// create a filter so we only return the properties that have been designated as bindable
			Attribute[] attrs = new Attribute[] {new BindableAttribute()};
			// get the type information for the next two steps
			Type t = typeof(<%=className%>);
			// save the bindable properties in a local field
			_propertyCollection = TypeDescriptor.GetProperties(t, attrs);
			// save the name of the type for use in the IDE GUI
			_listName = t.Name;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="<%=abstractCollectionClassName%>"/> class.
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
		<%=constructorAccessModifier%> <%=abstractCollectionClassName%> (SerializationInfo info, StreamingContext context) : base()
		{
			#region CollectionBase.list Serialization Workaround
			// WORKAROUND:  RH 3.6.2005 - Saving a strongly typed collection that inherits from CollectionBase
			// has no way to set the private CollectionBase.list ArrayList, so 
			// it would throw an exception.
			// Since the CollectionBase does not play nicely with the inner list 
			// being a readonly property, using reflection to set the property.
			// This is a slight performance hit, but acceptable when dealing with 
			// ViewState in a limited manner.
			FieldInfo field = typeof(CollectionBase).GetField("list", BindingFlags.Instance | BindingFlags.NonPublic);
			field.SetValue(this, (ArrayList)info.GetValue("<%=abstractCollectionClassName%>_InnerList", typeof(ArrayList)));
			
			#endregion
		}
		#endregion
	
		#region ListItem

		private class ListItem : IComparable 
		{
			/// <summary>
			/// The Key of the List Item.
			/// </summary>
			public object Key;
			
			
			/// <summary>
			/// The Item associated with the key.
			/// </summary>
			public object Item;
	
	
			/// <summary>
			/// Creates a new <see cref="ListItem"/> instance.
			/// </summary>
			/// <param name="key">Key.</param>
			/// <param name="item">Item.</param>
			public ListItem(object key, object item)
			{
				Key = key;
				Item = item;
			}
	
	
			///<summary>
			/// Compares the current instance with another object of the same type.
			///</summary>
			///<param name="obj">An object to compare with this instance.</param>
			///<returns>
			/// A 32-bit signed integer that indicates the relative order of the comparands. The return value has these meanings:
			/// <list type="table">
			///    <listheader>
			/// 	  <term>Value</term>
			/// 	  <description>Meaning</description>
			///    </listheader>
			///    <item>
			/// 	  <term>Less than zero</term>
			/// 	  <description>This instance is less than obj.</description>
			///    </item>
			///    <item>
			/// 	  <term>Zero</term>
			/// 	  <description>This instance is equal to obj.</description>
			///    </item>
			///    <item>
			/// 	  <term>Greater than zero</term>
			/// 	  <description>This instance is greater than obj.</description>
			///    </item>
			/// </list>
			///</returns>
			int IComparable.CompareTo(object obj)
			{
				object target = ((ListItem)obj).Key;
				IComparable cmp = Key as IComparable;
	
				if(cmp != null)
				{
					return ((IComparable)Key).CompareTo(target);
				}
				else
				{
					//Debug.WriteLine("No Comparable");
					if (Key == null)
					{
						return -1;
					}
					else if(Key.Equals(target))
					{
						return 0;
					}
					else
					{
						return Key.ToString().CompareTo(target.ToString());
					}
				}
			}
		
	
			///<summary>
			/// Obtains the <see cref="System.String"/> representation of this instance.
			///</summary>
			///<returns>The key of the item.</returns>
			public override string ToString()
			{
				return Key.ToString ();
			}
		}
		#endregion ListItem
	
		#region Find

		///<summary>
		/// Finds the first <see cref="<%=className%>" /> object in the current list matching the search criteria.
		///</summary>
		/// <param name="searchfield">Field of the object to search.</param>
		/// <param name="searchvalue">Value to find.</param>
		public virtual <%=className%> Find(<%=className%>Column searchfield, object searchvalue)
		{
			PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(<%=className%>));
			PropertyDescriptor searchby = null;
			switch(searchfield)
			{
			<%for(int x=0;x < cols.Count;x++) { %>
				case <%=className%>Column.<%=GetPropertyName(cols[x].Name)%>:
					searchby = props["<%=GetPropertyName(cols[x].Name)%>"];
					break;
			<% } %>
			}
			int j = ((IBindingList)this).Find(searchby, searchvalue);
			if (j > -1)
				return this[j];
			else
				return null;
		}
		
		///<summary>
		/// Finds a collection of <see cref="<%=className%>" /> objects in the current list.
		///</summary>
		/// <param name="searchfield">Field of the object to search.</param>
		/// <param name="searchvalue">Value to find.</param>
		public <%=collectionClassName%> FindAll(<%=className%>Column searchfield, object searchvalue)
		{
			PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(<%=className%>));
			PropertyDescriptor searchby = null;
			switch(searchfield)
			{
			<%for(int x=0;x < cols.Count;x++) { %>
				case <%=className%>Column.<%=GetPropertyName(cols[x].Name)%>:
					searchby = props["<%=GetPropertyName(cols[x].Name)%>"];
					break;
			<% } %>
			}
	
			<%=collectionClassName%> copy = new <%=collectionClassName%>();
			foreach(<%=className%> _<%=className%> in this.List)
			{
				if (searchby.GetValue(_<%=className%>).Equals(searchvalue))
				{
					<%=className%> copy<%=className%> = (<%=className%>)MakeCopyOf(_<%=className%>);
					copy.Add(copy<%=className%>);	
				}
			}
			return copy;
		}

		#endregion Find
	
		#region Sort
		
		///<summary>
		/// Sorts the elements in the <%=abstractCollectionClassName%> .
		///</summary>
		private void SortList()
		{
			this._OriginalList = new ArrayList(List);
			
			base.InnerList.Sort( new EntityPropertyComparer(this._sortby.Name));
			if (this._sortDirection == ListSortDirection.Descending) base.InnerList.Reverse();
			
			this._isSorted = true;			

			OnListChanged(new ListChangedEventArgs(ListChangedType.Reset,0));
		}
		
		/// <summary>
		///		Sorts the collection based upon field selected.
		/// </summary>
		/// <param name="field">Field of the object on which to sort.</param>
		/// <param name="direction">Direction to sort in, Ascending or Descending.</param>
		public virtual void Sort(<%=className%>Column field, ListSortDirection direction)
		{
			this._sortby = TypeDescriptor.GetProperties(typeof(<%=className%>)).Find( field.ToString(), false );
			this._sortDirection = direction;
			SortList();
		}	
		
		/// <summary>
		///		Sorts the collection based on primary key.
		/// </summary>
		/// <param name="direction">Direction to sort in, Ascending or Descending.</param>
		public virtual void  Sort(ListSortDirection direction)
		{
			_sortby = null;
			this._sortDirection = direction;
			SortList();
		}
		
		
		/// <summary>
		///		Sorts the collection based on primary key. Sorts in Ascending order.
		/// </summary>
		public virtual void Sort()
		{
			_sortby = null;
			this._sortDirection = ListSortDirection.Ascending;
			SortList();
		}
		
		#endregion Sort
		
		#region Shuffle
		
		/// <summary>
		///		Sorts the collection based on a random shuffle.
		/// </summary>
		/// <author>Steven Smith</author>
		/// <url>http://blogs.aspadvice.com/ssmith/archive/2005/01/27/2480.aspx</url>
		///<remarks></remarks>
		public virtual void Shuffle()
		{
		  ArrayList source = this.InnerList;
		  Random rnd = new Random();
		  for (int inx = source.Count-1; inx > 0; inx--)
		  {
		    int position = rnd.Next(inx+1);
		    object temp = source[inx];
		    source[inx] = source[position];
		    source[position] = temp;
		  }
		}
		#endregion
				
		#region Typed Collection Methods
		
		/// <summary>
		///	Adds a new <see cref="<%=className%>"/> instance to the Collection.
		/// </summary>
		/// <param name="value">The <see cref="<%=className%>"/> instance that is added.</param>
		/// <returns></returns>
		public virtual int Add (<%=className%> value) 
		{
			value.ParentCollection = (<%=collectionClassName%>)this ;
			return List.Add(value);
		}		
		<% if(colsUpdatable.Count > 0) { %>
		
		/// <summary>
		///	Adds a new <see cref="<%=className%>"/> instance to the Collection.
		/// </summary>
		<% for (int x=0; x < colsUpdatable.Count; x++) { %>
		///<param name="<%=GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %>"><%=GetColumnXmlComment(colsUpdatable[x],2)%></param>
		<% } %>
		/// <returns></returns>
		public virtual int Add (<% WrapInit(); for (int x=0; x < colsUpdatable.Count; x++) { %>
					<%= GetCSType(colsUpdatable[x]) %> <%= GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name) %><% WrapIncr(colsUpdatable[x]); if (x < colsUpdatable.Count -1){%>, <% WrapLine(3); } else {%>)<%}%><% }// end for %> 
		{
			return List.Add(<%=NameSpace + "." + className%>.Create<%=className%>(<% for (int x=0; x < colsUpdatable.Count; x++) { %>
						<%Response.Write( GetPrivateName(className) + GetPropertyName(colsUpdatable[x].Name)); %><% if (x < colsUpdatable.Count-1) {%>, <% }} %>));
		}
		<% } %>
					
		
		/// <summary>
		/// Gets or sets the <see cref="<%=className%>"/> at the specified index.
		/// </summary>
		/// <value></value>
		public virtual <%=className%> this[int index] 
		{
			get 
			{
				return (<%=className%>)(List[index]);
			}
			set 
			{
				List[index] = value;
			}
		}
		
		
		/// <summary>
		///	Removes a <see cref="<%=className%>"/> object from the Collection.
		/// </summary>
		/// <param name="value"><%=className%> object.</param>
		public virtual void Remove(<%=className%> value) 
		{
			value.MarkToDelete();
			this.DeletedItems.Add(value);
			InnerList.Remove(value);
			
			//if (! this.IsFiltering )
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, 0));
			//this.RemoveAt(List.IndexOf(value));
		}
		
		#endregion
				
		#region Typed Event Handlers
		
		private ListChangedEventArgs resetEvent = new ListChangedEventArgs(ListChangedType.Reset, -1);
		private ListChangedEventHandler onListChanged;
	
	
		/// <summary>
		/// Raises the ListChanged event.
		/// </summary>
		/// <param name="e">A <see cref="ListChangedEventArgs"/> that contains the event data.</param>
		protected virtual void OnListChanged(ListChangedEventArgs e) 
		{
			ListChangedEventHandler handler = onListChanged;
			if (handler != null) 
			{
				handler(this, e);
			}
		}
	
	
		/// <summary>
		/// Raises the ListChanged event.
		/// </summary>
		protected override void OnClearComplete() 
		{
			if(this._isSorted)
			{
				_OriginalList.Clear();
			}
			
			this.DeletedItems.Clear();
			this.RemoveFilter();
						
			OnListChanged(resetEvent);
		}
	
	
		/// <summary>
		/// Raises the InsertComplete event.
		/// Performs additional custom processes after inserting a new element into the <%=abstractCollectionClassName%> instance.
		/// </summary>
		/// <param name="index">The zero-based index at which to insert value.</param>
		/// <param name="value">The new value of the element at index.</param>
		protected override void OnInsertComplete(int index, object value) 
		{
			if(this._isSorted)
			{
				_OriginalList.Add(value);
			}
			OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
		}
		
		/// <summary>
		/// Raises the RemoveComplete event.
		/// Performs additional custom processes after removing a new element into the <%=abstractCollectionClassName%> instance.
		/// </summary>
		/// <param name="index">The zero-based index at which value can be found.</param>
		/// <param name="value">The value of the element to remove from index.</param>
		protected override void OnRemoveComplete(int index, object value) 
		{
			if(this._isSorted)
			{
				_OriginalList.Remove(value);
			}
			OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
		}
				
		/// <summary>
		/// Raises the SetComplete event.
		/// Performs additional custom processes after setting a value in the <%=abstractCollectionClassName%> instance.
		/// </summary>
		/// <param name="index">The zero-based index at which oldValue can be found.</param>
		/// <param name="oldValue">The value to replace with newValue.</param>
		/// <param name="newValue">The new value of the element at index.</param>
		protected override void OnSetComplete(int index, object oldValue, object newValue) 
		{
			if (oldValue != newValue) 
			{           
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
			}
		}
		
		
		/// <summary>
		/// 	Called by Customer when it changes.
		/// </summary>
		/// <param name="entity">The entity that has changed.</param>
	    internal void EntityChanged(<%=classBaseName%> entity) 
	    {
	        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, List.IndexOf(entity)));
	    }

		
	    #endregion Typed Event Handlers
				
		#region IBindingList
		private bool allowEdit = true;
		private bool allowNew = true;
		private bool allowRemove = true;
		
		///<summary>
		/// Gets whether you can update items in the list.
		///</summary>
		public bool AllowEdit 
		{ 
			get { return this.allowEdit ; }
			set { this.allowEdit = value; }
		}
		
	
		///<summary>
		/// Gets whether you can add items to the list using <see cref="IBindingList.AddNew"/>.
		///</summary>
		public bool AllowNew 
		{ 
			get { return this.allowNew ; }
			set { this.allowNew = value; }
		}
	
	
		///<summary>
		/// Gets whether you can remove items from the list, using <see cref="IList.Remove"/> or <see cref="IList.RemoveAt"/>.
		///</summary>
		public bool AllowRemove 
		{ 
			get { return this.allowRemove ; }
			set { this.allowRemove = value; }
		}
	
	
		///<summary>
		/// Gets whether a <see cref="ListChanged"/> event is raised when the list changes or an item in the list changes.
		///</summary>
		public bool SupportsChangeNotification 
		{ 
			get { return true ; }
		}
	    
	    
		///<summary>
		/// Gets whether the list supports searching using the <see cref="IBindingList.Find"/> method.
		///</summary>
		public bool SupportsSearching 
		{ 
			get { return true ; }
		}
	
		
		///<summary>
		/// Gets whether the list supports sorting.
		///</summary>
		public bool SupportsSorting 
		{ 
			get { return true ; }
		}
		
		
		///<summary>
		/// Gets whether the items in the list are sorted.
		///</summary>
		public bool IsSorted 
		{ 
			get { return this._isSorted; }
		}
	
	
		///<summary>
		/// Gets the direction of the sort.
		///</summary>
		public ListSortDirection SortDirection 
		{ 
			get { return this._sortDirection; }
		}
	
	
		///<summary>
		/// Gets the <see cref="PropertyDescriptor"/> that is being used for sorting.
		///</summary>
		public PropertyDescriptor SortProperty 
		{ 
			get { return _sortby; }
		}
	
		///<summary>
		/// Returns the index of the row that has the given <see cref="PropertyDescriptor"/>.
		///</summary>
		///<param name="property">The <see cref="PropertyDescriptor"/> to search on. </param>
		///<param name="key">The value of the property parameter to search for.</param>
		///<returns>The index of the row that has the given <see cref="PropertyDescriptor"/>.</returns>
		public int Find(PropertyDescriptor property, object key) 
		{
			foreach(<%=className%> _<%=className%> in this.List)
			{
				if (property.GetValue(_<%=className%>).Equals(key))
					return this.List.IndexOf(_<%=className%>);
			}
			return -1;
		}
	
	
		///<summary>
		/// Occurs when the list managed by the <see cref="<%=collectionClassName%>"/> changes.
		///</summary>
		public virtual event ListChangedEventHandler ListChanged 
		{
			add 
			{
				onListChanged += value;
			}
			remove 
			{
				onListChanged -= value;
			}
		}
				
		// Methods.
		
		///<summary>
		/// Adds a new item to the list.
		///</summary>
		///<returns>The item added to the list.</returns>
		object IBindingList.AddNew() 
		{
			<%=className%> c = new <%=className%>();
			this.Add(c);
			return c;
		}
		
		
		///<summary>
		/// Sorts the list based on a <see cref="PropertyDescriptor"/> and a <see cref="ListSortDirection"/>.
		///</summary>
		///<param name="property">The <see cref="PropertyDescriptor"/> to sort by.</param>
		///<param name="direction">One of the <see cref="ListSortDirection"/> values.</param>
		public void ApplySort(PropertyDescriptor property, ListSortDirection direction) 
		{
			_sortby = property;
			this._sortDirection = direction;
			SortList();
		}
		
		
		///<summary>
		/// Removes any sort applied using <see cref="IBindingList.RemoveSort"/>.
		///</summary>		
		public virtual void RemoveSort() 
		{
			if(this._isSorted)
			{
				base.InnerList.Clear();
				foreach(object obj in _OriginalList)
					base.InnerList.Add(obj);
				this._isSorted = false;
				_OriginalList = null; //destroy
				OnListChanged(new ListChangedEventArgs(ListChangedType.Reset,0));
			}
		}
	
		#region Unsupported Methods
		
		///<summary>
		/// Adds the <see cref="PropertyDescriptor"/> to the indexes used for searching.
		///</summary>
		///<param name="property">The <see cref="PropertyDescriptor"/> to add to the indexes used for searching.</param>
		///<remarks>The list must support this method. However, support for this method can be a nonoperation.</remarks>
		///<exception cref="System.NotSupportedException">Thrown</exception>
		public void AddIndex(PropertyDescriptor property) 
		{
			throw new NotSupportedException(); 
		}
		
		///<summary>
		/// Removes the <see cref="PropertyDescriptor"/> from the indexes used for searching.
		///</summary>
		///<param name="property">The <see cref="PropertyDescriptor"/> to remove from the indexes used for searching.</param>
		///<exception cref="System.NotSupportedException">Thrown</exception>
		public void RemoveIndex(PropertyDescriptor property) 
		{
			throw new NotSupportedException(); 
		}
		#endregion Unsupported Methods
	
		#endregion IBindingList
				
		#region ICloneable
		
		///<summary>
		/// Creates an exact copy of this <see cref="<%=collectionClassName%>"/> object.
		///</summary>
		///<returns>The <see cref="<%=collectionClassName%>"/> object this method creates, cast as an object.</returns>
		///<implements><see cref="ICloneable.Clone"/></implements>
		public object Clone(){
			return this.Copy();
		}
		
		
		///<summary>
		/// Creates an exact copy of this <see cref="<%=collectionClassName%>"/> object.
		///</summary>
		///<returns>A new, identical copy of the <see cref="<%=collectionClassName%>"/>.</returns>
		public virtual <%=collectionClassName%> Copy(){
			<%=collectionClassName%> copy = new <%=collectionClassName%>();
			foreach(<%=className%> _<%=className%> in this.List)
			{
				<%=className%> copy<%=className%> = (<%=className%>)MakeCopyOf(_<%=className%>);
				copy.Add(copy<%=className%>);	
			}
			return copy;
		}
		
		
		///<summary>
		/// Creates an exact copy of this <see cref="<%=collectionClassName%>"/> object.
		///</summary>
		///<returns>A new, identical copy of the <see cref="<%=collectionClassName%>"/> casted as object.</returns>
		public static object MakeCopyOf(object x)
		{
			if (x is ICloneable)
			{
				// Return a deep copy of the object
				return ((ICloneable)x).Clone();
			}
			else
			{
				throw new 
					System.NotSupportedException("object not cloneable");
			}
		}
		#endregion ICloneable
		
		#region ISerializable Members
		/// <summary>
		/// Sets the <see cref="SerializationInfo"/> with information about the exception..
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
		/// <Implements>ISerializable.GetObjectData</Implements>
		/// <remarks><c>GetObjectData</c> sets a <see cref="SerializationInfo"/> with all the exception object data targeted for serialization. During deserialization, the exception is reconstituted from the SerializationInfo transmitted over the stream.</remarks>
		[System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("<%=abstractCollectionClassName%>_InnerList", base.InnerList, typeof(ArrayList)) ;
		}
		#endregion ICloneable
		
		// TODO: Review Tony's edits
		#region CollectionBase Members

		/// <summary>
		///     Adds the contents of another collection 
		///     at the end of this instance.
		/// </summary>
		/// <param name="colValue">A collection of <%=className%> to add to the end of the collection.</param>
		/// <exception cref="ArgumentNullException">colValue is null.</exception>
		public void AddRange(<%=abstractCollectionClassName%> colValue)
		{
			if (colValue == null) throw new ArgumentNullException("colValue");
			for (int intCounter = 0; intCounter < colValue.Count; intCounter++)
			{
				this.Add(colValue[intCounter]);
			}
		}

		/// <summary>
		///     Copies the elements of an array of 
		///     collection members to the end of this 
		///     collection.
		/// </summary>
		/// <param name="arrValue">An array of <%=className%> to add to the end of the collection.</param>
		/// <exception cref="ArgumentNullException">arrValue is null.</exception>
		public void AddRange(<%=className%>[] arrValue)
		{
			if (arrValue == null) throw new ArgumentNullException("arrValue");
			for (int intCounter = 0; intCounter < arrValue.Length; intCounter++)
			{
				this.Add(arrValue[intCounter]);
			}
		}
						
		/*
		public void RejectChanges()
		{
			for(int i=this.Count-1; i>=0; i--)
			{
				if (this[i].IsDeleted)
				{
					this[i].RemoveDeleteMark();
				}				
			}
		}
		*/

/*
		/// <summary>
		///     Adds a specified member to the collection.
		/// </summary>
		public int Add(<%=className%> memValue)
		{
			int index = List.Add(memValue);
			return index;
		}
*/

/*
		/// <summary>
		///     Adds a specified member to the collection.
		///		You need this "object" overload for databinding.
		///		Do an explicit cast to validate the type.
		/// </summary>
		public int Add(object memValue)
		{
			return this.Add((<%=className%>)memValue);
		}
*/

/*
		/// <summary>
		///     Represents the member at 
		///     the specified index position.
		/// </summary>
		public <%=className%> this[int intIndex]
		{
			get{ return ((<%=className%>) List[intIndex]); }
			set{ List[intIndex] = value; }
		}
*/

		/// <summary>
		///     Gets a value indicating whether the 
		///     collection contains the specified value.
		/// </summary>
		public bool Contains(<%=className%> memValue)
		{
			return List.Contains(memValue);
		}

		/// <summary>
		///     Copies the collection values 
		///     to a one-dimensional System.Array instance 
		///     starting at the specified array index.
		/// </summary>
		public void CopyTo(<%=className%>[] arrValue, int index)
		{
			List.CopyTo(arrValue, index);
		}

		/// <summary>
		///     Returns the index of a member 
		///     object in the collection.
		/// </summary>
		public int IndexOf(<%=className%> memValue)
		{
			return List.IndexOf(memValue);
		}

		/// <summary>
		///     Inserts an existing member into 
		///     the collection at the specified index.
		/// </summary>
		public void Insert(int index, <%=className%> memValue)
		{
			List.Insert(index, memValue);
		}


		/// <summary>
		///     Removes a specific item from the collection.
		/// </summary>
		public new void RemoveAt(int index)
		{
			this.Remove(this[index]);
		}

		/*  YOU HAVE THESE ELSEWHERE ALREADY
		public override void OnInsertComplete ( int index , object value )
		{
			this.RaiseListChangedEvent(this, new ListChangedEventArgs(ListChangedType.ItemAdded, index));
		}

		public override void OnClearComplete ()
		{
			this.RaiseListChangedEvent(this, new ListChangedEventArgs(ListChangedType.Reset, -1));
		}

		public override void OnRemoveComplete ( int index , object value )
		{
			this.RaiseListChangedEvent(this, new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
		}

		public override void OnSetComplete ( int index , object oldValue, object newValue )
		{
			this.RaiseListChangedEvent(this, new ListChangedEventArgs(ListChangedType.ItemChanged, index));
		}
		*/

		#endregion // CollectionBase
		
		// TODO: Review Tony's edits
		#region IComponent Members
		
		// Added to implement Site property correctly.
		private ISite _site = null;

		/// <summary>
		/// Get / Set the site where this data is located.
		/// </summary>
		public ISite Site
		{
			get{ return _site; }
			set{ _site = value; }
		}

		#endregion //IComponent Members

		// TODO: Review Tony's edits
		#region IDisposable Members
		
		/// <summary>
		/// Notify those that care when we dispose.
		/// </summary>
		public event System.EventHandler Disposed;

		/// <summary>
		/// Clean up. Nothing here though.
		/// </summary>
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}
		
		/// <summary>
		/// Clean up.
		/// </summary>
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				EventHandler handler = Disposed;
				if (handler != null)
					handler(this, EventArgs.Empty);
			}
		}

		/// <summary>
		/// Releases unmanaged resources and performs other cleanup operations before the
		/// <see cref="<%=abstractCollectionClassName%>"/> is reclaimed by garbage collection.
		/// </summary>
		~<%=abstractCollectionClassName%>()
		{
			this.Dispose(false);
		}

		#endregion // IDisposable
		
		// TODO: Review Tony's edits
		#region ITypedList Members
		
		/// <summary>
		/// This member allows binding objects to discover the field/column information.
		/// </summary>
		public PropertyDescriptorCollection 
			GetItemProperties(PropertyDescriptor[] listAccessors)
		{
			return _propertyCollection;
		}

		/// <summary>
		/// This member returns the name displayed in the IDE.
		/// </summary>
		public string GetListName(PropertyDescriptor[] listAccessors)
		{
			return _listName;
		}

		#endregion // ITypedList
		
		// TODO: Review Tony's edits
		#region IListSource Members
		
		/// <summary>
		/// Clean up. Nothing here though.
		/// </summary>
		public IList GetList()
		{
			return this;
		}

		/// <summary>
		/// Return TRUE if our list contains additional/child lists.
		/// </summary>
		public bool ContainsListCollection
		{
			// TODO: Implement nested lists
			get{ return _containsListCollection; }
			set{ _containsListCollection = value; }
		}

		#endregion // IListSource
		
		// TODO: Review Tony's edits
		#region Enumeration Members

		/// <summary>
		/// Returns an enumerator that can be used to iterate
		/// through the 'CollectionBase' collection.
		/// </summary>
		public new <%=abstractCollectionClassName%>Enumerator GetEnumerator()
		{
			return new <%=abstractCollectionClassName%>Enumerator(this);
		}

		/// <summary>
		///     An enumerator for decendants of the CollectionBase class.
		/// </summary>
		public class <%=abstractCollectionClassName%>Enumerator : System.Collections.IEnumerator
		{

			private System.Collections.IEnumerator iEnBaseEnumerator;

			/// <summary>
			///     The enumerator constructor.
			/// </summary>
			public <%=abstractCollectionClassName%>Enumerator(CollectionBase mappings) : base()
			{
				this.iEnBaseEnumerator = ((IEnumerable) mappings).GetEnumerator();
			}

			/// <summary>
			///     Gets the current element from the collection.
			/// </summary>
			public object Current
			{
				get{ return iEnBaseEnumerator.Current; }
			}

			/// <summary>
			///     Advances the enumerator to the next element of the collection
			/// </summary>
			public bool MoveNext()
			{
				return iEnBaseEnumerator.MoveNext();
			}

			/// <summary>
			///     Sets the enumerator to the first element in the collection
			/// </summary>
			public void Reset()
			{
				iEnBaseEnumerator.Reset();
			}
		}

		#endregion // Enumeration Members
		
		#region Added Functionality
		
		/// <summary>
		///		Returns the number of items that have been marked new in the collection.
		/// </summary>
		///<returns>the number of items that have been marked new in the collection</returns>
		public virtual int IsNewCount
		{
			get
			{
				int count = 0;
				foreach(<%=className%> p in this.List)
				{
					if(p.IsNew)
						count += 1;
				}
				return count;
			}
		}
		
		/// <summary>
		///		Returns the number of items that have been marked to delete in the collection.
		/// </summary>
		///<returns>the number of items that have been marked for deletation in the collection</returns>
		public virtual int IsDeletedCount
		{
			get
			{
				int count = 0;
				foreach(<%=className%> p in this.List)
				{
					if(p.IsDeleted)
						count += 1;
				}
				return count;
			}
		}
		
		
		/// <summary>
		///		Returns the number of items that have been marked as modified in the collection.
		/// </summary>
		///<returns>the number of items that have been marked as modified in the collection</returns>
		public virtual int IsDirtyCount
		{
			get
			{
				int count = 0;
				foreach(<%=className%> p in this.List)
				{
					if(p.IsDirty)
						count += 1;
				}
				return count;
			}
		}
		
		#region Deleted items
		
		private System.Collections.ArrayList deletedItems;
		
		/// <summary>
		/// Hold a collection of item that we want to delete. they are removed from the main collection, so the databinding is working.
		/// </summary>
		/// <remark>The save method will loop on this collection to delete item from the datasource.</remark>
		[XmlElement(Type = typeof(<%=className%>))]
		public System.Collections.ArrayList DeletedItems
		{
			get
			{
				if (this.deletedItems == null)
				{
					this.deletedItems = new System.Collections.ArrayList();
				}
				return this.deletedItems;
			}			
		}
				
		#endregion
		
		#endregion	Added Functionality
		
		
		
		#region Filtering
		
		private ArrayList filteredItems = new ArrayList();
		private string filter = string.Empty ;
		
		
		/// <summary>
		/// Indicates if a filter is currently applied to the collection.
		/// </summary>
		public bool IsFiltering
		{
			get {return this.filteredItems.Count > 0;}
		}
		
		/// <summary>
		/// Get the list of currently filtered items.
		/// </summary>
		public ArrayList FilteredItems
		{
			get	{return this.filteredItems;}	
		}
		
		/// <summary>
		/// 
		/// </summary>
		public string ItemFilter
		{
			get
			{
				return filter;
			}
			set
			{
				if (value == this.filter) return ;
								
				this.filter = value;
				
				this.ApplyFilter();
				
				//4-Restauration du rafraichissement auto
				//OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, 0, 0));
				//ListChanged += onListChanged;
			}
		}
		
		/// <summary>
		/// Force the filtering of the collection, based on the filter expression set through the <c cref="ItemFilter"/> property.
		/// </summary>
		public void ApplyFilter()
		{
			// Restore the state without filter
			for (int i=0; i< this.filteredItems.Count; i++)
			{
				this.InnerList.Add(this.filteredItems[i] as <%=className%>);
			}
			
			// Clear the filterd items
			this.filteredItems.Clear();
			
			// Application du filtre si non vide
			if ( this.filter != null & this.filter.Length > 0 )
			{
				Filter MyFilter = new Filter(this.InnerList, this.filteredItems, typeof(<%=className%>), this.filter );
			}
			
			// Send a IBindingList list event
			OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, 0, 0));
		}
		
		/// <summary>
		/// 	Remove the filtering expression.
		/// </summary>
		public void RemoveFilter()
		{
			this.ItemFilter = string.Empty;
		}
								
		#endregion
		
		#region System.Object Overrides
		///<summary>
		/// Returns a String that represents the current <%=collectionClassName%>.
		///</summary>
		public override string ToString()
		{
			string output = string.Format(System.Globalization.CultureInfo.InvariantCulture,
				"There is {0} <%=className%> object in this collection{1}{1}", this.List.Count, Environment.NewLine);
			foreach(<%=className%> p in this.List)
			{
				output += p.ToString();
			}
			return output;
		}
		#endregion System.Object Overrides
		
	}
}
