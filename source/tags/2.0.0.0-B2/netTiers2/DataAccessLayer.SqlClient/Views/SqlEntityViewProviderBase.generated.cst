<%--
 * $Id: SqlEntityViewProviderBase.generated.cst,v 1.3 2006/03/07 09:51:41 jroland Exp $
 * Last modified by $Author$
 * Last modified at $Date$
 * $Revision$
--%>
<%@ CodeTemplate Src="..\..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Template description here." %>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>

<%@ Import Namespace="SchemaExplorer" %>
<%@ Import Namespace="System.Collections" %>

<%@ Property Name="SourceView" Type="SchemaExplorer.ViewSchema" Category="Connection" Description="Table that the data access class should be based on." %>

<%@ Property Name="IncludeCustoms" Type="System.Boolean" Default="True" Category="Options" Description="If true customs stored procedures will be generated as functions." %>
<%@ Property Name="CustomNonMatchingReturnType" Type="CustomNonMatchingReturnType" Default="DataSet" Category="Options" Description="When using custom stored procedures, if the returned rows do not match the fields in an entity, a DataSet or IDataReader will be returned. Choose One.  This is useful if you've returned more than one resultset in a custom procedure; you can use a ConvertToDataSet(IDataReader) method in the Utility class to convert that to a DataSet." %>
<%@ Property Name="CustomProcedureStartsWith" Type="System.String" Default="_{0}_" Category="Options" Description="If you include custom stored procedures, this is the pattern that NetTiers will look for your custom stored procedures. A string format will be used to match the procedure pattern.  So, {0}=TableName, {1}=StoredProc Prefix.  By default NetTiers will look at tables that starts with '_{0}_', which means it will detect the procedure _TableName_GetByBirthdate and will be detected and generated." %>
<%@ Property Name="IncludeGetList" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>
<%@ Property Name="IncludeGetListByIX" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeFind" Type="System.Boolean" Default="False" Category="Options" Description="If true find functions will be generated." %>
<%@ Property Name="SelectSuffix" Type="System.String" Default="_Get" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="SelectAllSuffix" Type="System.String" Default="List" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="FindSuffix" Type="System.String" Default="_Find" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="NameSpace" Type="System.String" Category="Style" Description="Class Namespace." %>
<%@ Property Name="DALNameSpace" Type="System.String" Category="Data" Description="DAL Namespace." %>
<%@ Property Name="ProcedurePrefix" Optional="True" Type="System.String" Category="Style" Description="Prefix for Strored Procedures" %>

<%
	// Name of the table being worked on.
	string name = SourceView.Name;
		
	string className = GetClassName(SourceView.Name);
	string abstractRepositoryClassName = "Sql" + GetProviderBaseName(SourceView.Name);
	string providerName = GetProviderName(SourceView.Name);
	string providerBaseName = "Sql" + GetProviderBaseName(SourceView.Name);
	string collectionClassName = GetViewCollectionClassName(SourceView.Name);
		
	// this array store each Get BY MemberColumns in order to avoid to create doublon Get methods
	System.Collections.ArrayList getbyKeys = new System.Collections.ArrayList();
%>
/*
	File Generated by NetTiers templates [www.nettiers.com]
	Generated on : <%=DateTime.Now.ToLongDateString()%>
	Important: Do not modify this file. Edit the file <%=className%>.cs instead.
*/

#region "Using directives"

using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using Microsoft.Practices.EnterpriseLibrary.Data;
using Microsoft.Practices.EnterpriseLibrary.Data.Sql;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using <%=NameSpace%>;
using <%=DALNameSpace%>.Bases;

#endregion

namespace <%=DALNameSpace%>.SqlClient
{

/// <summary>
///	This class is the base repository for the CRUD operations on the <%=className%> objects.
/// </summary>
public partial class <%=providerBaseName%> : <%=GetProviderBaseName(SourceView.Name)%>
{
	#region "Declarations"	
	
	string _connectionString;
    bool _useStoredProcedure;
    string _providerInvariantName;
    		
	#endregion "Declarations"
		
	#region "Constructors"
	
	/// <summary>
	/// Creates a new <see cref="<%=providerBaseName%>"/> instance.
	/// Uses connection string to connect to datasource.
	/// </summary>
	protected <%=providerBaseName%>()
	{		
	}
	
	/// <summary>
	/// Creates a new <see cref="<%=providerBaseName%>"/> instance.
	/// Uses connection string to connect to datasource.
	/// </summary>
	/// <param name="connectionString">The connection string to the database.</param>
	/// <param name="useStoredProcedure">A boolean value that indicates if we use the stored procedures or embedded queries.</param>
	/// <param name="providerInvariantName">Name of the invariant provider use by the DbProviderFactory.</param>
	public <%=providerBaseName%>(string connectionString, bool useStoredProcedure, string providerInvariantName)
	{
		this._connectionString = connectionString;
		this._useStoredProcedure = useStoredProcedure;
		this._providerInvariantName = providerInvariantName;
	}
			
	#endregion "Constructors"
	
	#region Public properties
	
	#region "Public properties"
	/// <summary>
    /// Gets or sets the connection string.
    /// </summary>
    /// <value>The connection string.</value>
    public string ConnectionString
	{
		get {return this._connectionString;}
		set {this._connectionString = value;}
	}
	
	/// <summary>
    /// Gets or sets a value indicating whether to use stored procedures.
    /// </summary>
    /// <value><c>true</c> if we choose to use use stored procedures; otherwise, <c>false</c>.</value>
	public bool UseStoredProcedure
	{
		get {return this._useStoredProcedure;}
		set {this._useStoredProcedure = value;}
	}
	
	/// <summary>
    /// Gets or sets the invariant provider name listed in the DbProviderFactories machine.config section.
    /// </summary>
    /// <value>The name of the provider invariant.</value>
    public string ProviderInvariantName
    {
        get { return this._providerInvariantName; }
        set { this._providerInvariantName = value; }
    }
	#endregion
		
	#endregion
	
	<%/*	
		-------------------------------
		GET LIST FUNCTIONS
		-------------------------------
	*/%>
<% if (IncludeGetList) { %>
	#region "GetList Functions"
	
	/// <summary>
	/// 	Gets All rows from the DataSource.
	/// </summary>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <remarks></remarks>
	/// <returns>Returns a typed collection of <%=className%> objects.</returns>
	public override <%=collectionClassName%> GetAll(TransactionManager transactionManager, int start, int pageLength)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "<%=ProcedurePrefix + GetCleanName(name) + SelectSuffix + SelectAllSuffix%>", _useStoredProcedure);
		
		IDataReader reader = null;
		//Create Collection
		<%=collectionClassName%> rows = new <%=collectionClassName%>();
		try
		{
			if (transactionManager != null)
			{
				reader = Utility.ExecuteReader(transactionManager, commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}
		
			Fill(reader, rows, start, pageLength);
		}
		finally {	if (reader != null) reader.Close();	}
		
		return rows;
	}//end getall
	
	#endregion
	
	#region "Get filterd and sorted"
			
	/// <summary>
	/// Gets a page of rows from the DataSource.
	/// </summary>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
	/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <remarks></remarks>
	/// <returns>Returns a typed collection of <%=className%> objects.</returns>
	public override <%=collectionClassName%> Get(TransactionManager transactionManager, string whereClause, string orderBy, int start, int pageLength)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "<%=ProcedurePrefix + GetCleanName(name) + SelectSuffix%>", _useStoredProcedure);

		//commandWrapper.AddInParameter("@PageIndex", DbType.Int32, start);
		//commandWrapper.AddInParameter("@PageSize", DbType.Int32, pageLength);
		database.AddInParameter(commandWrapper, "@WhereClause", DbType.String, whereClause);
		database.AddInParameter(commandWrapper, "@OrderBy", DbType.String, orderBy);
	
		IDataReader reader = null;
		//Create Collection
		<%=collectionClassName%> rows = new <%=collectionClassName%>();	
		try
		{
			if (transactionManager != null)
			{
				reader = Utility.ExecuteReader(transactionManager,commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}


			//reader.Read();
			//count = reader.GetInt32(0);
			//reader.NextResult();
	
			Fill(reader, rows, start, pageLength);
		}
		finally
		{
		     if (reader != null)
		     	 reader.Close();
		}
		return rows;
	}
	
	#endregion
	
<%
 	} //end IncludeGetList
%>
<%/*---------------------------------------------------------------------------------
							CUSTOM STORED PROCEDURES
  -------------------------------------------------------------------------------*/%>

<% if (IncludeCustoms) { %>
	#region "Custom Methods"
	
<% 
	string prefix = string.Format(CustomProcedureStartsWith, SourceView.Name, ProcedurePrefix);
	foreach(CommandSchema command in SourceView.Database.Commands)
	{
		//Response.WriteLine("// " + command.Name);
	
		// If the stored procedure is targeting the current table.
		if (command.Name.StartsWith(prefix))
		{
			string methodName = command.Name.Substring(prefix.Length);
			string returnType = "void";
						
			if (IsMatching(command, SourceView))
			{
				returnType = collectionClassName;
			}
			else	// Return user selected type
			{
				returnType =  CustomNonMatchingReturnType.ToString();
			}
			
			string returnTypeForComment = returnType.Replace("<", "&lt;").Replace(">", "&gt;");
%>
	#region "<%=command.Name%>"
	
	/// <summary>
	///	This method wrap the '<%=command.Name%>' stored procedure. 
	/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters)%>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <remark>This method is generate from a stored procedure.</remark>
	/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns>
	public override <%=returnType%> <%=methodName%>(TransactionManager transactionManager, int start, int pageLength <%=TransformStoredProcedureInputsToMethod(true, command.InputParameters)%>)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = database.GetStoredProcCommand("<%=command.Name%>");
		
		<% foreach(ParameterSchema col in command.InputParameters)	{ %>
		database.AddInParameter(commandWrapper, "@<%=GetPropertyName(col.Name)%>", <%=GetDbType(col)%>,  <%=GetPrivateName(col.Name)%> );
		<%}%>

		try
		{
			<% if (returnType == "DataSet") { %>
			DataSet ds = null;
			
			if (transactionManager != null)
			{	
				ds = database.ExecuteDataSet(commandWrapper, transactionManager.TransactionObject);
			}
			else
			{
				ds = database.ExecuteDataSet(commandWrapper);
			}
			return ds;	
			<% } else if (returnType == "IDataReader") { %>
			IDataReader dr = null;
			
			if (transactionManager != null)
			{	
				dr = Utility.ExecuteReader(transactionManager,commandWrapper);
			}
			else
			{
				dr = Utility.ExecuteReader(database, commandWrapper);
			}
			return dr;
			<% } else if (returnType == "void") { %>
			if (transactionManager != null)
			{	
				Utility.ExecuteNonQuery(commandWrapper, transactionManager.TransactionObject);
			}
			else
			{
				Utility.ExecuteNonQuery(database, commandWrapper);
			}
			return;
			<% } else if 	(returnType == collectionClassName) { %>
			IDataReader reader = null;

			if (transactionManager != null)
			{	
				reader = Utility.ExecuteReader(transactionManager, commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}			
			
			//Create Collection
			<% if (returnType == collectionClassName) {%>
				<%=collectionClassName%> rows = new <%=collectionClassName%>();
				try
				{    
					Fill(reader, rows, start, pageLength);
				}
				finally
				{
					if (reader != null) 
						reader.Close();
				}
				return rows;
				<%} else if (returnType != "void"){%>
				<%=returnType%> tmp = null;
				try
				{
					reader.Read();
					tmp = (<%=returnType%>)reader[0];
				}finally {reader.Close();}
				return tmp;
				<% } %>		
			<% } %>
		}
		catch(SqlException ex)
		{
			throw new DataException("An data access error occured, please check inner SqlException.", ex);
		}
	}
	#endregion
<%
		}
	}
%>

	#endregion
<% } // endif IncludeCustoms %>
	}//end class
} // end namespace
