<%@ CodeTemplate Src="..\..\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="" Debug="True"  ResponseEncoding="UTF-8"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Connection" Description="Tables of the system." %>
<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Connection" Description="Table that the data access class should be based on." %>
	
<%@ Property Name="IncludeCustoms" Type="System.Boolean" Default="True" Category="Options" Description="If true customs stored procedures will be generated as functions." %>
<%@ Property Name="CustomNonMatchingReturnType" Type="CustomNonMatchingReturnType" Default="DataSet" Category="Options" Description="When using custom stored procedures, if the returned rows do not match the fields in an entity, a DataSet or IDataReader will be returned. Choose One.  This is useful if you've returned more than one resultset in a custom procedure; you can use a ConvertToDataSet(IDataReader) method in the Utility class to convert that to a DataSet." %>
<%@ Property Name="CustomProcedureStartsWith" Type="System.String" Default="_{0}_" Category="Options" Description="If you include custom stored procedures, this is the pattern that NetTiers will look for your custom stored procedures. A string format will be used to match the procedure pattern.  So, {0}=TableName, {1}=StoredProc Prefix.  By default NetTiers will look at tables that starts with '_{0}_', which means it will detect the procedure _TableName_GetByBirthdate and will be detected and generated." %>
<%@ Property Name="ProcedurePrefix" Optional="True" Type="System.String" Category="Style" Description="Prefix for Strored Procedures" %>
<%@ Property Name="IncludeInsert" Type="System.Boolean" Default="True" Category="Options" Description="If true insert functions will be generated." %>
<%@ Property Name="IncludeUpdate" Type="System.Boolean" Default="True" Category="Options" Description="If true update functions will be generated." %>
<%@ Property Name="IncludeSave" Type="System.Boolean" Default="True" Category="Options" Description="If true combined insert/update functions will be generated." %>
<%@ Property Name="IncludeDelete" Type="System.Boolean" Default="True" Category="Options" Description="If true delete functions will be generated." %>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="False" Category="Options" Description="If true select statements will be generated for any many to many relationship." %>
<%@ Property Name="IncludeGetList" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>
<%@ Property Name="IncludeGetListByIX" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeFind" Type="System.Boolean" Default="True" Category="Options" Description="If true find functions will be generated." %>
<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="True" Category="Options" Description="If true DeepSave/Load will have a collection to fill.  There's still a requirement for IncludeByFk && IncludeSave" %>

<%@ Property Name="NameSpace" Type="System.String" Category="Style" Description="Root Namespace." %>
<%@ Property Name="DALNameSpace" Type="System.String" Category="Data" Description="DAL Namespace." %>

<%
	// Name of the table being worked on.
	string name = SourceTable.Name;
	
	// Collection of all columns in the table.
	ColumnSchemaCollection cols = SourceTable.Columns;
	
	// Collection of all columns in the table that are not primary keys.
	ColumnSchemaCollection nonKeys = SourceTable.NonPrimaryKeyColumns;
	
	// Collection of all primary key columns.
	//ColumnSchemaCollection keys = SourceTable.PrimaryKey.MemberColumns; 
	
	// Collection of ForeignKeys. Provides information about the foreign keys 
	//(keys where the current table is the foreign table) contained in the table. 
	TableKeySchemaCollection fkeys = SourceTable.ForeignKeys;
	
	//Provides information about the primary keys 
	//(keys where the current table is the primary table) contained in the table. 
	TableKeySchemaCollection pkeys = SourceTable.PrimaryKeys;
	
	//Provides information about the indexes contained in the table. 
	IndexSchemaCollection indexes = SourceTable.Indexes;
		
	string className = NameSpace + "." + GetClassName(SourceTable.Name);
	string collectionClassName = NameSpace + "." + GetCollectionClassName(SourceTable.Name);
	string collectionClassNameForComment = collectionClassName.Replace("<", "&lt;").Replace(">", "&gt;");
	string baseProviderName = GetProviderBaseName(SourceTable.Name);
	string iProviderName = GetIProviderName(SourceTable.Name);
	
	ColumnSchema RowVersion = null;
	
	foreach(ColumnSchema column in SourceTable.Columns)
	{
		if (column.NativeType.ToLower() == "timestamp")
		{
			RowVersion = column;
		}
	}
	
	

// this array store each Get BY MemberColumns in order to avoid to create doublon Get methods
System.Collections.ArrayList getbyKeys = new System.Collections.ArrayList();

%>
#region Using directives

using System;
using System.Data;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;

using System.Diagnostics;
using <%=NameSpace%>;
using <%=DALNameSpace%>;

#endregion

namespace <%=DALNameSpace%>.Bases
{	
	///<summary>
	/// This class is the base class for any <see cref="<%=baseProviderName%>"/> implementation.
	/// It exposes CRUD methods as well as selecting on index, foreign keys and custom stored procedures.
	///</summary>
	public abstract partial class <%=baseProviderName%>Core
	{		
		
		<% if(IncludeManyToMany) { %>
		#region Get from Many To Many Relationship Functions
		<%
		TableSchema primaryTable = SourceTable;
		
		foreach(TableKeySchema key in SourceTable.PrimaryKeys)
		{
			// Check that the key is related to a junction table
			if ( IsJunctionTable(key.ForeignKeyTable) && IsJunctionKey(key))
			{
				TableSchema junctionTable = key.ForeignKeyTable;
				
				// Search for the other(s) key(s) of the junction table' primary key
				foreach(TableKeySchema junctionTableKey in junctionTable.ForeignKeys)
				{				
					if ( IsJunctionKey(junctionTableKey) && junctionTableKey.Name != key.Name )
					{
						TableSchema secondaryTable = junctionTableKey.PrimaryKeyTable;
						string functionname = GetManyToManyName(junctionTableKey, GetCleanName(junctionTable.Name));
%>
		#region GetBy<%=functionname%>
		
		/// <summary>
		///		Gets <%=primaryTable.Name%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
	<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
	<% } %>	
		/// <returns>Returns a typed collection of <%=GetClassName(primaryTable.Name)%> objects.</returns>
		public <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(<%=GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns)%>)
		{
			int count = -1;
			return GetBy<%=functionname%>(null,<%=GetFunctionCallParameters(junctionTableKey.ForeignKeyMemberColumns)%>, 0, int.MaxValue, out count);
			
		}
		
		/// <summary>
		///		Gets <%=className%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
	<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=GetClassName(primaryTable.Name)%> objects.</returns>
		public <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(<%= GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns) %>, int start, int pageLength)
		{
			int count = -1;
			return GetBy<%=functionname%>(null, <%= GetFunctionCallParameters(junctionTableKey.ForeignKeyMemberColumns) %>, start, pageLength, out count);
		}
		
		/// <summary>
		///		Gets <%=GetClassName(primaryTable.Name)%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=primaryTable.Name%> objects.</returns>
		public <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns) %>)
		{
			int count = -1;
			return GetBy<%=functionname%>(transactionManager, <%= GetFunctionCallParameters(junctionTableKey.ForeignKeyMemberColumns) %>, 0, int.MaxValue, out count);
		}
		
		
		/// <summary>
		///		Gets <%=GetClassName(primaryTable.Name)%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		///  <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=primaryTable.Name%> objects.</returns>
		public <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns) %>,int start, int pageLength)
		{
			int count = -1;
			return GetBy<%=functionname%>(transactionManager, <%= GetFunctionCallParameters(junctionTableKey.ForeignKeyMemberColumns) %>, start, pageLength, out count);
		}
		
		/// <summary>
		///		Gets <%=GetClassName(primaryTable.Name)%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
	<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		///  <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=primaryTable.Name%> objects.</returns>
		public <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(<%= GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns) %>,int start, int pageLength, out int count)
		{
			
			return GetBy<%=functionname%>(null, <%= GetFunctionCallParameters(junctionTableKey.ForeignKeyMemberColumns) %>, start, pageLength, out count);
		}


		/// <summary>
		///		Gets <%=primaryTable.Name%> objects from the datasource by <%=junctionTableKey.ForeignKeyMemberColumns[0].Name%> in the
		///		<%=junctionTable.Name%> table. Table <%=primaryTable.Name%> is related to table <%=secondaryTable.Name%>
		///		through the (M:N) relationship defined in the <%=junctionTable.Name%> table.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
<% for (int i = 0; i < junctionTableKey.ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(junctionTableKey.ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(junctionTableKey.ForeignKeyMemberColumns[i],2)%></param>
<% } %>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=GetClassName(primaryTable.Name)%> objects.</returns>
		public abstract <%=GetCollectionClassName(primaryTable.Name)%> GetBy<%=functionname%>(TransactionManager transactionManager,<%=GetFunctionHeaderParameters(junctionTableKey.ForeignKeyMemberColumns)%>, int start, int pageLength, out int count);
		
		#endregion GetBy<%=functionname%>
		
					<%
					} //end if there is many to many relationship.
				} //end foreach			
		 	}// end if(IsJunctionTable(junctionTableKey.ForeignKeyTable)) %>
		<%}//end foreach pkey %>
		#endregion	
		
		<%} //endif(IncludeManyToMany) %>
		<% if (IncludeDelete && SourceTable.PrimaryKey != null) {%>
		#region Delete Functions
			
		/// <summary>
		/// 	Deletes rows from the DataSource.
		/// </summary>
		/// <param name="entityCollection"><%=collectionClassNameForComment%> containing data.</param>
		/// <remarks>Deletes <%=className%>s only when IsDeleted equals true.</remarks>
		/// <returns>Returns the number of successful delete.</returns>
		public int Delete(<%=collectionClassName%> entityCollection)
		{
			int number = 0;
			foreach (<%=className%> entity in entityCollection)
			{
				if( Delete(entity) )
				{
					number++;
				}
			}
			return number;
		}
			
		/// <summary>
		/// 	Deletes a row from the DataSource.
		/// </summary>
		/// <param name="entity"><%=className%> object containing data.</param>
		/// <remarks>Deletes based on primary key(s).</remarks>
		/// <returns>Returns true if operation suceeded.</returns>
		public bool Delete(<%=className%> entity)
		{
			return Delete(<% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>entity.<%if( !IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !IsComputed(SourceTable.PrimaryKey.MemberColumns[i])) {%>Original<%}%><%= GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%><% if (i < SourceTable.PrimaryKey.MemberColumns.Count - 1) { %>, <% } %><% } %><% if(RowVersion != null) {Response.Write(", entity." + GetPropertyName(RowVersion.Name));}%>);	
		}
		
		/// <summary>
		/// 	Deletes a row from the DataSource.
		/// </summary>
		<% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>"><%=GetColumnXmlComment(SourceTable.PrimaryKey.MemberColumns[i],2)%>. Primary Key.</param>
		<% } %>
		<% if (RowVersion != null){ %>
		/// <param name="<%=GetPrivateName(RowVersion.Name)%>">The timestamp field used for concurrency check.</param>
		<% } %>
		/// <remarks>Deletes based on primary key(s).</remarks>
		/// <returns>Returns true if operation suceeded.</returns>
		public bool Delete(<%= GetFunctionHeaderParameters(SourceTable.PrimaryKey.MemberColumns) %><% if(RowVersion != null) {Response.Write(", byte[] " + GetPrivateName(RowVersion.Name));}%>)
		{
			return Delete(null, <%= GetFunctionCallParameters(SourceTable.PrimaryKey.MemberColumns) %><% if(RowVersion != null) {Response.Write(", " + GetPrivateName(RowVersion.Name));}%>);
		}
			
		/// <summary>
		/// 	Deletes a rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection"><%=collectionClassNameForComment%> containing data.</param>
		/// <remarks>Deletes <%=className%>s only when IsDeleted equals true.</remarks>
		/// <returns>Returns the number of successful delete.</returns>
		public int Delete(TransactionManager transactionManager, <%=collectionClassName%> entityCollection)
		{
			int number = 0;
			foreach (<%=className%> entity in entityCollection)
			{
				if ( Delete(transactionManager, entity) )
				{
					number++;
				}
			}
			return number;
		}
		
		/// <summary>
		/// 	Deletes a row from the DataSource.
		/// </summary>
		/// <param name="entity"><%=className%> object containing data.</param>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <remarks>Deletes based on primary key(s).</remarks>
		/// <returns>Returns true if operation suceeded.</returns>
		public bool Delete(TransactionManager transactionManager, <%=className%> entity)
		{
			return Delete(transactionManager, <% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>entity.<%if(!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !IsComputed(SourceTable.PrimaryKey.MemberColumns[i])) {%>Original<%}%><%= GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%><% if (i < SourceTable.PrimaryKey.MemberColumns.Count - 1) { %>, <% } %><% } %><% if(RowVersion != null) {Response.Write(", entity." + GetPropertyName(RowVersion.Name));}%>);	
		}		
		
		/// <summary>
		/// 	Deletes a row from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		<% for (int i = 0; i < SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>"><%=GetColumnXmlComment(SourceTable.PrimaryKey.MemberColumns[i],2)%>. Primary Key.</param>
		<% } %>
		<% if (RowVersion != null){ %>
		/// <param name="<%=GetPrivateName(RowVersion.Name)%>">The timestamp field used for concurrency check.</param>
		<% } %>
		/// <remarks>Deletes based on primary key(s).</remarks>
		/// <returns>Returns true if operation suceeded.</returns>
		public abstract bool Delete(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(SourceTable.PrimaryKey.MemberColumns) %><% if(RowVersion != null) {Response.Write(", byte[] " + GetPrivateName(RowVersion.Name));}%>);
		
		#endregion
		
		<% } //endif(includedelete) %>
		<% if (IncludeFind) { %>
		#region Find Functions
		
		/// <summary>
		/// 	Returns rows meeting the whereclause condition from the DataSource.
		/// </summary>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> Find(string whereClause)
		{
			int count = -1;
			return Find(null,whereClause, 0, int.MaxValue, out count);
		}	
		
		/// <summary>
		/// 	Returns rows meeting the whereclause condition from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> Find(string whereClause, int start, int pageLength)
		{
			int count = -1;
			return Find(null, whereClause, start, pageLength, out count);
		}
		
		/// <summary>
		/// 	Returns rows meeting the whereclause condition from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> Find(TransactionManager transactionManager, string whereClause)
		{
			int count = -1;
			return Find(transactionManager, whereClause, 0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Returns rows meeting the whereclause condition from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> Find(TransactionManager transactionManager, string whereClause, out int count)
		{
			return Find(transactionManager, whereClause, 0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Returns rows meeting the whereclause condition from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks>Operators must be capitalized (OR, AND)</remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public abstract <%=collectionClassName%> Find(TransactionManager transactionManager, string whereClause, int start, int pageLength, out int count);
		
		#endregion "Find Functions"
		
		<% } //endif (IncludeFind) %>
		<% if (IncludeGetList) { %>
		#region GetList Functions
		
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetAll()
		{
			int count = -1;
			return GetAll(0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetAll(int start, int pageLength)
		{	
			int count = -1;
			return GetAll(null, start, pageLength, out count);
		}
					
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetAll(TransactionManager transactionManager)
		{
			int count = -1;
			return GetAll(transactionManager, 0,int.MaxValue, out count);
		}
		
		
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetAll(TransactionManager transactionManager, int start, int pageLength)
		{	
			int count = -1;
			return GetAll(transactionManager, start, pageLength, out count);
		}
		
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetAll(int start, int pageLength, out int count)
		{	
			return GetAll(null, start, pageLength, out count);
		}
		
		
		
		/// <summary>
		/// 	Gets All rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public abstract <%=collectionClassName%> GetAll(TransactionManager transactionManager, int start, int pageLength, out int count);
		
		#endregion
		
		#region Paged Recordset
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged()
		{
			int count = -1;
			return GetPaged(null, null, 0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(int start, int pageLength, out int count)
		{
			return GetPaged(null, null, start, pageLength, out count);
		}
		
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(int start, int pageLength)
		{
			int count = -1;
			return GetPaged(null, null, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(string whereClause, string orderBy, int start, int pageLength, out int count)
		{
			return GetPaged(null, whereClause, orderBy, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(string whereClause, string orderBy, int start, int pageLength)
		{
			int count = -1;
			return GetPaged(null, whereClause, orderBy, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(TransactionManager transactionManager, string whereClause, string orderBy, int start, int pageLength)
		{
			int count = -1;
			return GetPaged(transactionManager, whereClause, orderBy, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(TransactionManager transactionManager, int start, int pageLength)
		{
			int count = -1;
			return GetPaged(transactionManager, null, null, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetPaged(TransactionManager transactionManager, int start, int pageLength, out int count)
		{
			return GetPaged(transactionManager, null, null, start, pageLength, out count);
		}
		
		/// <summary>
		/// Gets a page of rows from the DataSource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="whereClause">.</param>
		/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">Number of rows in the DataSource.</param>
		/// <remarks></remarks>
		/// <returns>Returns a TList of <%=className%> objects.</returns>
		public abstract <%=collectionClassName%> GetPaged(TransactionManager transactionManager, string whereClause, string orderBy, int start, int pageLength, out int count);
		
		/// <summary>
        /// Gets a page of rows from the DataSource.
        /// </summary>
        /// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
        /// <param name="count">Number of rows in the DataSource.</param>
        /// <remarks></remarks>
        /// <returns>Returns an int indicating the total number of records that would be returned by an equivalent GetPaged call.</returns>
        public int GetTotalItems(string whereClause, out int count)
        {
            GetPaged(null, whereClause, "", 0, 0, out count);
            return count;
        }
		
		#endregion
			
		<% } //endif (IncludeGetList) %>
		<% if (IncludeGetListByFK) { %>
		#region Get By Foreign Key Functions
		<%
			for (int j=0; j < fkeys.Count;j++)
			{
				bool skipkey = false;
				foreach(IndexSchema i in indexes)
				{
					//if(i.MemberColumns.Contains(fkeys[j].ForeignKeyMemberColumns[0]))
					//	skipkey = true;
					if(i.MemberColumns.Equals(fkeys[j].ForeignKeyMemberColumns))
						skipkey = true;	
				}
				if(skipkey)
					continue;
					
				getbyKeys.Add(GetKeysName(fkeys[j].ForeignKeyMemberColumns));
		%>	
	
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=fkeys[j].Name%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(<%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns) %>)
		{
			int count = -1;
			return GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(<%= GetFunctionCallParameters(fkeys[j].ForeignKeyMemberColumns) %>, 0,int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=fkeys[j].Name%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		/// <remarks></remarks>
		public <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns) %>)
		{
			int count = -1;
			return GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(transactionManager, <%= GetFunctionCallParameters(fkeys[j].ForeignKeyMemberColumns) %>, 0, int.MaxValue, out count);
		}
		
			/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=fkeys[j].Name%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		///  <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns) %>, int start, int pageLength)
		{
			int count = -1;
			return GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(transactionManager, <%= GetFunctionCallParameters(fkeys[j].ForeignKeyMemberColumns) %>, start, pageLength, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=GetPrivateName(fkeys[j].Name)%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(<%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns)%>, int start, int pageLength)
		{
			int count =  -1;
			return GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(null, <%= GetFunctionCallParameters(fkeys[j].ForeignKeyMemberColumns) %>, start, pageLength,out count);	
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=GetPrivateName(fkeys[j].Name)%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks></remarks>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(<%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns)%>, int start, int pageLength,out int count)
		{
			return GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(null, <%= GetFunctionCallParameters(fkeys[j].ForeignKeyMemberColumns) %>, start, pageLength, out count);	
		}
						
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=fkeys[j].Name%> key.
		///		<%=fkeys[j].Name%> Description: <%=GetColumnXmlComment(fkeys[j],2)%>
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < fkeys[j].ForeignKeyMemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(fkeys[j].ForeignKeyMemberColumns[i].Name)%>"><%=GetColumnXmlComment(fkeys[j].ForeignKeyMemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">The total number of records.</param>
		/// <returns>Returns a typed collection of <%=className%> objects.</returns>
		public abstract <%=collectionClassName%> GetBy<%=GetKeysName(fkeys[j].ForeignKeyMemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(fkeys[j].ForeignKeyMemberColumns) %>, int start, int pageLength, out int count);
		
	<% 		}//endfor %>
		#endregion

	<% 	} //endif (IncludeGetListByFK) %>
	<% if (IncludeGetListByIX) { %>	
		#region Get By Index Functions
		<%	
			for (int j=0; j < indexes.Count;j++)
			{
				//if(indexes[j].IsPrimaryKey)
					//continue;
				
				// Check if this key is not already generated
				if(getbyKeys.IndexOf(GetKeysName(indexes[j].MemberColumns)) >=0 )
				{
					continue;
				}
				else
				{
					// add this key to the index list
					getbyKeys.Add(GetKeysName(indexes[j].MemberColumns));
				}
				
				string returnType = collectionClassName;
				bool isUnique = false;
				
				//if (IsPrimaryKey(indexes[j]))
				if (indexes[j].IsUnique || indexes[j].IsPrimaryKey)
				{
					returnType = className;
					isUnique = true;
				}
				%>
		
		/// <summary>
		/// 	Gets rows from the datasource based on the primary key <%=indexes[j].Name%> index.
		/// </summary>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public <%= returnType %> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(<%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>)
		{
			int count = -1;
			return GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(null,<%= GetFunctionCallParameters(indexes[j].MemberColumns) %>, 0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=indexes[j].Name%> index.
		/// </summary>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public <%=returnType%> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(<%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>, int start, int pageLength)
		{
			int count = -1;
			return GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(null, <%= GetFunctionCallParameters(indexes[j].MemberColumns) %>, start, pageLength, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=indexes[j].Name%> index.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <remarks></remarks>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public <%=returnType%> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>)
		{
			int count = -1;
			return GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(transactionManager, <%= GetFunctionCallParameters(indexes[j].MemberColumns) %>, 0, int.MaxValue, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=indexes[j].Name%> index.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remarks></remarks>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public <%=returnType%> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>, int start, int pageLength)
		{
			int count = -1;
			return GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(transactionManager, <%= GetFunctionCallParameters(indexes[j].MemberColumns) %>, start, pageLength, out count);
		}
		
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=indexes[j].Name%> index.
		/// </summary>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">out parameter to get total records for query</param>
		/// <remarks></remarks>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public <%=returnType%> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(<%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>, int start, int pageLength, out int count)
		{
			return GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(null, <%= GetFunctionCallParameters(indexes[j].MemberColumns) %>, start, pageLength, out count);
		}
		
				
		/// <summary>
		/// 	Gets rows from the datasource based on the <%=indexes[j].Name%> index.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	<% for (int i = 0; i < indexes[j].MemberColumns.Count; i++) { %>
		/// <param name="<%= GetPrivateName(indexes[j].MemberColumns[i].Name)%>"><%=GetColumnXmlComment(indexes[j].MemberColumns[i],2)%></param>
	<% } %>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="count">The total number of records.</param>
		/// <returns>Returns an instance of the <see cref="<%=returnType.Replace("<", "&lt;").Replace(">", "&gt;")%>"/> class.</returns>
		public abstract <%=returnType%> GetBy<%=GetKeysName(indexes[j].MemberColumns)%>(TransactionManager transactionManager, <%= GetFunctionHeaderParameters(indexes[j].MemberColumns) %>, int start, int pageLength, out int count);
						
	<%		}//endfor %>
		#endregion "Get By Index Functions"
	
	<%	}//end if includegetlistbyix %>
	<% if (IncludeInsert) { %>
		#region Insert Functions
		
		/// <summary>
		/// 	Inserts a <see cref="<%=className%>"/> object into the datasource.
		/// </summary>
		/// <param name="entity">The <see cref="<%=className%>"/> object to insert.</param>
		/// <remarks>
		/// 	After inserting into the datasource, the <see cref="<%=className%>"/> object will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public bool Insert(<%=className%> entity)
		{
			return Insert(null, entity);
		}	
		
		/// <summary>
		/// 	Insert rows in the datasource.
		/// </summary>
		/// <param name="entityCollection">TList of <c><%=className%></c> objects.</param>
		/// <remarks>
		///		This function will only insert entity objects marked as dirty
		///		and have an identity field equal to zero.
		///		Upon inserting the objects, each dirty object will have the public
		///		method <c>Object.AcceptChanges()</c> called to make it clean.
		/// 	After inserting into the datasource, the <c><%=className%></c> objects will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///</remarks>
		/// <returns>Returns the number of successful insert.</returns>
		public int Insert(<%=collectionClassName%> entityCollection)
		{
			return Insert(null, entityCollection);
		}
		
		/// <summary>
		/// 	Insert rows in the datasource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection"><c><%=className%></c> objects in a <%=collectionClassNameForComment%> object to insert.</param>
		/// <remarks>
		///		This function will only insert entity objects marked as dirty
		///		and have an identity field equal to zero.
		///		Upon inserting the objects, each dirty object will have the public
		///		method <c>Object.AcceptChanges()</c> called to make it clean.
		/// 	After inserting into the datasource, the <c><%=className%></c> objects will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///	</remarks>
		/// <returns>Returns the number of successful insert.</returns>
		public int Insert(TransactionManager transactionManager, <%=collectionClassName%> entityCollection)
		{
			int number = 0;
			foreach (<%=className%> entity in entityCollection)
			{
				//if (entity.IsNew)
				if (entity.EntityState == EntityState.Added)
				{
					if (Insert(transactionManager, entity) )
					{
						number++;
					}
				}
			}
			return number;
		}
		
		/// <summary>
		/// Lets you efficiently bulk many entity to the database.
		/// </summary>
		/// <param name="entities">The entities.</param>
		/// <remarks>
		///		After inserting into the datasource, the <%=className%> object will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>	
		public void BulkInsert(TList<<%=className%>> entities)
		{
			BulkInsert(null, entities);
		}
	
		/// <summary>
		/// Lets you efficiently bulk many entity to the database.
		/// </summary>
		/// <param name="transactionManager">The transaction manager.</param>
		/// <param name="entities">The entities.</param>
		/// <remarks>
		///		After inserting into the datasource, the <%=className%> object will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>	
		public abstract void BulkInsert(TransactionManager transactionManager, TList<<%=className%>> entities);
	
		/// <summary>
		/// 	Inserts a <%=className%> object into the datasource using a transaction.
		/// </summary>
		/// <param name="entity"><%=className%> object to insert.</param>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <remarks>After inserting into the datasource, the <%=className%> object will be updated
		/// to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public abstract bool Insert(TransactionManager transactionManager, <%=className%> entity);
		
		#endregion

	<%	}//endif (IncludeInsert) %>
	<% if (IncludeUpdate) { %>	
		#region Update Functions
		
		/// <summary>
		/// 	Update existing rows in the datasource.
		/// </summary>
		/// <param name="entityCollection">TList of <c><%=className%></c> objects.</param>
		/// <remarks>
		///		This function will only update entity objects marked as dirty
		///		and do not have an primary key value of 0.
		///		Upon updating the objects, each dirty object will have the public
		///		method <c>Object.AcceptChanges()</c> called to make it clean.
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///</remarks>
		/// <returns>Returns the number of successful update.</returns>
		public int Update(<%=collectionClassName%> entityCollection)
		{	
			return Update(null, entityCollection);
		}
		
		/// <summary>
		/// 	Update existing rows in the datasource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection">TList of <c><%=className%></c> objects.</param>
		/// <remarks>
		///		This function will only update entity objects marked as dirty
		///		and do not have an primary key value of 0.
		///		Upon updating the objects, each dirty object will have the public
		///		method <c>Object.AcceptChanges()</c> called to make it clean.
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///</remarks>
		/// <returns>Returns the number of successful update .</returns>
		public int Update(TransactionManager transactionManager, <%=collectionClassName%> entityCollection)
		{
			int number = 0;
			foreach (<%=className%> entity in entityCollection)
			{
				//if ((entity.IsDirty) && !(entity.IsNew))
				if (entity.EntityState == EntityState.Changed)
				{
					if ( Update(transactionManager, entity) )
					{
						number++;
					}
				}
			}
			return number;
		}
		
		/// <summary>
		/// 	Update an existing row in the datasource.
		/// </summary>
		/// <param name="entity"><%=className%> object to update.</param>
		/// <remarks>
		///		After updating the datasource, the <%=className%> object will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public bool Update(<%=className%> entity)
		{	
			return Update(null, entity);
		}
		
		/// <summary>
		/// 	Update an existing row in the datasource.
		/// </summary>
		/// <param name="entity"><%=className%> object to update.</param>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <remarks>
		///		After updating the datasource, the <%=className%> object will be updated
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public abstract bool Update(TransactionManager transactionManager, <%=className%> entity);
		
		#endregion

	<%	}//endif (IncludeUpdate) %>
	<% if (IncludeSave){ %>
		#region Save Functions
		
		/// <summary>
		/// 	Save rows changes in the datasource (insert, update ,delete).
		/// </summary>
		/// <param name="entity"><%=className%> object to update.</param>
		/// <remarks>
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated or inserted
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///</remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public void Save(<%=className%> entity)
		{		
			Save(null, entity);
		}
		
		/// <summary>
		/// 	Updates, Inserts rows in the datasource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entity"><c><%=className%></c> to save.</param>
		/// <remarks>
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated or inserted
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public void Save(TransactionManager transactionManager, <%=className%> entity)
		{				
			switch (entity.EntityState)
			{				
				case EntityState.Deleted:
					Delete(transactionManager, entity);
					break ;				
				case EntityState.Changed:
					Update(transactionManager, entity);
					break ;
				case EntityState.Added:
					Insert(transactionManager, entity);
					break ;
			}			
			
			/*
			if (entity.IsDeleted)
			{
				Delete(transactionManager, entity);
			}
			if ((entity.IsDirty) && !(entity.IsNew))
			{
				Update(transactionManager, entity);
			}
			else if (entity.IsNew)
			{
				Insert(transactionManager, entity);
			}
			*/
		}
		
		/// <summary>
		/// 	Save rows changes in the datasource (insert, update ,delete).
		/// </summary>
		/// <param name="entityCollection">TList of <c><%=className%></c> objects.</param>
		/// <remarks>
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated or inserted
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		///</remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public void Save(<%=collectionClassName%> entityCollection)
		{
			Save(null, entityCollection);
		}				
		
		/// <summary>
		/// 	Updates, Inserts rows in the datasource.
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entityCollection">TList of <c><%=className%></c> objects.</param>
		/// <remarks>
		/// 	After updating the datasource, the <c><%=className%></c> objects will be updated or inserted
		/// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
		/// </remarks>
		/// <returns>Returns true if operation is successful.</returns>
		public void Save(TransactionManager transactionManager, <%=collectionClassName%> entityCollection)
		{
			foreach (<%=className%> entity in entityCollection)
			{
				Save(transactionManager, entity);
			}
			
			foreach (<%=className%> entity in entityCollection.DeletedItems)
			{
				Delete(transactionManager, entity);
			}
			
			// Clear the items to delete list.
			entityCollection.DeletedItems.Clear();
		}
		
		#endregion

	<%} // endif (IncludeSave) %>
	<% if (IncludeCustoms) { %>
		#region Custom Methods
		
	<%
		string prefix = string.Format(CustomProcedureStartsWith, SourceTable.Name, ProcedurePrefix);
		foreach(CommandSchema command in SourceTable.Database.Commands)
		{
			// If the stored procedure is targeting the current table.
			if (!command.Name.StartsWith(prefix))
			{
				continue;
			}
			
			string methodName = command.Name.Substring(prefix.Length);
			string returnType = string.Empty;
			
			
			// if the sp return row of the table
			if (IsMatching(command, SourceTable))
			{
				returnType = collectionClassName;
			}
			else	// Return a basic DataSet
			{
				returnType = CustomNonMatchingReturnType.ToString();
			}
			
			string returnTypeForComment = returnType.Replace("<", "&lt;").Replace(">", "&gt;");
			
	%>
		#region <%=command.Name%> 
		
		/// <summary>
		///	This method wrap the '<%=command.Name%>' stored procedure. 
		/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters) + TransformStoredProcedureOutputsToMethodComments(command.AllOutputParameters)%>
		/// <remark>This method is generate from a stored procedure.</remark>
		/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns>
		public <%=returnType%> <%=methodName%>(<%=TransformStoredProcedureInputsToMethod(false, command.InputParameters) + TransformStoredProcedureOutputsToMethod(command.InputParameters.Count > 0, command.AllOutputParameters)%>)
		{
			return <%=methodName%>(null, 0, int.MaxValue <%=TransformStoredProcedureInputsToDataAccess(true, command.InputParameters) + TransformStoredProcedureOutputsToDataAccess(true, command.AllOutputParameters)%>);
		}
		
		/// <summary>
		///	This method wrap the '<%=command.Name%>' stored procedure. 
		/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters) + TransformStoredProcedureOutputsToMethodComments(command.AllOutputParameters)%>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <remark>This method is generate from a stored procedure.</remark>
		/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns>
		public <%=returnType%> <%=methodName%>(int start, int pageLength<%=TransformStoredProcedureInputsToMethod(true, command.InputParameters) + TransformStoredProcedureOutputsToMethod(true, command.AllOutputParameters)%>)
		{
			return <%=methodName%>(null, start, pageLength <%=TransformStoredProcedureInputsToDataAccess(true, command.InputParameters) + TransformStoredProcedureOutputsToDataAccess(true, command.AllOutputParameters)%>);
		}
				
		/// <summary>
		///	This method wrap the '<%=command.Name%>' stored procedure. 
		/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters) + TransformStoredProcedureOutputsToMethodComments(command.AllOutputParameters)%>
		/// <remark>This method is generate from a stored procedure.</remark><% if (returnType != "void") {%>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns><%}%>
		public <%=returnType%> <%=methodName%>(TransactionManager transactionManager<%=TransformStoredProcedureInputsToMethod(true, command.InputParameters) + TransformStoredProcedureOutputsToMethod(true, command.AllOutputParameters)%>)
		{
			return <%=methodName%>(0, int.MaxValue <%=TransformStoredProcedureInputsToDataAccess(true, command.InputParameters) + TransformStoredProcedureOutputsToDataAccess(true, command.AllOutputParameters)%>);
		}
		
		/// <summary>
		///	This method wrap the '<%=command.Name%>' stored procedure. 
		/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters) + TransformStoredProcedureOutputsToMethodComments(command.AllOutputParameters)%>
		/// <param name="start">Row number at which to start reading.</param>
		/// <param name="pageLength">Number of rows to return.</param>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <remark>This method is generate from a stored procedure.</remark>
		/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns>
		public abstract <%=returnType%> <%=methodName%>(TransactionManager transactionManager, int start, int pageLength <%=TransformStoredProcedureInputsToMethod(true, command.InputParameters) + TransformStoredProcedureOutputsToMethod(true, command.AllOutputParameters)%>);
		
		#endregion
	<%
		//}
		} // end foreach command	
	%>
		
		#endregion

	<% }//endif (IncludeCustoms) %>
		#region Helper Functions	
		/*
		/// <summary>
		/// Fill an <%=collectionClassNameForComment%> from the first table in a DataSet
		/// </summary>
		/// <param name="dataSet">the DataSet</param>
		/// <param name="rows">The collection to fill</param>
		/// <param name="start">Start row</param>
		/// <param name="pageLength">number of rows.</param>
		///<returns><see chref="<%=collectionClassName%>"/></returns>
		public static <%=collectionClassName%> Fill(DataSet dataSet, <%=collectionClassName%> rows, int start, int pageLength)
		{
			if (dataSet.Tables.Count >= 1)
			{
				return Fill(dataSet.Tables[0], rows, start, pageLength);
			}
			else
			{
				return new <%=collectionClassName%>();
			}	
		}
		
		/// <summary>
		/// Fill an <%=collectionClassNameForComment%> From a DataTable
		/// </summary>
		/// <param name="dataTable">the DataTable that hold the data.</param>
		/// <param name="rows">The collection to fill</param>
		/// <param name="start">Start row</param>
		/// <param name="pageLength">number of rows.</param>
		/// <returns><see chref="<%=collectionClassNameForComment%>"/></returns>
		public static <%=collectionClassName%> Fill(DataTable dataTable, <%=collectionClassName%> rows, int start, int pageLength)
		{
			// trying to start past the last row?
			if ( start > dataTable.Rows.Count )
				return rows;

			// will we go past the last row?
			if ( (pageLength+start) > dataTable.Rows.Count )
				pageLength = dataTable.Rows.Count;

			for (int i = start; i < pageLength; i++)
			{
				DataRow row = dataTable.Rows[i];
				
				<%=className%> c = new <%=className%>();
				<%for (int x=0; x < cols.Count;x++)	{ %>
				<%= GetObjectPropertySetExpression(cols[x], "row", "c", 4) %>;
				<%if( cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) ) {%>
				c.Original<%=GetPropertyName(cols[x].Name)%> = (Convert.IsDBNull(row["<%=cols[x].Name%>"]))?<%= GetCSDefaultByType(cols[x])%>:(<%=GetCSType(cols[x])%>)row["<%=cols[x].Name%>"];
				<%	}// end if
				} //end for %>
				c.AcceptChanges();
				rows.Add(c);
			}
			return rows;
		}
		*/

		/// <summary>
		/// Update the <%=className%> entity from the database without using GetByPrimaryKey
		///  - which creates a new entity every time and adds validation event handlers to it (that's bad memory-wise and CPU-wise at high DB refresh/update rates).
		/// </summary>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entity"><see cref="<%=className%>"/> object to refresh </param>
        public abstract void RefreshEntity(TransactionManager transactionManager, <%=className%> entity);
		
		/// <summary>
		/// Update the <%=className%> entity from the database without using GetByPrimaryKey
		///  - which creates a new entity every time and adds validation event handlers to it (that's bad memory-wise and CPU-wise at high DB refresh/update rates).
		/// </summary>
		/// <param name="entity"><see cref="<%=className%>"/> object to refresh </param>
		public virtual void RefreshEntity(<%=className%> entity)
        {
            RefreshEntity((TransactionManager)null, entity);
        }
			
		/// <summary>
		/// Fill a <%=collectionClassNameForComment%> From a DataReader.
		/// </summary>
		/// <param name="reader">Datareader</param>
		/// <param name="rows">The collection to fill</param>
		/// <param name="start">Start row</param>
		/// <param name="pageLength">number of rows.</param>
		/// <returns>a <see cref="<%=collectionClassNameForComment%>"/></returns>
		public static <%=collectionClassName%> Fill(IDataReader reader, <%=collectionClassName%> rows, int start, int pageLength)
		{
			// advance to the starting row
			for (int i = 0; i < start; i++)
			{
				if (! reader.Read() )
					return rows; // not enough rows, just return
			}

			for (int i = 0; i < pageLength; i++)
			{
				if (!reader.Read())
					break; // we are done

				<%=className%> c = new <%=className%>();
				<%for (int x=0; x < cols.Count;x++) { %>
				<%= GetObjectPropertySetExpression(cols[x], "reader", "c", 4) %>;
				<% if( cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) ) {%>
				c.Original<%=GetPropertyName(cols[x].Name)%> = (Convert.IsDBNull(reader["<%=cols[x].Name%>"]))?<%= GetCSDefaultByType(cols[x])%>:(<%=GetCSType(cols[x])%>)reader["<%=cols[x].Name%>"];
				<% }// end if %>
				<%} //end for each column %>
				c.AcceptChanges();
				rows.Add(c);
			}
			return rows;
		}
		
		/// <summary>
		/// Refreshes the <see cref="<%=className%>"/> object from the <see cref="IDataReader"/>.
		/// </summary>
		/// <param name="reader">The <see cref="IDataReader"/> to read from.</param>
		/// <param name="entity">The <see cref="<%=className%>"/> object to refresh.</param>
		public static void RefreshEntity(IDataReader reader, <%=className%> entity)
		{
			if (reader == null || entity == null || !reader.Read()) return;
			
			<%for (int x=0; x < cols.Count;x++) { %>
			<%= GetObjectPropertySetExpression(cols[x], "reader", "entity", 3) %>;
			<% if( cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) ) {%>
			<%= GetOriginalObjectPropertySetExpression(cols[x], "reader", "entity", 3) %>;
			<% } // end if %>
			<%} //end for each column %>
			entity.AcceptChanges();
		}
		
		/// <summary>
		/// Refreshes the <see cref="<%=className%>"/> object from the <see cref="DataSet"/>.
		/// </summary>
		/// <param name="dataSet">The <see cref="DataSet"/> to read from.</param>
		/// <param name="entity">The <see cref="<%=className%>"/> object.</param>
		public static void RefreshEntity(DataSet dataSet, <%=className%> entity)
		{
			if (dataSet == null || entity == null || dataSet.Tables.Count == 0 || dataSet.Tables[0].Rows.Count == 0) return;

			DataRow dataRow = dataSet.Tables[0].Rows[0];
			
			<%for (int x=0; x < cols.Count;x++) { %>
			<%= GetObjectPropertySetExpression(cols[x], "dataRow", "entity", 3) %>;
			<% if( cols[x].IsPrimaryKeyMember && !IsIdentityColumn(cols[x]) && !IsComputed(cols[x]) ) {%>
			<%= GetOriginalObjectPropertySetExpression(cols[x], "dataRow", "entity", 3) %>;
			<% }// end if %>
			<%} //end for each column %>
			entity.AcceptChanges();
		}
		
		<%
		if (IncludeRelations)
		{
		// Going to require knowing the foreign key indexes in order to do deep loading.
		if (IncludeGetListByFK) { %>  
		#region DeepLoad
		
		#region Deep Load By Entity
		/// <summary>
		/// Deep Load the IEntity object with all of the child 
		/// property collections only 1 Level Deep.
		/// </summary>
		/// <remarks>
		/// <c>DeepLoad</c> overloaded methods for a recursive N Level deep loading method.
		/// </remarks>
		/// <param name="entity"><%= className %> Object</param>
		public void DeepLoad(<%= className %> entity)
		{
		 	DeepLoad(entity, false, DeepLoadType.ExcludeChildren, new Type[] {});
		}
		
		/// <summary>
		/// Deep Load the IEntity object with all of the child 
		/// property collections only 1 Level Deep.
		/// </summary>
		/// <remarks>
		/// <c>DeepLoad</c> overloaded methods for a recursive N Level deep loading method.
		/// </remarks>
		/// <param name="entity"><%= className %> Object</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively save all Property Collection that are descendants of this instance. If True, saves the complete object graph below this object. If False, saves this object only. </param>
		public void DeepLoad(<%= className %> entity, bool deep)
		{
		 	DeepLoad(entity, deep, DeepLoadType.ExcludeChildren, new Type[] {});
		}
		
		/// <summary>
		/// Deep Loads the <see cref="IEntity"/> object with criteria based of the child 
		/// property collections only N Levels Deep based on the <see cref="DeepLoadType"/>.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with Recursion and traverse an entire object graph.
		/// </remarks>
		/// <param name="entity">The <see cref="<%= className %>"/> object to load.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively save all Property Collection that are descendants of this instance. If True, saves the complete object graph below this object. If False, saves this object only. </param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Load</param>
	    /// <exception cref="ArgumentNullException">entity or childTypes is null.</exception>
	    /// <exception cref="ArgumentException">deepLoadType has invalid value.</exception>
		public void DeepLoad(<%= className %> entity, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			DeepLoad(null, entity, deep, deepLoadType, childTypes);
		}
		
		/// <summary>
		/// Deep Loads the <see cref="IEntity"/> object with criteria based of the child 
		/// property collections only N Levels Deep based on the <see cref="DeepLoadType"/>.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with Recursion and traverse an entire object graph.
		/// </remarks>
		/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
		/// <param name="entity">The <see cref="<%= className %>"/> object to load.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively save all Property Collection that are descendants of this instance. If True, saves the complete object graph below this object. If False, saves this object only. </param>
		/// <param name="deepLoadType">DeepLoadType Enumeration to Include/Exclude object property collections from Load.</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Load</param>
	    /// <exception cref="ArgumentNullException">entity or childTypes is null.</exception>
	    /// <exception cref="ArgumentException">deepLoadType has invalid value.</exception>
		public void DeepLoad(TransactionManager transactionManager, <%= className %> entity, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			#region Argument Validation
			//Argument checks
			if (entity ==  null)
			{
				throw new ArgumentNullException("entity", "The argument <%= className %>, can not be null.");
			}
			if (!Enum.IsDefined(typeof(DeepLoadType), deepLoadType))
			{
				throw new ArgumentException("A valid DeepLoadType option is not present.", "DeepLoadType");
			}
			if (childTypes == null)
			{
				throw new ArgumentNullException("childTypes", "A valid Type[] array is not present.");
			}
			#endregion
			
			//In case an event can trigger the disabling of the deep load
			if (deepLoadType == DeepLoadType.Ignore)
			{
				return;
			}
			
			//Create a HashTable list of types for easy access
			Hashtable innerList = new Hashtable(childTypes.Length);
			for(int i=0; i < childTypes.Length; i++)
			{
				innerList.Add(childTypes[i], childTypes[i].ToString()); 
			}
			
			Debug.Indent();
			Debug.WriteLine("DeepLoad object '<%= className %>'");
			Debug.Indent();
			
			<%
			// option 1a: clear all collections
			// entity.My1Collection.Clear(); entity.My2Collection.Clear(); etc...
			// option 1b: check the count below to decide if we should set the value directly or call CopyTo
			// if (entity.My1Collection.Count > 0)

			// option 2a: use an 'AlreadySeen' list to decide if need to set or copy-to
			%>
			ArrayList alreadySetCollections = new ArrayList();
			<%
			// option 2b: check the 'AlreadySeen' list below to decide if we should set the value directly or call CopyTo
			// if (alreadySetCollections.IndexOf("My1Collection") > -1)

			// option 3a: same as option 1a - clear all collections first
			// option 3b: always use CopyTo - but that's probably less efficient
			%>
			
			// Load Entity through Provider
			<% 
			int ctr = 0;
			foreach(CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables))
			{				
				if (ctr == 0)
					Response.Write("\t\t\t// Deep load child collections  - Call GetBy" + String.Join(string.Empty,item.PkColNames) + " methods when available" + Environment.NewLine);
				ctr++;
			%>
			<% if (item.CollectionRelationshipType == RelationshipType.ManyToMany) { %>
			// RelationshipType.ManyToMany
			if ((deepLoadType == DeepLoadType.IncludeChildren && innerList[typeof(<%=NameSpace + ". " + GetCollectionClassName(item.SecondaryTable)%>)] != null)
				|| (deepLoadType == DeepLoadType.ExcludeChildren && innerList[typeof(<%=NameSpace + ". " + GetCollectionClassName(item.SecondaryTable)%>)] == null))
			{
				Debug.WriteLine("- property '<%=item.CollectionName%>' yy loaded.");
				if (alreadySetCollections.IndexOf("<%=item.CollectionName%>") > -1)
				{
					DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.GetBy<%=item.GetByKeysName%>(transactionManager,<%=item.CallParams%>).CopyTo(entity.<%=item.CollectionName%>);
				} else {
					entity.<%=item.CollectionName%> = DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.GetBy<%=item.GetByKeysName%>(transactionManager, <%=item.CallParams%>);			 
					alreadySetCollections.Add("<%=item.CollectionName%>");
				}
				/*if (deep)
				{
					DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepLoad(transactionManager, entity.<%=item.CollectionName%>, deep, deepLoadType, childTypes);
				}*/			
			}
			
			
			<% } else if (item.CollectionRelationshipType == RelationshipType.OneToOne) { %>
			// RelationshipType.OneToOne
			if ((deepLoadType == DeepLoadType.IncludeChildren && innerList[typeof(<%=NameSpace + ". " + item.CollectionTypeName%>)] != null)
				|| (deepLoadType == DeepLoadType.ExcludeChildren && innerList[typeof(<%=NameSpace + ". " + item.CollectionTypeName%>)] == null))
			{
				Trace.WriteLine("- property '<%=item.CleanName%>' loaded.");
				TList<<%=item.CleanName%>> _<%=item.CollectionName%> = DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.<%=item.GetByKeysName%>(transactionManager, <%=item.CallParams%>);
				if (_<%=item.CollectionName%>.Count == 1)
				{
					entity.<%=item.CleanName%> = _<%=item.CollectionName%>[0];
					if (deep)
					{
						DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepLoad(transactionManager, entity.<%=item.CleanName%>, deep, deepLoadType, childTypes);
					}
				}
				else
				{
					// the one to one linked object is not found
				}
			}
			
			<% } else { %>
			if ((deepLoadType == DeepLoadType.IncludeChildren && innerList[typeof(<%=NameSpace + ". " + item.CollectionTypeName%>)] != null)
				|| (deepLoadType == DeepLoadType.ExcludeChildren && innerList[typeof(<%=NameSpace + ". " + item.CollectionTypeName%>)] == null))
			{
				Debug.WriteLine("- property '<%=item.CollectionName%>' loaded.");

				if (alreadySetCollections.IndexOf("<%=item.CollectionName%>") > -1)
				{
					DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.<%=item.GetByKeysName%>(transactionManager, <%=item.CallParams%>).CopyTo(entity.<%=item.CollectionName%>);
				} else {
					entity.<%=item.CollectionName%> = DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.<%=item.GetByKeysName%>(transactionManager, <%=item.CallParams%>);			 
					alreadySetCollections.Add("<%=item.CollectionName%>");
				}

				if (deep)
				{
					DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepLoad(transactionManager, entity.<%=item.CollectionName%>, deep, deepLoadType, childTypes);
				}
			}		
			<% } %>	    
		    <% }//end foreach CollectionInfo%>
			Debug.Unindent();
			Debug.Unindent();
			Debug.WriteLine("");
		}

		#endregion
		
		#region Deep Load By Entity Collection
		/// <summary>
		/// Deep Loads the <see cref="<%= collectionClassNameForComment %>"/> object with all of the child 
		/// property collections only 1 Level Deep.
		/// </summary>
		/// <remarks>
		/// <c>DeepLoad</c> overloaded methods for a recursive N Level deep loading method.
		/// </remarks>
		/// <param name="entityCollection">the <see cref="<%= collectionClassNameForComment %>"/> Object to deep loads.</param>
		public void DeepLoad(<%= collectionClassName %> entityCollection)
		{
			 DeepLoad(entityCollection, false, DeepLoadType.ExcludeChildren, new Type[] {});
		}
		
		/// <summary>
		/// Deep Loads the <see cref="<%= collectionClassNameForComment %>"/> object.
		/// </summary>
		/// <remarks>
		/// <c>DeepLoad</c> overloaded methods for a recursive N Level deep loading method.
		/// </remarks>
		/// <param name="entityCollection">the <see cref="<%= collectionClassNameForComment %>"/> Object to deep loads.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively save all Property Collection that are descendants of this instance. If True, saves the complete object graph below this object. If False, saves this object only. </param>
		public void DeepLoad(<%= collectionClassName %> entityCollection, bool deep)
		{
			 DeepLoad(entityCollection, deep, DeepLoadType.ExcludeChildren, new Type[] {});
		}	
	
		/// <summary>
		/// Deep Loads the entire <see cref="<%= collectionClassNameForComment %>"/> object with criteria based of the child 
		/// property collections only N Levels Deep based on the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with Recursion and traverse an entire collection's object graph.
		/// </remarks>
		/// <param name="entityCollection">The <see cref="<%= collectionClassNameForComment %>"/> instance to load.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively load all Property Collection that are descendants of this instance. If True, load the complete object graph below this object. If False, load this object only.</param>
		/// <param name="deepLoadType"><see cref="DeepLoadType"/> Enumeration to Include/Exclude object property collections from Load.
		///		Use DeepLoadType.[IncludeChildren/ExcludeChildren]WithRecursion to traverse the entire object graph.
		///	</param>
		/// <param name="childTypes"><see cref="<%= className %>"/> Property Collection Type Array To Include or Exclude from Load</param>
		public void DeepLoad(<%= collectionClassName %> entityCollection, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			DeepLoad(null, entityCollection, deep, deepLoadType, childTypes);
		}
		
		/// <summary>
		/// Deep Loads the entire <see cref="<%= collectionClassNameForComment %>"/> object with criteria based of the child 
		/// property collections only N Levels Deep based on the DeepLoadType.
		/// </summary>
		/// <remarks>
		/// Use this method with caution as it is possible to DeepLoad with Recursion and traverse an entire collection's object graph.
		/// </remarks>
        /// <param name="transactionManager">The transaction manager.</param>
		/// <param name="entityCollection">The <see cref="<%= collectionClassNameForComment %>"/> instance to load.</param>
		/// <param name="deep">Boolean. A flag that indicates whether to recursively load all Property Collection that are descendants of this instance. If True, load the complete object graph below this object. If False, load this object only.</param>
		/// <param name="deepLoadType"><see cref="DeepLoadType"/> Enumeration to Include/Exclude object property collections from Load.
		///		Use DeepLoadType.[IncludeChildren/ExcludeChildren]WithRecursion to traverse the entire object graph.
		///	</param>
		/// <param name="childTypes"><see cref="<%= className %>"/> Property Collection Type Array To Include or Exclude from Load</param>
		public void DeepLoad(TransactionManager transactionManager, <%= collectionClassName %> entityCollection, bool deep, DeepLoadType deepLoadType, params System.Type[] childTypes)
		{
			#region Argument Validation
			//Argument checks
			if (entityCollection ==  null)
			{
				throw new ArgumentNullException("entityCollection", "A valid non-null, <%= collectionClassName %> object is not present.");
			}
			if (!Enum.IsDefined(typeof(DeepLoadType), deepLoadType))
			{
				throw new ArgumentException("A valid DeepLoadType option is not present.", deepLoadType.ToString());
			}
			if (childTypes == null)
			{
				throw new ArgumentNullException("childTypes", "A valid Type[] array is not present.");
			}
			#endregion
					
			//In case an event can trigger the disabling of the deepload
			if (deepLoadType == DeepLoadType.Ignore)
			{
				return;
			}
			
			foreach (<%=className%> entity in entityCollection)
			{
				DeepLoad(transactionManager, entity, deep, deepLoadType, childTypes);
			}		
			return;
		}

		
		#endregion
		
		#endregion 
		
		<%	}//endif %>
		<%  if (IncludeSave && IncludeGetListByFK) { %>
		#region DeepSave
		
		#region Deep Save By Entity
		
		/// <summary>
		/// Deep Save the <see cref="<%= className %>"/> object with all of the child
		/// property collections N Levels Deep.
		/// </summary>
		/// <param name="entity"><%= className %> Object</param>
		public bool DeepSave(<%= className %> entity)
		{
			return DeepSave(entity, DeepSaveType.ExcludeChildren, new Type[] {} );
		}
		
		/// <summary>
		/// Deep Save the <see cref="<%= className %>"/> object with all of the child
		/// property collections N Levels Deep.
		/// </summary>
		/// <param name="entity"><%= className %> instance</param>
		/// <param name="transactionManager">The transaction manager.</param>
		public bool DeepSave(TransactionManager transactionManager, <%= className %> entity)
		{
			return DeepSave(transactionManager, entity, DeepSaveType.ExcludeChildren, new Type[] {} );
		}
		
		
		
		/// <summary>
		/// Deep Save the entire object graph of the <%= className %> object with criteria based of the child 
		/// Type property array and DeepSaveType.
		/// </summary>
		/// <param name="entity"><%= className %> Object</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.
		///	</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Save</param>
		public bool DeepSave(<%= className %> entity, DeepSaveType deepSaveType, System.Type[] childTypes)
		{
			return DeepSave(null, entity, deepSaveType, childTypes);
		}
					
		/// <summary>
		/// Deep Save the entire object graph of the <%= className %> object with criteria based of the child 
		/// Type property array and DeepSaveType.
		/// </summary>
		/// <param name="transactionManager">The transaction manager.</param>
		/// <param name="entity"><%= className %> instance</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.
		///	</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Save</param>
		public bool DeepSave(TransactionManager transactionManager, <%= className %> entity, DeepSaveType deepSaveType, System.Type[] childTypes)
		{
			#region Argument Validation
			//Argument checks
			if (entity ==  null)
			{
				throw new ArgumentNullException("entity", "The argument <%= className %>, can not be null.");
			}
			if (!Enum.IsDefined(typeof(DeepSaveType), deepSaveType))
			{
				throw new ArgumentNullException("A valid DeepSaveType option is not present.", "deepSaveType");
			}
			if (childTypes == null)
			{
				throw new ArgumentNullException("childTypes", "A valid Type[] array is not present.");
			}
			#endregion
			
			//In case an event can trigger the disabling of the deepsave
			if (deepSaveType == DeepSaveType.Ignore)
			{
				return true;
			}
			
			//Create a HashTable list of types for easy access
			Hashtable innerList = new Hashtable(childTypes.Length);
			for(int i=0; i < childTypes.Length; i++)
			{
				innerList.Add(childTypes[i], childTypes[i].ToString()); 
			}
	
			// Save Root Entity through Provider
			this.Save(transactionManager, entity);
			<% 
	
			int ctr = 0;
			foreach(CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables)) { 
				if (ctr == 0)
					Response.Write("\t\t//deep save child collections  - Call DeepSave() Methods on Children" + Environment.NewLine);
				ctr++;
			%>
	
			 <% if (item.CollectionRelationshipType == RelationshipType.ManyToMany && IncludeManyToMany) { %>
			if ((deepSaveType == DeepSaveType.IncludeChildren && innerList[typeof(<%=NameSpace + "." + GetCollectionClassName(item.SecondaryTable)%>)] != null)
				|| (deepSaveType == DeepSaveType.ExcludeChildren && innerList[typeof(<%=NameSpace + "." + GetCollectionClassName(item.SecondaryTable)%>)] == null))
			{
				DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepSave(transactionManager, entity.<%=item.CollectionName %>, deepSaveType, childTypes); 
			}
			<% } else if (item.CollectionRelationshipType == RelationshipType.OneToOne) { %>
			if ((deepSaveType == DeepSaveType.IncludeChildren && innerList[typeof(<%=NameSpace + "." + item.CollectionTypeName%>)] != null)
				|| (deepSaveType == DeepSaveType.ExcludeChildren && innerList[typeof(<%=NameSpace + "." + item.CollectionTypeName%>)] == null))
			{
				// update each child parent id with the real parent id (mostly used on insert)
				<%
				for(int i=0; i<item.TableKey.ForeignKeyMemberColumns.Count; i++)
				{
					Response.Write("\t\t\t\tentity."+ item.CleanName +"." + GetPropertyName(item.TableKey.ForeignKeyMemberColumns[i].Name) + " = entity." + GetPropertyName(item.TableKey.PrimaryKeyMemberColumns[i].Name) + ";");
				}
				%>

				DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepSave(transactionManager, entity.<%=item.CleanName%>, deepSaveType, childTypes);
			} 
			<% } else { %>
			if ((deepSaveType == DeepSaveType.IncludeChildren && innerList[typeof(<%=NameSpace + "." + item.CollectionTypeName%>)] != null)
				|| (deepSaveType == DeepSaveType.ExcludeChildren && innerList[typeof(<%=NameSpace + "." + item.CollectionTypeName%>)] == null))
			{
				// update each child parent id with the real parent id (mostly used on insert)
				foreach(<%=item.CleanName%> child in entity.<%=item.CollectionName %>)
				{
					<% for(int i=0; i<item.TableKey.ForeignKeyMemberColumns.Count; i++)
					{
						Response.Write("\t\t\t\t\tchild." + GetPropertyName(item.TableKey.ForeignKeyMemberColumns[i].Name) + " = entity." + GetPropertyName(item.TableKey.PrimaryKeyMemberColumns[i].Name) + ";");
					}
					%>
				}
				
				DataRepository.<%=GetProviderClassName(item.SecondaryTable)%>.DeepSave(transactionManager, entity.<%=item.CollectionName%>, deepSaveType, childTypes);
			} 
			<% } %>
			<% }//end foreach CollectionInfo%>
			
			return true;
		}
		#endregion
		
		#region Deep Save By Entity Collection
		/// <summary>
		/// Deep Save the entire <%= collectionClassNameForComment %> object with all of the child 
		/// property collections.
		/// </summary>
		/// <param name="entityCollection"><%= collectionClassNameForComment %> Object</param>
		public bool DeepSave(<%= collectionClassName %> entityCollection)
		{
			return DeepSave(null, entityCollection, DeepSaveType.ExcludeChildren, new Type[] {});
		}
		
		/// <summary>
		/// Deep Save the entire <%= collectionClassNameForComment %> object with all of the child 
		/// property collections.
		/// </summary>
		/// <param name="transactionManager">The transaction manager.</param>
		/// <param name="entityCollection"><%= collectionClassNameForComment %> Object</param>
		public bool DeepSave(TransactionManager transactionManager, <%= collectionClassName %> entityCollection)
		{
			return DeepSave(transactionManager, entityCollection, DeepSaveType.ExcludeChildren, new Type[] {});
		}
		
		/// <summary>
		/// Deep Save the entire object graph of the <%= collectionClassNameForComment %> object with criteria based of the child 
		/// property collections.
		/// </summary>
		/// <param name="entityCollection"><%= collectionClassNameForComment %> Object</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Save</param>
		public bool DeepSave(<%= collectionClassName %> entityCollection, DeepSaveType deepSaveType, System.Type[] childTypes)
		{
			return DeepSave(null, entityCollection, deepSaveType, childTypes);
		}
		
		/// <summary>
		/// Deep Save the entire object graph of the <%= collectionClassNameForComment %> object with criteria based of the child 
		/// property collections.
		/// </summary>
		/// <param name="transactionManager">The transaction manager.</param>
		/// <param name="entityCollection"><c cref="<%= collectionClassNameForComment %>"/> instance</param>
		/// <param name="deepSaveType">DeepSaveType Enumeration to Include/Exclude object property collections from Save.</param>
		/// <param name="childTypes"><%= className %> Property Collection Type Array To Include or Exclude from Save</param>
		public bool DeepSave(TransactionManager transactionManager, <%= collectionClassName %> entityCollection, DeepSaveType deepSaveType, System.Type[] childTypes)
		{
			#region Argument Validation
			//Argument checks
			if (entityCollection ==  null)
			{
				throw new ArgumentNullException("entityCollection", "A valid non-null, <%= collectionClassName %> object is not present.");
			}
			if (!Enum.IsDefined(typeof(DeepSaveType), deepSaveType))
			{
				throw new ArgumentException("A valid DeepSaveType option is not present.", "deepSaveType");
			}
			if (childTypes == null)
			{
				throw new ArgumentNullException("childTypes", "A valid Type[] array is not present.");
			}
			#endregion
					
			//In case an event can trigger the disabling of the deepsave
			if (deepSaveType == DeepSaveType.Ignore)
			{
				return true;
			}
			
			bool deepSaveResult = true;
			bool result;
			
			foreach (<%=className%> entity in entityCollection)
			{
				result = DeepSave(transactionManager, entity, deepSaveType, childTypes);
				if (!result){
					 deepSaveResult = false;
				}
			}
			
			foreach (<%=className%> entity in entityCollection.DeletedItems)
            {
                result = DeepSave(transactionManager, entity, deepSaveType, childTypes);
                if (!result){
                     deepSaveResult = false;
                }
            }

            entityCollection.DeletedItems.Clear();
			
			return deepSaveResult;
		}
		#endregion
		
		#endregion
		<%	}//endif 
		}// end if Include Relations
		%>
			
		#endregion "Helper Functions"
		
	}//end class
} // end namespace
