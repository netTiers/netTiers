<%--
 * $Id: EntityData.cst,v 1.2 2005/12/14 10:04:22 jroland Exp $
 * Last modified by $Author: bgjohnso $
 * Last modified at $Date: 2006-03-18 00:48:43 -0600 (Sat, 18 Mar 2006) $
 * $Revision: 69 $
--%>
<%@ CodeTemplate Src="..\TemplateLib\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Business object base class" Debug="True" ResponseEncoding="UTF-8" NoWarn="0108,0618,1572,1573,1574,0162,2002"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Connection" Description="Table Object should be based on." %>
<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Connection" Description="Tables of the sytem." %>
<%@ Property Name="SerializeEntityState" Type="System.Boolean" Default="False" Category="02. Framework Generation - Optional" Description="Indicates if the EntityState property should be included in serialization." %>

<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>
	
<%@ Property Name="NameSpace" Optional="True" Type="System.String" Category="Style" Description="Object Namespace." %>
<%
	string structName = GetClassName(SourceTable, ClassNameFormat.Struct);
%>
		
	/// <summary>
	///		The data structure representation of the '<%=SourceTable.Name%>' table.
	/// </summary>
	/// <remarks>
	/// 	This struct is generated by a tool and should never be modified.
	/// </remarks>
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Serializable]
	internal protected class <%=structName%> : ICloneable
	{
		#region Variable Declarations
		private EntityState currentEntityState = EntityState.Added;
		
		#region Primary key(s)
		<%
			for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++)
			{%>
			/// <summary>			
			/// <%=SourceTable.PrimaryKey.MemberColumns[i].Name%> : <%= GetColumnXmlComment(SourceTable.PrimaryKey.MemberColumns[i],2)%>
			/// </summary>
			/// <remarks>Member of the primary key of the underlying table "<%=SourceTable.Name%>"</remarks>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
				
			<%
				if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i])))
				{%>
			/// <summary>
			/// keep a copy of the original so it can be used for editable primary keys.
			/// </summary>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
			
				<%}
			}
		%>
		#endregion
		
		#region Non Primary key(s)
		
		<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
		
		/// <summary>
		/// <%=SourceTable.NonPrimaryKeyColumns[x].Name%> : <%=GetColumnXmlComment(SourceTable.NonPrimaryKeyColumns[x],2)%>
		/// </summary>
		public <%= GetCSType(SourceTable.NonPrimaryKeyColumns[x]) %><%= Tab(2) %>  <%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x]) %> = <%=GetParsedDefaultValue(x) %>;
		<% } //end for each non PK column %>
		#endregion
			
		<% if (IncludeGetListByFK) { %>
		#region Source Foreign Key Property
				
		<%	//Generate a Source property for each foreign key relation		
		System.Collections.ArrayList filled = new System.Collections.ArrayList();
		foreach(TableKeySchema tableKey in SourceTable.ForeignKeys)
		{	
			// related table must be in the selection
			if (SourceTables.Contains(tableKey.PrimaryKeyTable)) {
			string fkPropertyName = GetKeysName(tableKey.ForeignKeyMemberColumns);
			
			if(filled.Contains(fkPropertyName))
				continue;
				
			filled.Add(fkPropertyName);
			
			string pkClassName = GetClassName(tableKey.PrimaryKeyTable);
			string memberVarName = "_" + GetCamelCaseName(fkPropertyName) + "Source";
		%>
		private <%=pkClassName%> <%=memberVarName%> = null;
		
		/// <summary>
		/// Gets or sets the source <see cref="<%=pkClassName%>"/>.
		/// </summary>
		/// <value>The source <%=pkClassName%> for <%=fkPropertyName%>.</value>
        [XmlIgnore()]
		[Browsable(false)]
		public virtual <%=pkClassName%> <%=fkPropertyName%>Source
      	{
            get { return this.<%=memberVarName%>; }
            set { this.<%=memberVarName%> = value; }
      	}
		<%	} //end if in SourceTables
		 } //end for each FK%>
		#endregion
		<%}// IncludeGetListByFK%>	
		#endregion Variable Declarations
	
<% 
		
if(IncludeRelations)
{	
	Response.Write("\t\t#region Data Properties"+Environment.NewLine);
	WriteRelationshipPropertyString();
	Response.Write(Environment.NewLine + "\t\t#endregion Data Properties"+ Environment.NewLine );
}
		
%>
		
		#region Clone Method

		/// <summary>
		/// Creates a new object that is a copy of the current instance.
		/// </summary>
		/// <returns>A new object that is a copy of this instance.</returns>
		public Object Clone()
		{
			<%=structName%> _tmp = new <%=structName%>();
						
			<% for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
			_tmp.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%> = this.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
			<% if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i]))) {%>
			_tmp.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%> = this.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
			<% } %>
			<% } %>
			
			<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
			_tmp.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x]) %> = this.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x]) %>;
			<% } %>
			
			#region Source Parent Composite Entities
			<% if (IncludeGetListByFK) { %>
			<%	//Generate a Source property for each foreign key relation
				System.Collections.ArrayList filled = new System.Collections.ArrayList();
				foreach(TableKeySchema tableKey in SourceTable.ForeignKeys)
				{	
					// related table must be in the selection
					if (SourceTables.Contains(tableKey.PrimaryKeyTable)) {
					string fkPropertyName = GetKeysName(tableKey.ForeignKeyMemberColumns);
					
					if(filled.Contains(fkPropertyName))
						continue;
						
					filled.Add(fkPropertyName);
					
				string pkClassName = GetClassName(tableKey.PrimaryKeyTable);
					
				%>
			if (this.<%=fkPropertyName%>Source != null)
				_tmp.<%=fkPropertyName%>Source = MakeCopyOf(this.<%=fkPropertyName%>Source) as <%= pkClassName %>;
				<%	} //end if in SourceTables
				} //end for each FK
		  	}// IncludeGetListByFK%>	
			#endregion
		
			#region Child Collections
			<% if (IncludeRelations){
			int ctr = 0;
			foreach(CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables).Values) { 
				if (ctr == 0)
					Response.Write("\t\t\t//deep copy nested objects" + Environment.NewLine);
				ctr++;
				
				string typeName = "";
				if (item.CollectionRelationshipType == MoM.Templates.CommonSqlCode.RelationshipType.OneToOne)
					typeName = item.TypeName;
				else
					typeName = item.CollectionTypeName;
			%>
			if (this.<%=item.FieldName %> != null)
				_tmp.<%= item.PropertyNameUnique %> = (<%= typeName %>) MakeCopyOf(this.<%=item.PropertyNameUnique %>); 
				<% }//end foreach CollectionInfo
			}//end if IncludeRelations
			%>
			#endregion Child Collections
			
			//EntityState
			_tmp.EntityState = this.EntityState;
			
			return _tmp;
		}
		
		#endregion Clone Method
		
		/// <summary>
		///		Indicates state of object
		/// </summary>
		/// <remarks>0=Unchanged, 1=Added, 2=Changed</remarks>
		[BrowsableAttribute(false)<%= (!SerializeEntityState ? ", XmlIgnoreAttribute()" : "") %>]
		public EntityState	EntityState
		{
			get { return currentEntityState;  }
			set { currentEntityState = value; }
		}
	
	}//End struct

<script runat="template">
///<summary>
/// Many To Many Relationship Class Template Property String
///</summary>
protected static string MANY_TO_MANY = @"
		#region {0}
		
		private {1} {2};
		
		/// <summary>
		///	Holds a collection of entity objects
		///	which are related to this object through the junction table {2}
		/// </summary>	
		public {1} {0}
		{{
			get
			{{
				if ({2} == null)
				{{
				{2} = new {1}();
				}}
	
				return {2};
			}}
			set {{ {2} = value; }}
		}}
		
		#endregion 
";

///<summary>
/// One to One Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_ONE = @"
		#region {0}
		
		private {2} {1};
		
		/// <summary>
		///	Holds a  {2} entity object
		///	which is related to this object through the relation {1}
		/// </summary>
		public {2} {0}
		{{
			get {{		return {1};		}}
			set {{ 	{1} = value; 	}}
		}}
		
		#endregion 
";
		
///<summary>
/// One To Many Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_MANY = @"
		#region {0}
		
		private {2} {1};
		
		/// <summary>
		///	Holds a collection of entity objects
		///	which are related to this object through the relation {1}
		/// </summary>	
		public {2} {0}
		{{
			get
			{{
				if ({1} == null)
				{{
				{1} = new {2}();
				}}
	
				return {1};
			}}
			set {{ {1} = value; }}
		}}
		
		#endregion
";
		
///<summary>
///   Writes out the property string of all the relationship object collections.
///</summary>
private void WriteRelationshipPropertyString()
{	
	///Loop Child Collections
	foreach (CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables).Values)
	{
		///Assign by RelationshipType, Then Write to Response
		switch((int)item.CollectionRelationshipType)
		{
			///One To One Relationship
			case (int)RelationshipType.OneToOne:			
				object[] oneToOneParams = {
							item.PropertyNameUnique,
							item.FieldName,
							item.TypeName
				};
				item.PropertyName = string.Format(ONE_TO_ONE, oneToOneParams);
				break;
				
			///One To Many, Many To One
			case (int)RelationshipType.OneToMany:
			case (int)RelationshipType.ManyToOne:
			    object[] oneToManyParams = {
						  item.PropertyNameUnique
						, item.FieldName
						, item.TypeName
				};
			item.PropertyName = string.Format(ONE_TO_MANY, oneToManyParams);
			break;
			
			///Many To Many
			case (int)RelationshipType.ManyToMany:
				object[] manyToManyParams = {
						item.PropertyNameUnique,
						item.CollectionTypeName,
						item.FieldName
				};
				item.PropertyName = string.Format(MANY_TO_MANY, manyToManyParams);
				break;
			default:
				break;
		}
		
		///Write it out to the response stream
		Response.Write(item.PropertyName);	
	
	}///End foreach loop
}

public string GetParsedDefaultValue(int x)
{
	if (!ParseDbColDefaultVal 
		&& SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
	{
		return "null";
	}
	else if (!ParseDbColDefaultVal && !SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
	{
		return GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x]); 
	}
	else
	{
		string val = GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x]); 
		string defaultVal = GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x], true);
		
		if (val == defaultVal
			&& SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
			return "null";
		else 
			return val;
	}
}
</script>


