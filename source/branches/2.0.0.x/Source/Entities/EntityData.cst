<%--
 * $Id: EntityData.cst,v 1.2 2005/12/14 10:04:22 jroland Exp $
 * Last modified by $Author: bgjohnso $
 * Last modified at $Date: 2006-03-18 00:48:43 -0600 (Sat, 18 Mar 2006) $
 * $Revision: 69 $
--%>
<%@ CodeTemplate Src="..\TemplateLib\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Business object base class" Debug="True"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Property Name="SourceTable" Type="SchemaExplorer.TableSchema" Category="Connection" Description="Table Object should be based on." %>
<%@ Property Name="SourceTables" Type="SchemaExplorer.TableSchemaCollection" Category="Connection" Description="Tables of the sytem." %>

<%@ Property Name="IncludeRelations" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
<%@ Property Name="IncludeManyToMany" Type="System.Boolean" Default="False" Category="Options" Description="Include Collections for Related Entities."%>
	
<%@ Property Name="NameSpace" Optional="True" Type="System.String" Category="Style" Description="Object Namespace." %>
<%
	/* string className = GetClassName(SourceTable.Name); */
	string structName = GetStructName(SourceTable.Name);
%>
		
	/// <summary>
	///		The data structure representation of the '<%=SourceTable.Name%>' table.
	/// </summary>
	/// <remarks>
	/// 	This struct is generated by a tool and should never be modified.
	/// </remarks>
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Serializable]
	internal protected class <%=structName%> : ICloneable
	{
		#region Variable Declarations
		
		#region Primary key(s)
		<%
			for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++)
			{%>
			/// <summary>			
			/// <%=SourceTable.PrimaryKey.MemberColumns[i].Name%> : <%= GetColumnXmlComment(SourceTable.PrimaryKey.MemberColumns[i],2)%>
			/// </summary>
			/// <remarks>Member of the primary key of the underlying table "<%=SourceTable.Name%>"</remarks>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
				
			<%
				if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i])))
				{%>
			/// <summary>
			/// keep a copy of the original so it can be used for editable primary keys.
			/// </summary>
			public <%= GetCSType(SourceTable.PrimaryKey.MemberColumns[i]) %> <%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i])%>;
			
				<%}
			}
		%>
		#endregion
		
		#region Non Primary key(s)
		
		<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
		
		/// <summary>
		/// <%=SourceTable.NonPrimaryKeyColumns[x].Name%> : <%=GetColumnXmlComment(SourceTable.NonPrimaryKeyColumns[x],2)%>
		/// </summary>
		public <%= GetCSType(SourceTable.NonPrimaryKeyColumns[x]) %><%= Tab(2) %>  <%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %> = <%=GetParsedDefaultValue(x) %>;
		<% } //end for each non PK column %>
		#endregion
			
		#endregion Variable Declarations
		
		#region Clone Method

		/// <summary>
		/// Creates a new object that is a copy of the current instance.
		/// </summary>
		/// <returns>A new object that is a copy of this instance.</returns>
		public Object Clone()
		{
			<%=structName%> _tmp = new <%=structName%>();
						
			<% for(int i=0; i<SourceTable.PrimaryKey.MemberColumns.Count; i++) { %>
			_tmp.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%> = this.<%=GetPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
			<% if (!IsIdentityColumn(SourceTable.PrimaryKey.MemberColumns[i]) && !(IsComputed(SourceTable.PrimaryKey.MemberColumns[i]))) {%>
			_tmp.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%> = this.<%=GetOriginalPropertyName(SourceTable.PrimaryKey.MemberColumns[i].Name)%>;
			<% } %>
			<% } %>
			
			<% for (int x=0; x < SourceTable.NonPrimaryKeyColumns.Count; x++) { %>
			_tmp.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %> = this.<%= GetPropertyName(SourceTable.NonPrimaryKeyColumns[x].Name) %>;
			<% } %>
			
			return _tmp;
		}
		
		#endregion Clone Method
		
<% 
		
if(IncludeRelations)
{	
	Response.Write("\t\t#region Data Properties"+Environment.NewLine);
	WriteRelationshipPropertyString();
	Response.Write(Environment.NewLine + "\t\t#endregion Data Properties"+ Environment.NewLine );
}
		
%>

	}//End struct

<script runat="template">
///<summary>
/// Many To Many Relationship Class Template Property String
///</summary>
protected static string MANY_TO_MANY = @"
		#region {0}
		
		private {1} {2};
		
		/// <summary>
		///	Holds a collection of entity objects
		///	which are related to this object through the junction table {2}
		/// </summary>	
		public {1} {0}
		{{
			get
			{{
				if ({2} == null)
				{{
				{2} = new {1}();
				}}
	
				return {2};
			}}
			set {{ {2} = value; }}
		}}
		
		#endregion 
";

///<summary>
/// One to One Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_ONE = @"
		#region {0}
		
		private {2} {1};
		
		/// <summary>
		///	Holds a  {2} entity object
		///	which is related to this object through the relation {1}
		/// </summary>
		public {2} {0}
		{{
			get {{		return {1};		}}
			set {{ 	{1} = value; 	}}
		}}
		
		#endregion 
";
		
///<summary>
/// One To Many Relationship Class Template Property String
///</summary>		
protected static string ONE_TO_MANY = @"
		#region {0}
		
		private {2} {1};
		
		/// <summary>
		///	Holds a collection of entity objects
		///	which are related to this object through the relation {1}
		/// </summary>	
		public {2} {0}
		{{
			get
			{{
				if ({1} == null)
				{{
				{1} = new {2}();
				}}
	
				return {1};
			}}
			set {{ {1} = value; }}
		}}
		
		#endregion
";
		
///<summary>
///   Writes out the property string of all the relationship object collections.
///</summary>
private void WriteRelationshipPropertyString()
{	
	///Loop Child Collections
	foreach (CollectionInfo item in GetChildrenCollections(SourceTable, SourceTables).Values)
	{
		///Assign by RelationshipType, Then Write to Response
		switch((int)item.CollectionRelationshipType)
		{
			///One To One Relationship
			case (int)RelationshipType.OneToOne:			
				object[] oneToOneParams = {
							item.PropertyNameUnique,
							item.FieldName,
							item.TypeName
				};
				item.PropertyName = string.Format(ONE_TO_ONE, oneToOneParams);
				break;
				
			///One To Many, Many To One
			case (int)RelationshipType.OneToMany:
			case (int)RelationshipType.ManyToOne:
			    object[] oneToManyParams = {
						  item.PropertyNameUnique
						, item.FieldName
						, item.TypeName
				};
			item.PropertyName = string.Format(ONE_TO_MANY, oneToManyParams);
			break;
			
			///Many To Many
			case (int)RelationshipType.ManyToMany:
				object[] manyToManyParams = {
						item.PropertyNameUnique,
						item.CollectionTypeName,
						item.FieldName
				};
				item.PropertyName = string.Format(MANY_TO_MANY, manyToManyParams);
				break;
			default:
				break;
		}
		
		///Write it out to the response stream
		Response.Write(item.PropertyName);	
	
	}///End foreach loop
}

public string GetParsedDefaultValue(int x)
{
	if (!ParseDbColDefaultVal 
		&& SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
	{
		return "null";
	}
	else if (!ParseDbColDefaultVal && !SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
	{
		return GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x]); 
	}
	else
	{
		string val = GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x]); 
		string defaultVal = GetCSDefaultByType(SourceTable.NonPrimaryKeyColumns[x], true);
		
		if (val == defaultVal
			&& SourceTable.NonPrimaryKeyColumns[x].AllowDBNull)
			return "null";
		else 
			return val;
	}
}
</script>

