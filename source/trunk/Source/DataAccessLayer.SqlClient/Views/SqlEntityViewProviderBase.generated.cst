<%--
 * $Id: SqlEntityViewProviderBase.generated.cst,v 1.3 2006/03/07 09:51:41 jroland Exp $
 * Last modified by $Author: goofsr $
 * Last modified at $Date: 2006-04-07 14:24:32 -0500 (Fri, 07 Apr 2006) $
 * $Revision: 115 $
--%>
<%@ CodeTemplate Src="..\..\TemplateLib\CommonSqlCode.cs" Inherits="MoM.Templates.CommonSqlCode" Language="C#" TargetLanguage="C#" Description="Template description here." Debug="True"  ResponseEncoding="UTF-8" NoWarn="0108,0618,1572,1573,1574,0162,2002"%>
<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>

<%@ Import Namespace="SchemaExplorer" %>
<%@ Import Namespace="System.Collections" %>

<%@ Property Name="SourceView" Type="SchemaExplorer.ViewSchema" Category="Connection" Description="Table that the data access class should be based on." %>

<%@ Property Name="IncludeCustoms" Type="System.Boolean" Default="True" Category="Options" Description="If true customs stored procedures will be generated as functions." %>
<%@ Property Name="CustomNonMatchingReturnType" Type="CustomNonMatchingReturnType" Default="DataSet" Category="Options" Description="When using custom stored procedures, if the returned rows do not match the fields in an entity, a DataSet or IDataReader will be returned. Choose One.  This is useful if you've returned more than one resultset in a custom procedure; you can use a ConvertToDataSet(IDataReader) method in the Utility class to convert that to a DataSet." %>
<%@ Property Name="IncludeGetList" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeGetListByFK" Type="System.Boolean" Default="True" Category="Options" Description="If true get functions will be generated." %>
<%@ Property Name="IncludeGetListByIX" Type="System.Boolean" Default="True" Category="Options" Description="If true getlist functions will be generated." %>
<%@ Property Name="IncludeFind" Type="System.Boolean" Default="False" Category="Options" Description="If true find functions will be generated." %>
<%@ Property Name="SelectSuffix" Type="System.String" Default="_Get" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="SelectAllSuffix" Type="System.String" Default="List" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="FindSuffix" Type="System.String" Default="_Find" Category="Style" Description="Suffix to use for all generated SELECT functions." %>
<%@ Property Name="NameSpace" Type="System.String" Category="Style" Description="Class Namespace." %>
<%@ Property Name="DALNameSpace" Type="System.String" Category="Data" Description="DAL Namespace." %>
<%@ Property Name="IncludeDatabaseFeatures" Type="MoM.Templates.DatabaseType" Category="02. Framework Generation - Optional" Description="Indicates which database specific features to generate." Default="None" %>
<%
	// Name of the table being worked on.
	string name = SourceView.Name;
		
	string className = GetClassName(SourceView);
	string abstractRepositoryClassName = "Sql" + GetClassName(SourceView, ClassNameFormat.ProviderBase);
	string providerName = GetClassName(SourceView, ClassNameFormat.Provider);
	string providerBaseName = "Sql" + GetClassName(SourceView, ClassNameFormat.ProviderBase);
	string collectionClassName = GetClassName(SourceView, ClassNameFormat.ViewCollection);
		
	// this array store each Get BY MemberColumns in order to avoid to create doublon Get methods
	System.Collections.ArrayList getbyKeys = new System.Collections.ArrayList();
%>
/*
	File Generated by NetTiers templates [www.nettiers.com]
	<%
	if( IncludeGeneratedDate)
	{
	%>
	Generated on : <%=DateTime.Now.ToLongDateString()%>
	<%
	}
	%>
	Important: Do not modify this file. Edit the file <%=className%>.cs instead.
*/

#region Using directives

using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using Microsoft.Practices.EnterpriseLibrary.Data;
using Microsoft.Practices.EnterpriseLibrary.Data.Sql;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using <%=NameSpace%>;
using <%=DALNameSpace%>.Bases;

#endregion

namespace <%=DALNameSpace%>.SqlClient
{
/// <summary>
///	This class is the base repository for the CRUD operations on the <%=className%> objects.
/// </summary>
public abstract partial class <%=providerBaseName%> : <%=GetClassName(SourceView, ClassNameFormat.ProviderBase)%>
{
	
	string _connectionString;
    bool _useStoredProcedure;
    string _providerInvariantName;
		
	#region Constructors
	
	/// <summary>
	/// Creates a new <see cref="<%=providerBaseName%>"/> instance.
	/// Uses connection string to connect to datasource.
	/// </summary>
	protected <%=providerBaseName%>()
	{		
	}
	
	/// <summary>
	/// Creates a new <see cref="<%=providerBaseName%>"/> instance.
	/// Uses connection string to connect to datasource.
	/// </summary>
	/// <param name="connectionString">The connection string to the database.</param>
	/// <param name="useStoredProcedure">A boolean value that indicates if we use the stored procedures or embedded queries.</param>
	/// <param name="providerInvariantName">Name of the invariant provider use by the DbProviderFactory.</param>
	public <%=providerBaseName%>(string connectionString, bool useStoredProcedure, string providerInvariantName)
	{
		this._connectionString = connectionString;
		this._useStoredProcedure = useStoredProcedure;
		this._providerInvariantName = providerInvariantName;
	}
			
	#endregion 
	
	#region Public properties
	/// <summary>
    /// Gets or sets the connection string.
    /// </summary>
    /// <value>The connection string.</value>
    public string ConnectionString
	{
		get {return this._connectionString;}
		set {this._connectionString = value;}
	}
	
	/// <summary>
    /// Gets or sets a value indicating whether to use stored procedures.
    /// </summary>
    /// <value><c>true</c> if we choose to use use stored procedures; otherwise, <c>false</c>.</value>
	public bool UseStoredProcedure
	{
		get {return this._useStoredProcedure;}
		set {this._useStoredProcedure = value;}
	}
	
	/// <summary>
    /// Gets or sets the invariant provider name listed in the DbProviderFactories machine.config section.
    /// </summary>
    /// <value>The name of the provider invariant.</value>
    public string ProviderInvariantName
    {
        get { return this._providerInvariantName; }
        set { this._providerInvariantName = value; }
    }
	#endregion
		
	
	<%/*	
		-------------------------------
		GET LIST FUNCTIONS
		-------------------------------
	*/%>
<% if (IncludeGetList) { %>
	#region <%= MethodNames.GetAll %> Methods
	
	/// <summary>
	/// 	Gets All rows from the DataSource.
	/// </summary>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="count">The total number of rows in the data source</param>
	/// <remarks></remarks>
	/// <returns>Returns a typed collection of <%=className%> objects.</returns>
	public override <%=collectionClassName%> <%= MethodNames.GetAll %>(TransactionManager transactionManager, int start, int pageLength, out int count)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "<%=ProcedurePrefix + GetCleanName(name) + SelectSuffix + SelectAllSuffix%>", _useStoredProcedure);
		
		IDataReader reader = null;
		//Create Collection
		<%=collectionClassName%> rows = new <%=collectionClassName%>();
		
		try
		{
			if (transactionManager != null)
			{
				reader = Utility.ExecuteReader(transactionManager, commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}
		
			Fill(reader, rows, start, pageLength);
			count = rows.Count;

			if(reader.NextResult())
			{
				if(reader.Read())
				{
					count = reader.GetInt32(0);
				}
			}
		}
		finally
		{
			if (reader != null)
				reader.Close();
		}
		return rows;
	}//end getall
	
	#endregion
	
	#region <%= MethodNames.Get %> Methods
			
	/// <summary>
	/// Gets a page of rows from the DataSource.
	/// </summary>
	/// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
	/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="count">The total number of rows in the data source</param>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <remarks></remarks>
	/// <returns>Returns a typed collection of <%=className%> objects.</returns>
	public override <%=collectionClassName%> <%= MethodNames.Get %>(TransactionManager transactionManager, string whereClause, string orderBy, int start, int pageLength, out int count)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "<%=ProcedurePrefix + GetCleanName(name) + SelectSuffix%>", _useStoredProcedure);

		database.AddInParameter(commandWrapper, "@WhereClause", DbType.String, whereClause);
		database.AddInParameter(commandWrapper, "@OrderBy", DbType.String, orderBy);
		<% if ( IncludeDatabaseFeatures == MoM.Templates.DatabaseType.SQLServer2005 ) { %>
		database.AddInParameter(commandWrapper, "@PageIndex", DbType.Int32, start);
		database.AddInParameter(commandWrapper, "@PageSize", DbType.Int32, pageLength);
		<% } %>
	
		IDataReader reader = null;
		//Create Collection
		<%=collectionClassName%> rows = new <%=collectionClassName%>();
		
		try
		{
			if (transactionManager != null)
			{
				reader = Utility.ExecuteReader(transactionManager,commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}

			<% if ( IncludeDatabaseFeatures == MoM.Templates.DatabaseType.SQLServer2005 ) { %>
			Fill(reader, rows, 0, int.MaxValue);
			<% } else { %>
			Fill(reader, rows, start, pageLength);
			<% } %>
			count = rows.Count;

			if(reader.NextResult())
			{
				if(reader.Read())
				{
					count = reader.GetInt32(0);
				}
			}
		}
		finally
		{
		     if (reader != null)
		     	 reader.Close();
		}
		return rows;
	}
	
	#endregion
	
<% } //end IncludeGetList %>
<% if ( IncludeFind ) { %>
	#region <%= MethodNames.Find %> Methods
	
	#region Parameterized <%= MethodNames.Find %> Methods
	
	/// <summary>
	/// 	Returns rows from the DataSource that meet the parameter conditions.
	/// </summary>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <param name="parameters">A collection of <see cref="SqlFilterParameter"/> objects.</param>
	/// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="count">out. The number of rows that match this query.</param>
	/// <returns>Returns a typed collection of <%= className %> objects.</returns>
	public override <%=collectionClassName%> <%= MethodNames.Find %>(TransactionManager transactionManager, IFilterParameterCollection parameters, string orderBy, int start, int pageLength, out int count)
	{
		SqlFilterParameterCollection filter = null;
		
		if (parameters == null)
			filter = new SqlFilterParameterCollection();
		else 
			filter = parameters.GetParameters();
			
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "<%= ProcedurePrefix + GetCleanName(name) + FindSuffix %>_Dynamic", typeof(<%= className %>Column), filter, orderBy, start, pageLength);
		
		SqlFilterParameter param;

		for ( int i = 0; i < filter.Count; i++ )
		{
			param = filter[i];
			database.AddInParameter(commandWrapper, param.Name, param.DbType, param.GetValue());
		}

		<%= collectionClassName %> rows = new <%= collectionClassName %>();
		IDataReader reader = null;
		
		try
		{
			if ( transactionManager != null )
			{
				reader = Utility.ExecuteReader(transactionManager, commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}
			
			<% if ( IncludeDatabaseFeatures == MoM.Templates.DatabaseType.SQLServer2005 ) { %>
			Fill(reader, rows, 0, int.MaxValue);
			<% } else { %>
			Fill(reader, rows, start, pageLength);
			<% } %>
			count = rows.Count;
			
			if ( reader.NextResult() )
			{
				if ( reader.Read() )
				{
					count = reader.GetInt32(0);
				}
			}
		}
		finally
		{
			if ( reader != null )
				reader.Close();
		}
		
		return rows;
	}
	
	#endregion Parameterized <%= MethodNames.Find %> Methods

	#endregion 

<% } // end if ( IncludeFind ) { %>
<%/*---------------------------------------------------------------------------------
							CUSTOM STORED PROCEDURES
  -------------------------------------------------------------------------------*/ %>
<% if (IncludeCustoms) { %>
	#region Custom Methods
	
<% 
		System.Collections.IDictionary procs = GetCustomProcedures(SourceView);
		foreach(System.Collections.DictionaryEntry item in procs)
		{
			CommandSchema command = (CommandSchema) item.Value;
			string methodName  = item.Key.ToString();		
			string returnType = GetReturnCustomProcReturnType(CustomNonMatchingReturnType, SourceView, command);
			string returnTypeForComment = returnType.Replace("<", "&lt;").Replace(">", "&gt;");
%>

	#region <%=command.Name%>
	
	/// <summary>
	///	This method wrap the '<%=command.Name%>' stored procedure. 
	/// </summary><%=TransformStoredProcedureInputsToMethodComments(command.InputParameters)%>
	/// <param name="start">Row number at which to start reading.</param>
	/// <param name="pageLength">Number of rows to return.</param>
	/// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
	/// <remark>This method is generate from a stored procedure.</remark><% if (returnType != "void") {%>
		/// <returns>A <see cref="<%=returnTypeForComment%>"/> instance.</returns><%}%>
	public override <%=returnType%> <%=methodName%>(TransactionManager transactionManager, int start, int pageLength <%=TransformStoredProcedureInputsToMethod(true, command.InputParameters)%>)
	{
		SqlDatabase database = new SqlDatabase(this._connectionString);
		DbCommand commandWrapper = database.GetStoredProcCommand("<%=command.Name%>");
		
		<% foreach(ParameterSchema col in command.InputParameters)	{ %>
		database.AddInParameter(commandWrapper, "<%=col.Name%>", <%=GetDbType(col)%>,  <%=GetFieldName(col)%> );
		<%}%>

		try
		{
			<% if (returnType == "DataSet") { %>
			DataSet ds = null;
			
			if (transactionManager != null)
			{	
				ds = Utility.ExecuteDataSet(transactionManager, commandWrapper);
			}
			else
			{
				ds = Utility.ExecuteDataSet(database, commandWrapper);
			}
			return ds;	
			<% } else if (returnType == "IDataReader") { %>
			IDataReader dr = null;
			
			if (transactionManager != null)
			{	
				dr = Utility.ExecuteReader(transactionManager,commandWrapper);
			}
			else
			{
				dr = Utility.ExecuteReader(database, commandWrapper);
			}
			return dr;
			<% } else if (returnType == "void") { %>
			if (transactionManager != null)
			{	
				Utility.ExecuteNonQuery(transactionManager, commandWrapper);
			}
			else
			{
				Utility.ExecuteNonQuery(database, commandWrapper);
			}
			return;
			<% } else if 	(returnType == collectionClassName) { %>
			IDataReader reader = null;

			if (transactionManager != null)
			{	
				reader = Utility.ExecuteReader(transactionManager, commandWrapper);
			}
			else
			{
				reader = Utility.ExecuteReader(database, commandWrapper);
			}			
			
			//Create Collection
			<% if (returnType == collectionClassName) {%>
				<%=collectionClassName%> rows = new <%=collectionClassName%>();
				try
				{    
					Fill(reader, rows, start, pageLength);
				}
				finally
				{
					if (reader != null) 
						reader.Close();
				}
				return rows;
				<%} else if (returnType != "void"){%>
				<%=returnType%> tmp = null;
				try
				{
					reader.Read();
					tmp = (<%=returnType%>)reader[0];
				}finally {reader.Close();}
				return tmp;
				<% } %>		
			<% } %>
		}
		catch(SqlException ex)
		{
			throw new DataException("An data access error occured, please check inner SqlException.", ex);
		}
	}
	#endregion
<%
	}
%>

	#endregion

<% } // endif IncludeCustoms %>

	}//end class
} // end namespace
